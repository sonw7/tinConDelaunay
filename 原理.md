



--------------------



![image-20230829154433392](./assets/image-20230829154433392-1716820261732-2-1716963385690-1.png)

```
public static void main(String []args) throws Exception {
    IncrementalTin tin = new IncrementalTin(1.0);
    List<Vertex>vertexList = TestVertices.makeRandomVertices(100, 0);
    tin.add(vertexList, null);
    TinRenderingUtility.drawTin(tin, 500, 500, new File("tin.png"));
}
```

# é—®é¢˜æ±‡æ€»

## 1ã€åˆæˆç‚¹çš„å‡ºç°--å¾·åŠ³å†…ç»†åŒ–ç®—æ³•

![image-20230829154547739](./assets/image-20230829154547739-1716820295651-2.png)

![image-20230830090038913](./assets/image-20230830090038913.png)



![image-20230830090137723](./assets/image-20230830090137723.png)

ç›®å‰ï¼Œåªæœ‰åœ¨æ·»åŠ çº¦æŸæ—¶æ‰ä¼šå¼•å…¥åˆæˆé¡¶ç‚¹ã€‚é¡¶ç‚¹æ˜¯éœ€è¦çš„ï¼Œä»¥ç¡®ä¿ä¸‰è§’å‰–åˆ†ä¿ç•™Delaunayå‡†åˆ™ã€‚ä¸è¿‡ï¼Œå¦‚æœä½ æ„¿æ„ï¼Œä½ å¯ä»¥å…³é—­è¿™ä¸ªåŠŸèƒ½ã€‚åœ¨Incremental Tinç±»ä¸­ï¼Œå¯¹â€œaddConstraintsâ€çš„è°ƒç”¨æœ‰ä¸¤ä¸ªå‚æ•°ã€‚ç¬¬äºŒï¼Œâ€œæ¢å¤ä¸€è‡´æ€§â€æ§åˆ¶æ˜¯å¦ç”Ÿæˆåˆæˆç‚¹ã€‚å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚è§https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/index.html

ä¸ºäº†è¯´æ˜ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯èƒ½è¦æ·»åŠ åˆæˆç‚¹ï¼Œæˆ‘é™„ä¸Šä¸€å¼ å›¾ç‰‡ä»ç½‘ç»œæ–‡ç« [ä»€ä¹ˆæ˜¯çº¦æŸDelaunay](https://gwlucastrig.github.io/TinfourDocs/DelaunayIntroCDT/index.html). æ·»åŠ çº¦æŸæ—¶ï¼Œå®ƒå¯èƒ½å¼•å…¥ä¸ç¬¦åˆDelaunayå‡†åˆ™çš„ä¸‰è§’å½¢ã€‚ä½†æˆ‘ä»¬ä¸éœ€è¦æ·»åŠ åˆæˆé¡¶ç‚¹ï¼Œé™¤éæˆ‘ä»¬æƒ³è¦ä¸‰è§’å‰–åˆ†æ¥ä¿æŒDelaunayå…¼å®¹ã€‚

![image-20230830091101259](./assets/image-20230830091101259.png)çœ‹äº†ä½ ä¹‹å‰çš„é—®é¢˜ï¼Œï¼ˆè®¨è®º[#100](https://github.com/gwlucastrig/Tinfour/discussions/100))ï¼Œæˆ‘æƒ³æˆ‘å¯èƒ½æ²¡æœ‰ç†è§£ä½ çš„æ„æ€ï¼Œè€Œä¸”æˆ‘å¯¹æœ¯è¯­çš„ä½¿ç”¨ä¹Ÿä¸æ¸…æ¥šã€‚

ç›®å‰ï¼Œä»…å½“åº”ç”¨ç¨‹åºå°†çº¦æŸæ·»åŠ åˆ°ä¸‰è§’æµ‹é‡ï¼Œå¹¶ä¸”ä»…å½“åº”ç”¨ç¨‹åºæŒ‡ç¤ºè¦æ¢å¤ç»“æœçš„DelaunayæŸ”åº¦æ—¶ï¼Œæ‰ä¼šæ·»åŠ åˆæˆç‚¹ã€‚æ‚¨å¯ä»¥é€šè¿‡å°†restore Configurationé€‰é¡¹è®¾ç½®ä¸ºtrueæ¥æ§åˆ¶æ˜¯å¦å‘ç”Ÿè¿™ç§æƒ…å†µã€‚

æœ¯è¯­â€œå¾·åŠ³å†…ç»†åŒ–â€ï¼Œè‡³å°‘åœ¨æˆ‘ä½¿ç”¨å®ƒï¼ŒæŒ‡çš„æ˜¯ä¸€ç§ä¸åŒçš„æŠ€æœ¯ã€‚åœ¨Delaunayç»†åŒ–ä¸­ï¼Œæ‚¨æœ‰ä¸€ä¸ªå¸¦æœ‰çª„ä¸‰è§’å½¢çš„Delaunayä¸‰è§’ç½‘ï¼ˆä¾‹å¦‚åœ¨è¾¹ç•Œé™„è¿‘å‡ºç°çš„ä¸‰è§’å½¢ï¼‰ï¼Œæ‚¨å¯ä»¥é€šè¿‡åœ¨æœ€ä½³ä½ç½®æ’å…¥äººå·¥"Steinerç‚¹"æ¥æ”¹è¿›ä¸‰è§’å½¢çš„å½¢çŠ¶ã€‚æˆ‘æƒ³å®ç°è¿™ä¸ªåŠŸèƒ½å¾ˆä¹…äº†ï¼Œä½†æ˜¯ä¸€ç›´æ²¡èƒ½å®ç°ã€‚æˆ‘å¸Œæœ›å®ƒèƒ½åœ¨2024å¹´åˆå¼€å§‹å·¥ä½œã€‚

![image-20230830091124622](./assets/image-20230830091124622.png)

è¿˜æœ‰ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œå¯èƒ½ä¼šå‡ºç°äººå·¥ç‚¹ã€‚å¦‚æœä¸€ä¸ªåº”ç”¨ç¨‹åºè¯•å›¾å°†ä¸¤ä¸ªé å¾—å¤ªè¿‘ï¼ˆæˆ–å®Œå…¨é‡åˆï¼‰çš„é¡¶ç‚¹æ’å…¥åˆ°ä¸‰è§’ç½‘ä¸­ï¼Œå¢é‡TINç±»å°†åˆ›å»ºä¸€ä¸ªâ€œåˆå¹¶é¡¶ç‚¹â€æ¥å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªç‚¹ä¸­ã€‚å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œé€šå¸¸åªå â€œæ˜¾ç€ç‚¹é—´è·â€çš„100ä¸‡åˆ†ä¹‹ä¸€ã€‚-å½“ä¸€å¯¹æˆ–ä¸€ç°‡ç‚¹é å¾—é‚£ä¹ˆè¿‘æ—¶ï¼Œæ•°å€¼é—®é¢˜å¼€å§‹é™ä½ç®—æ³•çš„æ€§èƒ½ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠå®ƒä»¬å½“ä½œä¸€ä¸ªå•ç‚¹

### è§£å†³åŠæ³•

![image-20230830103233134](./assets/image-20230830103233134.png)

![image-20230830103319526](./assets/image-20230830103319526.png)

ä½œè€…è¯´æ˜ åªæœ‰æ·»åŠ çº¦æŸçš„æ—¶å€™å¯èƒ½äº§ç”Ÿåˆæˆç‚¹ã€‚ç”±tinä¸­çš„addConstraints()å‡½æ•°å†³å®š

![image-20230830103459805](./assets/image-20230830103459805.png)

æ ¹æ®ä½œè€…æè¿°ç¬¬äºŒä¸ªå‚æ•°æ§åˆ¶å‡½æ•°ç»†åŒ–ä¸å¦ã€‚è®¾ä¸ºfalseä»¥åï¼Œæ— åˆæˆç‚¹å‡ºç°ã€‚

```
addConstraints(list<>,false)//ç¬¬äºŒä¸ªå‚æ•°ï¼Œç¦ç”¨æ¢å¤ä¸€è‡´æ€§ï¼Œå³ä¸ä¼šç”Ÿæˆåˆæˆç‚¹ã€‚

```

## 2ã€ä»€ä¹ˆæ˜¯å¹½çµç‚¹

åœ¨è®¡ç®—å‡ ä½•å’Œç‰¹åˆ«æ˜¯ä¸‰è§’å‰–åˆ†ä¸­ï¼Œå¹½çµç‚¹ï¼ˆä¹Ÿç§°ä¸ºè™šæ‹Ÿç‚¹æˆ–è¶…çº§ç‚¹ï¼‰æ˜¯ä¸€ç§è¾…åŠ©æ€§çš„æ¦‚å¿µï¼Œç”¨äºç®€åŒ–æŸäº›ç®—æ³•çš„åˆå§‹åŒ–å’Œè¾¹ç•Œæ¡ä»¶å¤„ç†ã€‚å¹½çµç‚¹ä¸ä»£è¡¨å®é™…çš„æ•°æ®ç‚¹ï¼Œè€Œæ˜¯ç”¨æ¥æ„é€ ä¸€ä¸ªåŒ…å«æ‰€æœ‰å®é™…æ•°æ®ç‚¹çš„åˆå§‹å¤§ä¸‰è§’å½¢æˆ–å››è¾¹å½¢ã€‚

åœ¨ Tinfour åº“ä¸­ï¼Œå®ç° Delaunay ä¸‰è§’å‰–åˆ†æ—¶å¯èƒ½ä¼šä½¿ç”¨åˆ°å¹½çµç‚¹ã€‚è¯¥åº“çš„ä¸€äº›ç‰ˆæœ¬ä¸ºäº†åˆå§‹åŒ–ä¸‰è§’å‰–åˆ†åˆ›å»ºäº†ä¸€ä¸ªè¶…çº§ä¸‰è§’å½¢ï¼Œå®ƒæ˜¯ä¸€ä¸ªå·¨å¤§çš„ä¸‰è§’å½¢ï¼Œå…¶é¡¶ç‚¹æ˜¯å¹½çµç‚¹ï¼Œè¶³å¤Ÿå¤§ä»¥ç¡®ä¿åŒ…å«æ‰€æœ‰çš„è¾“å…¥æ•°æ®ç‚¹ã€‚åœ¨ç®—æ³•è¿è¡Œç»“æŸåï¼Œè¿™ä¸ªè¶…çº§ä¸‰è§’å½¢ä»¥åŠä¸ä¹‹ç›¸å…³è”çš„å¹½çµç‚¹ä¼šè¢«ç§»é™¤ï¼Œç•™ä¸‹ç”±æ•°æ®ç‚¹å½¢æˆçš„çœŸæ­£çš„ Delaunay ä¸‰è§’ç½‘ã€‚

è¿™ç§æ–¹æ³•æœ‰ä»¥ä¸‹ä¼˜ç‚¹ï¼š

1. **ç®€åŒ–**: é€šè¿‡ä½¿ç”¨å¹½çµç‚¹ï¼Œå¯ä»¥é¿å…å¤„ç†ç‰¹æ®Šæƒ…å†µå’Œè¾¹ç•Œé—®é¢˜ï¼Œå› ä¸ºæ‰€æœ‰çš„æ•°æ®ç‚¹éƒ½è¢«è§†ä¸ºå†…éƒ¨ç‚¹ã€‚
2. **æœ‰æ•ˆæ€§**: åˆå§‹åŒ–æ­¥éª¤å˜å¾—ç®€å•é«˜æ•ˆï¼Œä¾¿äºç®—æ³•å¼€å§‹æ·»åŠ å®é™…çš„æ•°æ®ç‚¹å¹¶è°ƒæ•´ä¸‰è§’å½¢ç»“æ„ã€‚

åœ¨ Tinfour çš„ `IncrementalTin` ç±»æˆ–å…¶ä»–ç±»ä¼¼ç»„ä»¶ä¸­ï¼Œå¹½çµç‚¹å¯èƒ½è¢«éšå¼åœ°å¼•å…¥å’Œç®¡ç†ã€‚å¦‚æœä½ æ­£åœ¨ä½¿ç”¨è¿™ä¸ªåº“ï¼Œé€šå¸¸ä¸éœ€è¦ç›´æ¥å…³å¿ƒå¹½çµç‚¹çš„å¤„ç†ï¼Œå› ä¸ºè¿™æ˜¯åº“å†…éƒ¨é€»è¾‘çš„ä¸€éƒ¨åˆ†ã€‚

æœ€ç»ˆï¼Œå½“æ‰€æœ‰çš„æ•°æ®ç‚¹å·²ç»è¢«æ’å…¥å¹¶ä¸”ä¸‰è§’å‰–åˆ†å®Œæˆåï¼Œä¸å¹½çµç‚¹ç›¸å…³çš„ä¸‰è§’å½¢ä¼šè¢«ä»ç»“æœä¸­æ’é™¤ï¼Œä»è€Œç”Ÿæˆä¸€ä¸ªåæ˜ è¾“å…¥æ•°æ®é›†çš„çº¯å‡€ Delaunay ä¸‰è§’å‰–åˆ†ã€‚

## 3ã€åœ¨æ·»åŠ å®Œç¦»æ•£ç‚¹ä»¥åï¼Œæ·»åŠ å†…å¤–çº¦æŸè¾¹ç•Œï¼Œç®—æ³•æµç¨‹æ˜¯æ€æ ·çš„

åœ¨ æ·»åŠ ç¦»æ•£ç‚¹åï¼Œæ’å…¥çº¦æŸè¾¹ç•Œçš„è¿‡ç¨‹æ¶‰åŠä¿®æ”¹ç°æœ‰çš„ä¸‰è§’å‰–åˆ†ä»¥ç¡®ä¿æ‰€æœ‰çº¦æŸè¾¹ç•Œéƒ½å¾—åˆ°æ°å½“çš„è¡¨ç¤ºã€‚è¿™ä¸€è¿‡ç¨‹é€šå¸¸åŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š

1. æ‰¾åˆ°çº¦æŸè¾¹ç•Œç›¸äº¤çš„ä¸‰è§’å½¢

ç®—æ³•é¦–å…ˆç¡®å®šæ¯ä¸ªçº¦æŸè¾¹ç•Œç›¸äº¤çš„ä¸‰è§’ç½‘ä¸­å·²å­˜åœ¨çš„è¾¹å’Œä¸‰è§’å½¢ã€‚çº¦æŸè¾¹ç•Œå¯èƒ½ä¼šç©¿è¿‡å¤šä¸ªä¸‰è§’å½¢ï¼Œå› æ­¤éœ€è¦å¯¹æ¯ä¸ªä¸‰è§’å½¢è¿›è¡Œæ£€æŸ¥å¹¶å¤„ç†ã€‚

2. åˆ‡å‰²ç›¸äº¤çš„ä¸‰è§’å½¢

å½“ä¸€ä¸ªçº¦æŸè¾¹ç•Œä¸ä¸€ä¸ªä¸‰è§’å½¢çš„è¾¹ç›¸äº¤æ—¶ï¼Œè¯¥ä¸‰è§’å½¢éœ€è¦è¢«åˆ‡å‰²ã€‚è¿™æ¶‰åŠåˆ°åˆ é™¤åŸæœ‰çš„ä¸‰è§’å½¢ï¼Œå¹¶åˆ›å»ºæ–°çš„ä¸‰è§’å½¢ï¼Œè¿™äº›ä¸‰è§’å½¢ç¬¦åˆç”±çº¦æŸè¾¹ç•Œå¼•å…¥çš„æ–°è¾¹ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¯èƒ½è¿˜ä¼šä¸ºäº†ä¿æŒ Delaunay æ¡ä»¶è€Œæ’å…¥é¢å¤–çš„é¡¶ç‚¹ã€‚

3. è°ƒæ•´ç›¸é‚»çš„ä¸‰è§’å½¢

ç”±äºçº¦æŸè¾¹ç•Œçš„æ’å…¥ï¼Œç›¸é‚»çš„ä¸‰è§’å½¢å¯èƒ½éœ€è¦é‡æ–°è°ƒæ•´æ¥é€‚åº”æ–°çš„è¾¹ã€‚è¿™å¯èƒ½æ¶‰åŠç¿»è½¬è¾¹ï¼ˆedge flippingï¼‰æˆ–é‡æ–°æ„é€ ä¸€äº›ä¸‰è§’å½¢ä»¥ç¡®ä¿æ•´ä¸ªç½‘ç»œä»ç„¶æ˜¯ Delaunay çš„ã€‚

4. åˆ›å»ºæ–°çš„è¾¹è¿æ¥

åœ¨çº¦æŸè¾¹ç•Œçš„ä¸¤ç«¯ç‚¹ä¹‹é—´åˆ›å»ºæ–°çš„è¾¹ï¼Œä»¥ç¡®ä¿çº¦æŸå¾—åˆ°å®Œå…¨ä½“ç°ã€‚å¦‚æœçº¦æŸè¾¹ç•Œæ˜¯å°é—­çš„ï¼Œåˆ™éœ€è¦ä¿è¯å½¢æˆä¸€ä¸ªå°é—­ç¯ã€‚

5. ç¡®ä¿çº¦æŸä¸å¯ç©¿è¶Š

ç®—æ³•å¿…é¡»ç¡®ä¿çº¦æŸè¾¹ç•Œæ˜¯ä¸å¯ç©¿è¶Šçš„ã€‚è¿™æ„å‘³ç€æ²¡æœ‰å…¶ä»–çš„è¾¹å¯ä»¥ç©¿è¿‡è¿™ä¸ªè¾¹ç•Œã€‚åœ¨ä¸‰è§’å‰–åˆ†ä¸­ï¼Œè¿™æ„å‘³ç€ç›¸å…³çš„ä¸‰è§’å½¢å¿…é¡»æ­£ç¡®åœ°è¾¹æ¥æˆ–æ’åˆ—ï¼Œä»¥é˜²æ­¢ä»»ä½•ç©¿è¶Šå‘ç”Ÿã€‚

6. æ›´æ–°æ•°æ®ç»“æ„

åœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­ï¼ŒTinfour éœ€è¦æ›´æ–°å…¶å†…éƒ¨æ•°æ®ç»“æ„ï¼Œå¦‚è¾¹çš„é“¾è¡¨ã€é¡¶ç‚¹çš„ä½ç½®ç´¢å¼•ç­‰ï¼Œä»¥åæ˜ é€šè¿‡æ·»åŠ çº¦æŸè¾¹ç•Œæ‰€åšçš„æ”¹å˜ã€‚

7. æ¸…ç†å’Œä¼˜åŒ–

æœ€åï¼Œå¯èƒ½éœ€è¦æ‰§è¡Œæ¸…ç†å’Œä¼˜åŒ–æ­¥éª¤ï¼Œç§»é™¤ç”±äºæ·»åŠ çº¦æŸè¾¹ç•Œè€Œä¸å†éœ€è¦çš„è¾¹å’Œé¡¶ç‚¹ï¼Œä»¥åŠå¯èƒ½çš„å±€éƒ¨ä¼˜åŒ–ï¼Œä»¥ç¡®ä¿ä¸‰è§’ç½‘çš„è´¨é‡ã€‚

è¿™ä¸ªè¿‡ç¨‹åœ¨å‡ ä½•å­¦å’Œè®¡ç®—ä¸Šå¯èƒ½éå¸¸å¤æ‚ï¼Œéœ€è¦ç²¾ç¡®åœ°å¤„ç†å„ç§ç‰¹æ®Šæƒ…å†µã€‚Tinfour åº“çš„å®ç°ç»†èŠ‚æ¶‰åŠå¤§é‡çš„æ•°æ®ç»“æ„æ“ä½œå’Œå‡ ä½•è®¡ç®—ï¼Œå®ƒä»¬é€šå¸¸è¢«å°è£…åœ¨åº“çš„å†…éƒ¨ç±»å’Œæ–¹æ³•ä¸­ã€‚å¯¹äºä½¿ç”¨è€…æ¥è¯´ï¼Œè¿™äº›ç»†èŠ‚è¢«æŠ½è±¡åŒ–äº†ï¼Œæ‰€ä»¥åªéœ€é€šè¿‡ç®€å•çš„ API è°ƒç”¨å³å¯å®Œæˆå¤æ‚çš„æ“ä½œã€‚

è¯·æ³¨æ„ï¼Œä»¥ä¸Šæè¿°çš„æ­¥éª¤æ˜¯ä¸€èˆ¬æ€§çš„ï¼Œå¹¶ä¸”å¯èƒ½æ ¹æ®å…·ä½“æƒ…å†µå’Œåº“çš„å®é™…å®ç°æœ‰æ‰€ä¸åŒã€‚ è‹¥è¦è·å¾— Tinfour å¤„ç†çº¦æŸè¾¹ç•Œçš„ç²¾ç¡®å®ç°ç»†èŠ‚ï¼Œæœ€å¥½çš„èµ„æºæ˜¯åº“çš„æºä»£ç å’Œç›¸å…³æ–‡æ¡£ã€‚

## 4 å†…å¤–è¾¹ç•Œ



# æ€è€ƒ

1ã€ç¨‹åºä¸­å‰–åˆ†ç›¸å…³çš„APIé€»è¾‘é€šé¡º (å°½é‡15å¤©)ã€‚

2ã€åœ°è´¨ä¸Šçš„åº”ç”¨ï¼Ÿ

3ã€å½“å‰ä½¿ç”¨çš„ç¨‹åºæ˜¯å¦èƒ½æœ‰æ”¹è¿›ï¼Ÿç®—æ³•æœ¬èº«çš„é€»è¾‘ä¼˜åŒ–ï¼Ÿæ€§èƒ½çš„ä¼˜åŒ–?

4ã€åº”ç”¨åœºæ™¯ä¸Šçš„é—®é¢˜ï¼Ÿ

5ã€é‡åˆ°çš„åœ°è´¨é—®é¢˜ï¼ˆæ¯”å¦‚å†…è¾¹ç•Œäº¤å‰ï¼‰ç»“åˆCDT

# ä¸€ã€ä¸»è¦ç ”ç©¶å†…å®¹

## 1ã€å†…å¤–è¾¹ç•Œé¡ºåº-----------------------------

- **å¤–è¾¹ç•Œ**ç¦»æ•£ç‚¹å¿…é¡»æŒ‰ç…§**é€†æ—¶é’ˆ**
- **å†…è¾¹ç•Œ**ç¦»æ•£ç‚¹å¿…é¡»æŒ‰ç…§**é¡ºæ—¶é’ˆ**

![image-20240609212417053](./assets/image-20240609212417053.png)



æ·»åŠ çš„å†…è¾¹ç•Œç‚¹ï¼Œèµ·åˆæ˜¯é€†æ—¶é’ˆï¼Œå˜æˆäº†é¡ºæ—¶é’ˆã€‚

<img src="./assets/image-20240609214108533.png" alt="image-20240609214108533" style="zoom:50%;" />

![image-20240612220418042](./assets/image-20240612220418042.png)

```
ç»è¿‡Qgisçš„æŸ¥çœ‹ï¼Œ
æ–‡ä»¶ä¸­çš„å¤–è¾¹ç•Œæ˜¯é¡ºæ—¶é’ˆ
æ–‡ä»¶ä¸­çš„å†…è¾¹ç•Œæ˜¯é€†æ—¶é’ˆ

æ‰€ä»¥ä½¿ç”¨çš„æ˜¯åŒä¸€ä¸ªæ·»åŠ è¾¹ç•Œçš„æ–¹æ³•ï¼Œè¿›è¡Œäº†é¡ºåºé¢ å€’ã€‚
addOutBounds(outlinesTopVertices,cListTop);
addOutBounds(innerlinesTopVertices,cListTop);

è¿™æ ·çš„è¯æ·»åŠ è¿›çš„å¤–è¾¹ç•Œæ˜¯é€†æ—¶é’ˆï¼Œæ·»åŠ è¿›å»çš„å†…è¾¹ç•Œæ˜¯é¡ºæ—¶é’ˆ
ç¬¦åˆé€»è¾‘
```





## 2ã€coreæ ¸å¿ƒä»£ç ç›®å½•ç»“æ„

| Package                                                      | Description                                                  |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [org.tinfour.common](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/common/package-summary.html) | æä¾›å¯¹Tinforé¡¹ç›®ä¸­çš„å¤šä¸ªåŒ…é€šç”¨çš„ç±»æˆ–è€…æ¥å£ã€‚                 |
| [org.tinfour.contour](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/contour/package-summary.html) | æä¾›æ”¯æŒDelaunay ä¸‰è§’å‰–åˆ†çš„è½®å»“ç»˜åˆ¶ç±»                        |
| [org.tinfour.edge](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/edge/package-summary.html) | æä¾›å…·æœ‰æ”¯æŒæ•°æ®ç®¡ç†ç±»çš„IQuadEdgeæ¥å£çš„å®ç°ã€‚                |
| [org.tinfour.interpolation](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/interpolation/package-summary.html) | æä¾›ç”¨äºåœ¨TINä¸Šæ‰§è¡Œæ’å€¼çš„æ¥å£å’Œæ”¯æŒç±»                        |
| [org.tinfour.io](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/io/package-summary.html) | ä¸I/Oæ“ä½œç›¸å…³çš„å®ç”¨ç¨‹åº                                      |
| [org.tinfour.semivirtual](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/semivirtual/package-summary.html) | æä¾›ç±»å’Œæ¥å£ï¼Œ<br />ç”¨äºåŸºäºDelaunayä¸‰è§’å‰–åˆ†è§„èŒƒåˆ›å»ºä¸è§„åˆ™ä¸‰è§’ç½‘ï¼ˆTINï¼‰ï¼Œå¹¶ä½¿ç”¨è¾¹çš„åŠè™šæ‹Ÿè¡¨ç¤ºæ¥**å‡å°‘å†…å­˜éœ€æ±‚**ã€‚ |
| [org.tinfour.standard](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/standard/package-summary.html) | æä¾›<br />ç”¨äºåŸºäºDelaunayä¸‰è§’å‰–åˆ†è§„èŒƒåˆ›å»ºä¸è§„åˆ™ä¸‰è§’ç½‘ï¼ˆTINï¼‰çš„ç±»å’Œæ¥å£ã€‚ |
| [org.tinfour.utils](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/utils/package-summary.html) | ä¸ºä½¿ç”¨Tinfourè½¯ä»¶åŒ…æä¾›é«˜çº§å®ç”¨ç¨‹åºå’Œé€šç”¨å®ç”¨ç¨‹åºã€‚          |
| [org.tinfour.utils.loaders](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/utils/loaders/package-summary.html) | å®šä¹‰æ¥å£å¹¶æä¾›ç”¨äºåŠ è½½æ•°æ®çš„å®ç”¨ç¨‹åº                         |
| [org.tinfour.utils.rendering](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/utils/rendering/package-summary.html) | æä¾›å¸®åŠ©æ¸²æŸ“Tinfourå’Œç›¸å…³åº”ç”¨ç¨‹åºå›¾å½¢çš„å®ç”¨ç¨‹åºã€‚            |
| [org.tinfour.vividsolutions.jts.math](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/vividsolutions/jts/math/package-summary.html) | æä¾›JTSæ‹“æ‰‘å¥—ä»¶å·¥å…·çš„ä¸´æ—¶åŒ…ã€‚                                |
| [org.tinfour.voronoi](https://gwlucastrig.github.io/TinfourDocs/javadoc/TinfourCore-2.1.6-javadoc/org/tinfour/voronoi/package-summary.html) | å®ç°Voronoiå›¾åŠŸèƒ½çš„å®éªŒåŒ…                                    |

## 3ã€æ ¸å¿ƒ IncrementalTinç±»

```
 * Provides methods and data elements for building and maintaining a
 * Triangulated Irregular Network (TIN) that is optimal with regard to the
 * Delaunay criterion.
 * æä¾›ç”¨äºæ„å»ºå’Œç»´æŠ¤ä¸‰è§’ä¸è§„åˆ™ç½‘ç»œï¼ˆTINï¼‰çš„æ–¹æ³•å’Œæ•°æ®å…ƒç´ ï¼Œè¯¥ç½‘ç»œåœ¨Delaunayæ ‡å‡†æ–¹é¢æ˜¯æœ€ä½³çš„ã€‚
 * <p>
 * The Delaunay Triangulation has several desirable properties and is well
 * documented on the Internet. The TIN produced by this class is meets the
 * Delaunay criterion except in cases where round-off errors due to the limits
 * of floating point calculations result in small deviations from the optimum.
 * Delaunayä¸‰è§’å‰–åˆ†å…·æœ‰å‡ ä¸ªç†æƒ³çš„ç‰¹æ€§ï¼Œå¹¶åœ¨äº’è”ç½‘ä¸Šæœ‰å¾ˆå¥½çš„è®°å½•ã€‚
 * æ­¤ç±»äº§ç”Ÿçš„ä¸‰è§’ç½‘ç¬¦åˆDelaunayæ ‡å‡†ï¼Œé™¤éç”±äºæµ®ç‚¹è®¡ç®—çš„é™åˆ¶è€Œäº§ç”Ÿçš„èˆå…¥è¯¯å·®å¯¼è‡´ä¸æœ€ä½³å€¼çš„å¾®å°åå·®ã€‚
 * <p>
 * There are three major classes of algorithms for creating a Delaunay
 * Triangulation: sweep-line algorithms, divide-and-conquer, and incremental
 * construction. In the incremental algorithm used for this implementation,
 * vertices are added to the TIN one-at-a time. If a vertex lies inside the
 * convex hull of an existing TIN, it is inserted. If the vertex lies to the
 * exterior, the bounds of the TIN is extended to include it. Delaunay
 * optimality is maintained at each step.
 * åˆ›å»ºDelaunayä¸‰è§’å‰–åˆ†çš„ç®—æ³•ä¸»è¦æœ‰ä¸‰ç±»ï¼šæ‰«æ çº¿ç®—æ³•ã€åˆ†æ²»ç®—æ³•å’Œå¢é‡æ„é€ ç®—æ³•ã€‚
 * åœ¨ç”¨äºæ­¤å®ç°çš„å¢é‡ç®—æ³•ä¸­ï¼Œé¡¶ç‚¹ä¸€æ¬¡æ·»åŠ åˆ°ä¸‰è§’ç½‘ä¸­ä¸€ä¸ªã€‚
 * å¦‚æœé¡¶ç‚¹ä½äºç°æœ‰ä¸‰è§’ç½‘çš„å‡¸åŒ…å†…éƒ¨ï¼Œåˆ™ä¼šæ’å…¥è¯¥é¡¶ç‚¹ã€‚
 * å¦‚æœé¡¶ç‚¹ä½äºå¤–éƒ¨ï¼Œåˆ™ä¸‰è§’ç½‘çš„è¾¹ç•Œè¢«æ‰©å±•åˆ°åŒ…æ‹¬å®ƒã€‚åœ¨æ¯ä¸€æ­¥éƒ½ä¿æŒDelaunayæœ€ä¼˜æ€§ã€‚
 * <h1>Memory use and performance</h1>
 * å†…å­˜ä½¿ç”¨å’Œæ€§èƒ½
 * <p>
 * This class was designed to handle cases where the input set includes a large
 * number of vertices. In particular, terrain elevation data sets collected
 * using laser devices (lidar) that typically include multiple millions of data
 * points. With such large input sets, performance and memory-management are
 * critical issues.
 * è¿™ä¸ªç±»è¢«è®¾è®¡ç”¨äºå¤„ç†è¾“å…¥é›†åŒ…å«å¤§é‡é¡¶ç‚¹çš„æƒ…å†µã€‚
 * ç‰¹åˆ«æ˜¯ï¼Œä½¿ç”¨æ¿€å…‰è®¾å¤‡ï¼ˆæ¿€å…‰é›·è¾¾ï¼‰æ”¶é›†çš„åœ°å½¢é«˜ç¨‹æ•°æ®é›†é€šå¸¸åŒ…æ‹¬æ•°ç™¾ä¸‡ä¸ªæ•°æ®ç‚¹ã€‚
 * å¯¹äºå¦‚æ­¤å¤§çš„è¾“å…¥é›†ï¼Œæ€§èƒ½å’Œå†…å­˜ç®¡ç†æ˜¯å…³é”®é—®é¢˜
 * <p>
 * Naturally, memory use and performance varies by hardware, operating system,
 * and Java Virtual Machine (HVM). In 2015, testing lidar data under Windows 7
 * on a computer with a 2.9 GHz Intel i7 processor, 8 gigabytes installed
 * memory, 512 kilobytes of L2 cache memory, and Hotspot JVM, this class
 * routinely delivered a processing rate of 1.1 million vertices per second.
 * Time-complexity for samples smaller than 10 million was nearly linear. Memory
 * use averaged 244 bytes per vertex.
 * å½“ç„¶ï¼Œå†…å­˜çš„ä½¿ç”¨å’Œæ€§èƒ½å› ç¡¬ä»¶ã€æ“ä½œç³»ç»Ÿå’ŒJavaè™šæ‹Ÿæœºï¼ˆHVMï¼‰è€Œå¼‚ã€‚
 * 2015å¹´ï¼Œåœ¨è£…æœ‰2.9 GHz Intel i7å¤„ç†å™¨ã€8GBå®‰è£…å†…å­˜ã€512 KBäºŒçº§ç¼“å­˜å’ŒHotspot JVMçš„è®¡ç®—æœºä¸Šï¼Œåœ¨Windows 7ä¸‹æµ‹è¯•æ¿€å…‰é›·è¾¾æ•°æ®ï¼Œ
 * è¯¥ç±»é€šå¸¸æä¾›æ¯ç§’110ä¸‡ä¸ªé¡¶ç‚¹çš„å¤„ç†ç‡ã€‚
 * å°äº1000ä¸‡ä¸ªæ ·æœ¬çš„æ—¶é—´å¤æ‚åº¦å‡ ä¹æ˜¯çº¿æ€§çš„ã€‚å†…å­˜ä½¿ç”¨å¹³å‡æ¯ä¸ªé¡¶ç‚¹244å­—èŠ‚ã€‚
 * <h2>Memory Use</h2>å†…å­˜ä½¿ç”¨
 * <p>
 * About a third of the memory use by this class when running under Hotspot is
 * due to Java object-related overhead rather than actual data. Software
 * environments such as Java and C# provide automatic garbage collection and
 * memory management. Doing so adds a small amount of memory overhead to each
 * object created. Because the data-size of the objects used to build a TIN
 * (vertices and edges) is also small, this overhead is significant. In a
 * sufficiently large Delaunay Triangulation, the number of edges approaches
 * three per vertex. This implementation uses one object per vertex and two per
 * edge. Although the memory overhead for Java varies for different operating
 * systems and Java Virtual Machines (JVMs), the Hotspot JVM for Windows uses 12
 * bytes per object. Thus for each vertex, it requires (1+3*2)x12 = 84 bytes of
 * overhead.
 * å½“è¿™ä¸ªç±»åœ¨Hotspotä¸‹è¿è¡Œæ—¶ï¼Œå¤§çº¦ä¸‰åˆ†ä¹‹ä¸€çš„å†…å­˜ä½¿ç”¨æ˜¯ç”±äºä¸Javaå¯¹è±¡ç›¸å…³çš„å¼€é”€ï¼Œè€Œä¸æ˜¯å®é™…çš„æ•°æ®ã€‚
 * Javaå’ŒC#ç­‰è½¯ä»¶ç¯å¢ƒæä¾›è‡ªåŠ¨åƒåœ¾æ”¶é›†å’Œå†…å­˜ç®¡ç†ã€‚è¿™æ ·åšä¼šä¸ºåˆ›å»ºçš„æ¯ä¸ªå¯¹è±¡å¢åŠ å°‘é‡å†…å­˜å¼€é”€ã€‚
 * å› ä¸ºç”¨äºæ„å»ºä¸‰è§’ç½‘ï¼ˆé¡¶ç‚¹å’Œè¾¹ï¼‰çš„å¯¹è±¡çš„æ•°æ®å¤§å°ä¹Ÿå¾ˆå°ï¼Œæ‰€ä»¥è¿™ç§å¼€é”€å¾ˆå¤§ã€‚
 * åœ¨è¶³å¤Ÿå¤§çš„Delaunayä¸‰è§’å‰–åˆ†ä¸­ï¼Œæ¯ä¸ªé¡¶ç‚¹çš„è¾¹æ•°æ¥è¿‘ä¸‰æ¡ã€‚
 * æ­¤å®ç°æ¯ä¸ªé¡¶ç‚¹ä½¿ç”¨ä¸€ä¸ªå¯¹è±¡ï¼Œæ¯ä¸ªè¾¹ä½¿ç”¨ä¸¤ä¸ªå¯¹è±¡ã€‚
 * å°½ç®¡Javaçš„å†…å­˜å¼€é”€å› ä¸åŒçš„æ“ä½œç³»ç»Ÿå’ŒJavaè™šæ‹Ÿæœºï¼ˆJVMï¼‰è€Œå¼‚ï¼Œä½†Windowsçš„Hotspot JVMæ¯ä¸ªå¯¹è±¡ä½¿ç”¨12ä¸ªå­—èŠ‚ã€‚
 * å› æ­¤ï¼Œå¯¹äºæ¯ä¸ªé¡¶ç‚¹ï¼Œå®ƒéœ€è¦ï¼ˆ1+3*2ï¼‰x12=84å­—èŠ‚çš„å¼€é”€ã€‚
 * <h2>Performance</h2>
 * <h3>Managing the performance cost of object construction</h3>
 * ç®¡ç†å¯¹è±¡æ„å»ºçš„æ€§èƒ½æˆæœ¬
 * Testing indicates that the most time-consuming part of the TIN construction
 * operation is the construction of Java objects. As noted above, this class
 * requires 6 edge-related objects per vertex. Although this overhead is
 * inescapable when processing a single data set, this class does permit a TIN
 * instance to be reused over-and-over again when processing multiple data sets.
 * A call to the clear() method resets the TIN to an empty state, but preserves
 * the edges already allocated so that they may be reused for the next data set.
 * By doing so, the cost of the up-front construction of edge objects can be
 * amortized over the entire data set, this reducing the processing time for a
 * group of multiple input sets. Applications that do so should be able to
 * improve on the run-time performance values quoted above.
 * æµ‹è¯•è¡¨æ˜ï¼ŒTINæ„å»ºæ“ä½œä¸­æœ€è€—æ—¶çš„éƒ¨åˆ†æ˜¯Javaå¯¹è±¡çš„æ„å»ºã€‚
 * å¦‚ä¸Šæ‰€è¿°ï¼Œæ­¤ç±»æ¯ä¸ªé¡¶ç‚¹éœ€è¦6ä¸ªä¸è¾¹ç›¸å…³çš„å¯¹è±¡ã€‚
 * å°½ç®¡åœ¨å¤„ç†å•ä¸ªæ•°æ®é›†æ—¶è¿™ç§å¼€é”€æ˜¯ä¸å¯é¿å…çš„ï¼Œä½†æ­¤ç±»ç¡®å®å…è®¸åœ¨å¤„ç†å¤šä¸ªæ•°æ®é›†æ—¶åå¤ä½¿ç”¨TINå®ä¾‹ã€‚
 * å¯¹clearï¼ˆï¼‰æ–¹æ³•çš„è°ƒç”¨ä¼šå°†TINé‡ç½®ä¸ºç©ºçŠ¶æ€ï¼Œä½†ä¼šä¿ç•™å·²åˆ†é…çš„è¾¹ï¼Œä»¥ä¾¿å®ƒä»¬å¯ä»¥é‡æ–°ç”¨äºä¸‹ä¸€ä¸ªæ•°æ®é›†ã€‚
 * é€šè¿‡è¿™æ ·åšï¼Œè¾¹ç¼˜å¯¹è±¡çš„å‰æœŸæ„å»ºæˆæœ¬å¯ä»¥åˆ†æ‘Šåˆ°æ•´ä¸ªæ•°æ®é›†ï¼Œä»è€Œå‡å°‘äº†ä¸€ç»„å¤šä¸ªè¾“å…¥é›†çš„å¤„ç†æ—¶é—´ã€‚
 * è¿™æ ·åšçš„åº”ç”¨ç¨‹åºåº”è¯¥èƒ½å¤Ÿæ”¹è¿›ä¸Šé¢å¼•ç”¨çš„è¿è¡Œæ—¶æ€§èƒ½å€¼ã€‚
 * <h3>Input geometry</h3>
 * è¾“å…¥é›†åˆä½“
 * The worst case vertex geometry for TIN construction is a data set in which a
 *  * large number of points are collinear and do not form triangles readily.
 *  * Unfortunately, that is exactly the geometry of one of the most obvious
 *  * classes of input: the regular grid. This class supports two different add()
 *  * methods for adding vertices to the TIN. When dealing with a regular grid or
 *  * similar geometries, it is advantageous to use the add() method that takes a
 *  * list as an input rather than the one that accepts single vertices. Having a
 *  * list of vertices gives this class more flexibility in constructing the TIN.
 *  ä¸‰è§’ç½‘æ„é€ çš„æœ€åæƒ…å†µä¸‹çš„é¡¶ç‚¹å‡ ä½•å›¾å½¢æ˜¯å¤§é‡ç‚¹å…±çº¿ä¸”ä¸å®¹æ˜“å½¢æˆä¸‰è§’å½¢çš„æ•°æ®é›†ã€‚
 *  ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ­£æ˜¯æœ€æ˜æ˜¾çš„è¾“å…¥ç±»ä¹‹ä¸€çš„å‡ ä½•ä½“ï¼šè§„åˆ™ç½‘æ ¼ã€‚
 *  è¯¥ç±»æ”¯æŒä¸¤ç§ä¸åŒçš„addï¼ˆï¼‰æ–¹æ³•å°†é¡¶ç‚¹æ·»åŠ åˆ°ä¸‰è§’ç½‘ã€‚
 *  å½“å¤„ç†è§„åˆ™ç½‘æ ¼æˆ–ç±»ä¼¼çš„å‡ ä½•ä½“æ—¶ï¼Œä½¿ç”¨å°†åˆ—è¡¨ä½œä¸ºè¾“å…¥çš„addï¼ˆï¼‰æ–¹æ³•æ¯”ä½¿ç”¨æ¥å—å•ä¸ªé¡¶ç‚¹çš„æ–¹æ³•æ›´æœ‰åˆ©ã€‚
 *  å…·æœ‰é¡¶ç‚¹åˆ—è¡¨ä½¿æ­¤ç±»åœ¨æ„é€ ä¸‰è§’ç½‘æ—¶å…·æœ‰æ›´å¤§çš„çµæ´»æ€§ã€‚
 * <p>
 * The process of inserting a vertex within a TIN requires fewer operations than
 * extending the convex hull of that TIN. If a list of vertices is supplied to
 * the initial add routine, the bootstrap process attempts pick the largest
 * starting triangle that it can without excessive processing. Doing so improves
 * performance and stability of the build process.
 * åœ¨ä¸‰è§’ç½‘ä¸­æ’å…¥é¡¶ç‚¹çš„è¿‡ç¨‹æ¯”æ‰©å±•è¯¥ä¸‰è§’ç½‘çš„å‡¸åŒ…æ‰€éœ€çš„æ“ä½œæ›´å°‘ã€‚
 * å¦‚æœå°†é¡¶ç‚¹åˆ—è¡¨æä¾›ç»™åˆå§‹æ·»åŠ ä¾‹ç¨‹ï¼Œåˆ™å¼•å¯¼è¿›ç¨‹ä¼šå°è¯•åœ¨ä¸è¿›è¡Œè¿‡å¤šå¤„ç†çš„æƒ…å†µä¸‹é€‰æ‹©æœ€å¤§çš„èµ·å§‹ä¸‰è§’å½¢ã€‚
 * è¿™æ ·åšå¯ä»¥æé«˜æ„å»ºè¿‡ç¨‹çš„æ€§èƒ½å’Œç¨³å®šæ€§ã€‚
 * <h3>Storing the same vertex more than once</h3>
 * å¤šæ¬¡å­˜å‚¨åŒä¸€é¡¶ç‚¹
 * The add() methods detect when the same vertex object is inserted more than
 * once and ignore redundant inputs. For distinct vertex objects at the same or
 * nearly same coordinates, this class maintains a "merged group" of vertices.
 * Rules for disambiguating the values of a merged group my be specified using a
 * call to the setResolutionRuleForMergedVertices() method.
 * addï¼ˆï¼‰æ–¹æ³•æ£€æµ‹åŒä¸€é¡¶ç‚¹å¯¹è±¡ä½•æ—¶è¢«å¤šæ¬¡æ’å…¥ï¼Œå¹¶å¿½ç•¥å†—ä½™è¾“å…¥ã€‚
 * å¯¹äºä½äºç›¸åŒæˆ–å‡ ä¹ç›¸åŒåæ ‡çš„ä¸åŒé¡¶ç‚¹å¯¹è±¡ï¼Œæ­¤ç±»ç»´æŠ¤ä¸€ä¸ªé¡¶ç‚¹çš„â€œåˆå¹¶ç»„â€ã€‚
 * å¯ä»¥ä½¿ç”¨å¯¹setResolutionRuleForMergedVerticesï¼ˆï¼‰æ–¹æ³•çš„è°ƒç”¨æ¥æŒ‡å®šç”¨äºæ¶ˆé™¤åˆå¹¶ç»„çš„å€¼çš„æ­§ä¹‰çš„è§„åˆ™ã€‚
 * <h3>Sequential spatial autocorrelation</h3>
 * åºåˆ—ç©ºé—´è‡ªç›¸å…³
 * <p>
 * Inserting a vertex into a TIN depends on identifying the triangle that
 * contains an insertion vertex (if any). This class uses the Stochastic
 * Lawson's Walk algorithm (SLW) that is most efficient when subsequent vertices
 * tend to be spaced close together. Fortunately, this condition is met by
 * many real-world data collection systems. For example, airborne-lidar systems
 * tend to produce a sequence of samples that are closely spaced in
 * terms of horizontal coordinates because they collect measurements
 * using scanning lasers and storing them in the order they are
 * taken.
 * å°†é¡¶ç‚¹æ’å…¥ä¸‰è§’ç½‘å–å†³äºè¯†åˆ«åŒ…å«æ’å…¥é¡¶ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰çš„ä¸‰è§’å½¢ã€‚
 * æ­¤ç±»ä½¿ç”¨éšæœºåŠ³æ£®è¡Œèµ°ç®—æ³•ï¼ˆSLWï¼‰ï¼Œå½“åç»­é¡¶ç‚¹å¾€å¾€é—´éš”å¾—å¾ˆè¿‘æ—¶ï¼Œè¯¥ç®—æ³•æœ€æœ‰æ•ˆã€‚
 * å¹¸è¿çš„æ˜¯ï¼Œè®¸å¤šçœŸå®ä¸–ç•Œçš„æ•°æ®æ”¶é›†ç³»ç»Ÿéƒ½æ»¡è¶³äº†è¿™ä¸€æ¡ä»¶ã€‚
 * ä¾‹å¦‚ï¼Œæœºè½½æ¿€å…‰é›·è¾¾ç³»ç»Ÿå¾€å¾€ä¼šäº§ç”Ÿä¸€ç³»åˆ—åœ¨æ°´å¹³åæ ‡æ–¹é¢é—´éš”å¾ˆè¿‘çš„æ ·æœ¬ï¼Œå› ä¸ºå®ƒä»¬ä½¿ç”¨æ‰«ææ¿€å…‰æ”¶é›†æµ‹é‡ç»“æœï¼Œå¹¶æŒ‰é‡‡é›†é¡ºåºå­˜å‚¨ã€‚
 * <p>
 * Other data sources may not be compliant. Randomly generated data
 * points, in particular, may be problematic. For such data, there may be a
 * performance benefit in using the HilbertSort class to pre-order points before
 * insertion so that sequential spatial autocorrelation is provided by the
 * input data.
 * å…¶ä»–æ•°æ®æºå¯èƒ½ä¸å…¼å®¹ã€‚ç‰¹åˆ«åœ°ï¼Œéšæœºç”Ÿæˆçš„æ•°æ®ç‚¹å¯èƒ½æ˜¯æœ‰é—®é¢˜çš„ã€‚
 * å¯¹äºè¿™æ ·çš„æ•°æ®ï¼Œä½¿ç”¨HilbertSortç±»åœ¨æ’å…¥ä¹‹å‰å¯¹ç‚¹è¿›è¡Œé¢„æ’åºï¼Œä»è€Œç”±è¾“å…¥æ•°æ®æä¾›é¡ºåºçš„ç©ºé—´è‡ªç›¸å…³ï¼Œè¿™å¯èƒ½ä¼šå¸¦æ¥æ€§èƒ½ä¼˜åŠ¿ã€‚
 * <p>
 * One way to judge the degree of sequential spacial autocorrelation in a set of
 * vertices is to view the output of the printDiagnostics() method after
 * building a TIN. Under the entry for the SLW statistics, the "average steps to
 * completion" indicates how many comparisons were needed to locate vertices. If
 * this number is larger than 7 or 8, it may be useful to try using the
 * HilbertSort and see if it improves processing times.
 * åˆ¤æ–­ä¸€ç»„é¡¶ç‚¹ä¸­åºåˆ—ç©ºé—´è‡ªç›¸å…³ç¨‹åº¦çš„ä¸€ç§æ–¹æ³•æ˜¯åœ¨æ„å»ºä¸‰è§’ç½‘åæŸ¥çœ‹printDiagnosticsï¼ˆï¼‰æ–¹æ³•çš„è¾“å‡ºã€‚
 * åœ¨SLWç»Ÿè®¡ä¿¡æ¯çš„æ¡ç›®ä¸‹ï¼Œâ€œå¹³å‡å®Œæˆæ­¥éª¤â€è¡¨ç¤ºéœ€è¦è¿›è¡Œå¤šå°‘æ¯”è¾ƒæ‰èƒ½å®šä½é¡¶ç‚¹ã€‚
 * å¦‚æœè¿™ä¸ªæ•°å­—å¤§äº7æˆ–8ï¼Œé‚£ä¹ˆå°è¯•ä½¿ç”¨HilbertSortå¹¶æŸ¥çœ‹å®ƒæ˜¯å¦å¯ä»¥ç¼©çŸ­å¤„ç†æ—¶é—´å¯èƒ½ä¼šå¾ˆæœ‰ç”¨ã€‚
 * <h3>Cleaning up when finished</h3>
 * å®Œæˆåæ¸…ç†
 * <p>
 * Because of the complex relationships between objects in a TIN, Java garbage
 * collection may require an above-average number of passes to clean up memory
 * when an instance of this class goes out-of-scope. The dispose() method can be
 * used to expedite garbage collection. Once the dispose() method is called on a
 * TIN, it cannot be reused. Do not confuse dispose() with clear().
 * ç”±äºTINä¸­å¯¹è±¡ä¹‹é—´çš„å¤æ‚å…³ç³»ï¼Œå½“æ­¤ç±»çš„å®ä¾‹è¶…å‡ºèŒƒå›´æ—¶ï¼ŒJavaåƒåœ¾æ”¶é›†å¯èƒ½éœ€è¦é«˜äºå¹³å‡å€¼çš„æ¬¡æ•°æ¥æ¸…ç†å†…å­˜ã€‚
 * disposeï¼ˆï¼‰æ–¹æ³•å¯ç”¨äºåŠ å¿«åƒåœ¾æ”¶é›†ã€‚ä¸€æ—¦åœ¨TINä¸Šè°ƒç”¨disposeï¼ˆï¼‰æ–¹æ³•ï¼Œå°±ä¸èƒ½é‡ç”¨å®ƒã€‚
 * ä¸è¦å°†disposeï¼ˆï¼‰ä¸clearï¼ˆï¼‰æ··æ·†ã€‚
   * <h3>Running nude</h3>
 * è£¸å¥”
 * <p>
 * Because of the unusually demanding performance considerations related to the
 * use of this class, object instances are frequently reused and, thus, are
 * subject to change. Consequently, this implementation provides little
 * protection against improper method calls by
 * applications accessing its data. In particular, applications must never
 * modify an object (such as an edge) obtained from instances of this class.
 * Furthermore, they must assume that any addition or removal of vertices to the
 * TIN may change the internal state of any objects previously obtained.
 * ç”±äºä¸æ­¤ç±»çš„ä½¿ç”¨ç›¸å…³çš„å¼‚å¸¸è‹›åˆ»çš„æ€§èƒ½è€ƒè™‘ï¼Œå¯¹è±¡å®ä¾‹ç»å¸¸è¢«é‡ç”¨ï¼Œå› æ­¤å¯èƒ½ä¼šå‘ç”Ÿæ›´æ”¹ã€‚
 * å› æ­¤ï¼Œè¿™ç§å®ç°å‡ ä¹ä¸èƒ½é˜²æ­¢åº”ç”¨ç¨‹åºè®¿é—®å…¶æ•°æ®æ—¶è¿›è¡Œä¸æ­£ç¡®çš„æ–¹æ³•è°ƒç”¨ã€‚
 * ç‰¹åˆ«æ˜¯ï¼Œåº”ç”¨ç¨‹åºå†³ä¸èƒ½ä¿®æ”¹ä»æ­¤ç±»å®ä¾‹ä¸­è·å¾—çš„å¯¹è±¡ï¼ˆå¦‚è¾¹ï¼‰ã€‚æ­¤å¤–ï¼Œä»–ä»¬å¿…é¡»å‡è®¾å‘ä¸‰è§’ç½‘æ·»åŠ æˆ–åˆ é™¤é¡¶ç‚¹å¯èƒ½ä¼šæ”¹å˜å…ˆå‰è·å¾—çš„ä»»ä½•å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ã€‚
 * <p>
 * To better understand the re-use strategy, consider that each time a vertex is
 * added to or removed from a TIN, the set of edges that link vertices changes.
 * Some edges may be removed, others added. Testing with lidar data sets
 * indicates that the present implementation re-uses each edge in the collection
 * a average about 7.5 times while the TIN is being constructed. If the
 * application were to treat edges as immutable, it would have to construct new
 * objects each time a vertex was inserted and many of those edge objects would
 * have to be discarded (and garbage collected) before the entire vertex set was
 * processed. Doing so would substantially degrade the performance of this
 * class.
 * ä¸ºäº†æ›´å¥½åœ°ç†è§£é‡ç”¨ç­–ç•¥ï¼Œè¯·è€ƒè™‘æ¯æ¬¡å‘ä¸‰è§’ç½‘æ·»åŠ é¡¶ç‚¹æˆ–ä»ä¸‰è§’ç½‘åˆ é™¤é¡¶ç‚¹æ—¶ï¼Œè¿æ¥é¡¶ç‚¹çš„è¾¹é›†éƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚
 * ä¸€äº›è¾¹ç¼˜å¯èƒ½ä¼šè¢«åˆ é™¤ï¼Œå¦ä¸€äº›åˆ™ä¼šè¢«æ·»åŠ ã€‚ç”¨æ¿€å…‰é›·è¾¾æ•°æ®é›†è¿›è¡Œçš„æµ‹è¯•è¡¨æ˜ï¼Œåœ¨æ„å»ºTINæ—¶ï¼Œæœ¬å®æ–½æ–¹æ¡ˆå¹³å‡é‡å¤ä½¿ç”¨é›†åˆä¸­çš„æ¯ä¸ªè¾¹ç¼˜çº¦7.5æ¬¡ã€‚
 * å¦‚æœåº”ç”¨ç¨‹åºè¦å°†è¾¹è§†ä¸ºä¸å¯å˜çš„ï¼Œåˆ™æ¯æ¬¡æ’å…¥é¡¶ç‚¹æ—¶éƒ½å¿…é¡»æ„é€ æ–°å¯¹è±¡ï¼Œå¹¶ä¸”åœ¨å¤„ç†æ•´ä¸ªé¡¶ç‚¹é›†ä¹‹å‰ï¼Œå¿…é¡»ä¸¢å¼ƒï¼ˆå¹¶åƒåœ¾æ”¶é›†ï¼‰å…¶ä¸­è®¸å¤šè¾¹å¯¹è±¡ã€‚è¿™æ ·åšä¼šå¤§å¤§é™ä½æ­¤ç±»çš„æ€§èƒ½ã€‚
 * <h3>Multi-Threading and Concurrency</h3>
 * å¤šçº¿ç¨‹å’Œå¹¶å‘
 * The process of creating a Delaunay Triangulation (TIN) using an
 * incremental-insertion technique is inherently serial. Therefore, application
 * code that creates a TIN should not attempt to access the "add" methods
 * for this class in parallel threads. However, this API is designed so
 * that once a TIN is complete, it can be accessed by multiple threads
 * on a read-only basis.
 * Multi-threaded access is particularly useful when performing
 * surface-interpolation operations to construct raster (grid) representations
 * of data.
 * ä½¿ç”¨å¢é‡æ’å…¥æŠ€æœ¯åˆ›å»ºDelaunayä¸‰è§’ç½‘ï¼ˆTINï¼‰çš„è¿‡ç¨‹æœ¬è´¨ä¸Šæ˜¯ä¸²è¡Œçš„ã€‚
 * å› æ­¤ï¼Œåˆ›å»ºTINçš„åº”ç”¨ç¨‹åºä»£ç ä¸åº”è¯•å›¾åœ¨å¹¶è¡Œçº¿ç¨‹ä¸­è®¿é—®æ­¤ç±»çš„â€œæ·»åŠ â€æ–¹æ³•ã€‚
 * ç„¶è€Œï¼Œæ­¤APIçš„è®¾è®¡æ˜¯ä¸ºäº†åœ¨TINå®Œæˆåï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥åœ¨åªè¯»çš„åŸºç¡€ä¸Šè®¿é—®å®ƒã€‚
 * å½“æ‰§è¡Œæ›²é¢æ’å€¼æ“ä½œä»¥æ„å»ºæ•°æ®çš„å…‰æ …ï¼ˆæ …æ ¼ï¼‰è¡¨ç¤ºæ—¶ï¼Œå¤šçº¿ç¨‹è®¿é—®å°¤å…¶æœ‰ç”¨ã€‚
 * <h1>Methods and References</h1>
 * -----------------------------------æ–¹æ³•å’Œæ–‡çŒ®å¼•ç”¨-------------------------------------
 * <p>
 * A good review of point location using a stochastic Lawson's walk is provided
 * by <cite>Soukal, R.; Ma&#769;lkova&#769;, Kolingerova&#769; (2012) "Walking
 * algorithms for point location in TIN models", Computational Geoscience
 * 16:853-869</cite>.
 * <p>
 * The Bower-Watson algorithm for point insertion is discussed in
 * <cite>Cheng, Siu-Wing; Dey, T.; Shewchuk, J. (2013) "Delaunay mesh
 * generation", CRC Press, Boca Raton, FL</cite>. This is a challenging book
 * that provides an overview of both 2D and solid TIN models. Jonathan Shewchuk
 * is pretty much the expert on Delaunay Triangulations and his writings were a
 * valuable resource in the creation of this class. You can also read Bowyer's
 * and Watson's original papers both of which famously appeared in the same
 * issue of the same journal in 1981. See
 * <cite>Bowyer, A. (1981) "Computing Dirichlet tesselations", The Computer
 * Journal" Vol 24, No 2., p. 162-166</cite>. and
 * <cite>Watson, D. (1981) "Computing the N-dimensional tesselation with
 * application to Voronoi Diagrams", The Computer Journal" Vol 24, No 2., p.
 * 167-172</cite>.
 * <p>
 * The point-removal algorithm is due to Devillers. See
 * <cite>Devillers, O. (2002), "On deletion in delaunay triangulations",
 * International Journal of Computational Geometry &amp; Applications 12.3 p.
 * 123-2005</cite>.
 * <p>
 * The QuadEdge concept is based on the structure popularized by
 * <cite>Guibas, L. and Stolfi, J. (1985) "Primitives for the manipulation of
 * subdivisions and the computation of Voronoi diagrams", ACM Transactions on
 * Graphics, 4(2), 1985, p. 75-123.</cite>
 * <p>
 * The logic for adding constraints to the TIN was adapted from
 * <cite>Sloan, S.W. (1993) "A Fast Algorithm for Generating Constrained
 * Delaunay Triangulations", Computers &amp; Structures Vol 47. No 3, 1993,
 * p. 441-450.</cite>
 */
```

![1713273997550](./assets/1713273997550.png)

![1713273939654](./assets/1713273939654.png)

![1713274020567](./assets/1713274020567.png)

## 4ã€å¢é‡ä¸‰è§’åˆ¨åˆ†ï¼ˆIncrementalTinï¼‰çš„æ¦‚å¿µ

å¢é‡ä¸‰è§’å‰–åˆ†ï¼ˆIncremental Delaunay Triangulationï¼‰æ˜¯ä¸€ç§ç”¨äºç”ŸæˆDelaunayä¸‰è§’å‰–åˆ†çš„ç®—æ³•ï¼Œç‰¹åˆ«é€‚ç”¨äºäºŒç»´å¹³é¢ä¸Šçš„ç‚¹é›†ã€‚è¿™ç§ç®—æ³•ä»¥å…¶ç®€å•å’Œé«˜æ•ˆè€Œå¹¿æ³›åº”ç”¨äºå‡ ä½•å¤„ç†çš„å„ä¸ªé¢†åŸŸï¼Œå¦‚è®¡ç®—å‡ ä½•ã€åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ã€ç½‘æ ¼ç”Ÿæˆå’Œè·¯å¾„è§„åˆ’ç­‰ã€‚

**åŸºæœ¬æ¦‚å¿µ**

é¦–å…ˆï¼Œè®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹`Delaunayä¸‰è§’å‰–åˆ†çš„åŸºæœ¬æ€§è´¨`ï¼š

- Delaunayä¸‰è§’å‰–åˆ†æ˜¯å¯¹ç»™å®šçš„ç¦»æ•£ç‚¹é›†çš„ä¸€ç§ä¸‰è§’å‰–åˆ†ï¼Œå®ƒæ»¡è¶³**ç©ºåœ†æ€§è´¨**ï¼Œå³æ¯ä¸ªä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ä¸åŒ…å«å…¶ä»–çš„ç‚¹ã€‚
- Delaunayä¸‰è§’å‰–åˆ†å…·æœ‰æœ€å¤§åŒ–æœ€å°è§’çš„å±æ€§ï¼Œè¿™ä½¿å¾—å®ƒèƒ½å¤Ÿé¿å…å‡ºç°ç»†é•¿çš„ä¸‰è§’å½¢ï¼Œé€šå¸¸è¢«è®¤ä¸ºåœ¨å¤šç§åº”ç”¨ä¸­äº§ç”Ÿæ›´ä¼˜ç¾çš„ç½‘æ ¼å‰–åˆ†ã€‚
- å¯¹äºä»»ä½•ç»™å®šçš„ç‚¹é›†ï¼Œå…¶Delaunayä¸‰è§’å‰–åˆ†æ˜¯å”¯ä¸€çš„ï¼Œé™¤éå››ä¸ªæˆ–æ›´å¤šçš„ç‚¹å…±åœ†ã€‚

**å¢é‡ä¸‰è§’å‰–åˆ†**

å¢é‡ä¸‰è§’å‰–åˆ†ç®—æ³•é€šè¿‡é€æ­¥æ·»åŠ ç‚¹åˆ°å·²æœ‰çš„Delaunayä¸‰è§’å‰–åˆ†ä¸­å¹¶å±€éƒ¨è°ƒæ•´æ¥ç»´æŒDelaunayæ€§è´¨ã€‚ç®—æ³•çš„ä¸»è¦æ­¥éª¤å¯ä»¥æ¦‚æ‹¬å¦‚ä¸‹ï¼š

1. **åˆå§‹åŒ–**ï¼š å¼€å§‹æ—¶ï¼Œé€‰æ‹©ä¸€ä¸ªåˆå§‹ä¸‰è§’å½¢ï¼Œå®ƒå¿…é¡»åŒ…å«æ‰€æœ‰å¾…å‰–åˆ†ç‚¹ã€‚ä¸ºäº†ç®€åŒ–é—®é¢˜ï¼Œäººä»¬é€šå¸¸é€‰æ‹©ä¸€ä¸ªè¶…çº§ä¸‰è§’å½¢ï¼Œè¿™ä¸ªè¶…çº§ä¸‰è§’å½¢çš„é¡¶ç‚¹è¿œè¿œè¶…å‡ºäº†æ‰€æœ‰ç‚¹çš„èŒƒå›´ã€‚
2. **æ’å…¥ç‚¹**ï¼š ä¾æ¬¡å°†æ¯ä¸ªç‚¹æ’å…¥å½“å‰çš„ä¸‰è§’å‰–åˆ†ä¸­ã€‚å¯¹äºæ–°æ’å…¥çš„ç‚¹ï¼Œæ‰¾åˆ°å®ƒæ‰€åœ¨çš„ä¸‰è§’å½¢ã€‚
3. **å±€éƒ¨è°ƒæ•´**ï¼š å¦‚æœæ–°æ’å…¥çš„ç‚¹æ°å¥½åœ¨æŸä¸ªä¸‰è§’å½¢çš„è¾¹ä¸Šï¼Œé‚£ä¹ˆè¿™æ¡è¾¹çš„ä¸¤ä¸ªç›¸é‚»ä¸‰è§’å½¢éƒ½ä¼šè¢«å½±å“ã€‚å¦åˆ™ï¼Œåªæœ‰åŒ…å«æ–°ç‚¹çš„ä¸‰è§’å½¢å—å½±å“ã€‚æ— è®ºå“ªç§æƒ…å†µï¼Œéƒ½éœ€è¦å°†å—å½±å“çš„ä¸‰è§’å½¢ç»†åˆ†ä¸ºå‡ ä¸ªæ–°çš„ä¸‰è§’å½¢ï¼Œä½¿æ–°ç‚¹æˆä¸ºæ–°ä¸‰è§’å½¢çš„é¡¶ç‚¹ã€‚
4. **æ¢å¤Delaunayæ€§è´¨**ï¼š æ’å…¥æ–°ç‚¹åï¼Œå¯èƒ½ç ´åäº†åŸæœ‰çš„Delaunayæ€§è´¨ã€‚æ­¤æ—¶ï¼Œéœ€è¦æ£€æŸ¥ä¸æ–°å¢ä¸‰è§’å½¢ç›¸é‚»çš„ä¸‰è§’å½¢ï¼Œå¹¶è¿›è¡Œè¾¹ç¿»è½¬ï¼ˆEdge Flippingï¼‰ï¼Œä»¥ç¡®ä¿æ‰€æœ‰ç›¸é‚»çš„ä¸‰è§’å½¢ä»æ»¡è¶³Delaunayæ¡ä»¶ã€‚
5. **ç§»é™¤è¶…çº§ä¸‰è§’å½¢**ï¼š å¢é‡æ·»åŠ æ‰€æœ‰ç‚¹åï¼Œåˆ é™¤æ‰€æœ‰ä¸åˆå§‹è¶…çº§ä¸‰è§’å½¢æœ‰å…¬å…±é¡¶ç‚¹çš„ä¸‰è§’å½¢ï¼Œä»¥å¾—åˆ°æœ€ç»ˆçš„Delaunayä¸‰è§’å‰–åˆ†ã€‚

**è¾¹ç¿»è½¬ï¼ˆEdge Flippingï¼‰**

è¾¹ç¿»è½¬æ˜¯åœ¨å¢é‡ä¸‰è§’å‰–åˆ†è¿‡ç¨‹ä¸­ç”¨æ¥ç»´æŠ¤Delaunayæ€§è´¨çš„é‡è¦æ“ä½œã€‚å¦‚æœå‘ç°æŸä¸ªä¸‰è§’å½¢çš„é‚»è¾¹å¯¹é¢çš„é¡¶ç‚¹åœ¨è¯¥ä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ï¼Œå°±éœ€è¦æ‰§è¡Œè¾¹ç¿»è½¬ã€‚è¾¹ç¿»è½¬çš„è¿‡ç¨‹æ¶‰åŠ**åˆ é™¤å…±äº«è¿™æ¡é‚»è¾¹çš„ä¸¤ä¸ªä¸‰è§’å½¢**ï¼Œå¹¶åˆ›å»ºä¸¤ä¸ªæ–°çš„ä¸‰è§’å½¢ï¼Œè¿™ä¸¤ä¸ªæ–°ä¸‰è§’å½¢å…±äº«ä¹‹å‰æœªå…±äº«çš„é¡¶ç‚¹ã€‚

**ç®—æ³•ä¼˜åŠ¿å’Œå±€é™**

å¢é‡ä¸‰è§’å‰–åˆ†ç®—æ³•çš„ä¼˜åŠ¿åœ¨äºå…¶å®ç°ç®€å•ç›´è§‚ï¼Œå¯¹äºé€æ¸å¢åŠ çš„æ•°æ®é›†ä¹Ÿèƒ½å¾ˆå¥½åœ°å·¥ä½œã€‚ç„¶è€Œï¼Œåœ¨æœ€åæƒ…å†µä¸‹å…¶æ—¶é—´å¤æ‚åº¦å¯ä»¥è¾¾åˆ°O(n^2)ï¼Œå…¶ä¸­næ˜¯ç‚¹çš„æ•°é‡ã€‚è¿™é€šå¸¸å‘ç”Ÿåœ¨æ‰€æœ‰ç‚¹éƒ½æŒ‰ç…§æŸç§ç‰¹å®šé¡ºåºï¼ˆæ¯”å¦‚å‡ ä¹å…±çº¿ï¼‰æ·»åŠ æ—¶ã€‚å°½ç®¡å¦‚æ­¤ï¼Œåœ¨å¹³å‡æƒ…å†µä¸‹ï¼Œç®—æ³•è¡¨ç°è‰¯å¥½ï¼Œæ—¶é—´å¤æ‚åº¦æ¥è¿‘O(nlogn)ã€‚

å¢é‡ä¸‰è§’å‰–åˆ†æ˜¯å¤šç§Delaunayä¸‰è§’å‰–åˆ†æ–¹æ³•ä¸­çš„ä¸€ç§ï¼Œå¹¶ä¸”å¯æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯é€‰æ‹©ä½¿ç”¨æ­¤ç®—æ³•æˆ–å…¶ä»–ç®—æ³•ï¼Œå¦‚åˆ†æ²»æ³•æˆ–æ‰«æçº¿æ³•ç­‰ã€‚

# äºŒã€ç®—æ³•æµç¨‹

## 2.1å¢é‡ä¸‰è§’å‰–åˆ†ç®—æ³•æµç¨‹

æ•´ä¸ªç®—æ³•çš„æµç¨‹æ˜¯è¿™æ ·çš„

- ä¸€å¼€å§‹å…ˆæ„é€ ä¸€ä¸ªæå¤§ä¸‰è§’å½¢ï¼Œç„¶åæ‰“ä¹±æ’å…¥ç‚¹é›†çš„é¡ºåºã€‚
- æ¯æ¬¡æ’å…¥ä¸€ä¸ªç‚¹ ğ‘ƒ ï¼Œ**ç¡®å®šè¿™ä¸ªç‚¹åœ¨å“ªä¸ªä¸‰è§’å½¢**ï¼ŒåŒæ—¶æŠŠè¿™ä¸ªä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹è¿æ¥æ’å…¥ç‚¹åˆ†æˆä¸‰ä»½ï¼Œåˆ†åˆ«å‘½åä¸º a, b, cã€‚

<img src="./assets/image-20240529143151076.png" alt="image-20240529143151076" style="zoom:50%;" />

- å¯¹äº a, b, c ä¸‰ä¸ªä¸‰è§’å½¢ï¼Œæˆ‘ä»¬æŠŠæ‰€æœ‰ä¸åŒ…å« ğ‘ƒ çš„è¾¹æ ‡è®°ä¸ºå¯ç–‘è¾¹ã€‚
- å¯¹äºæ‰€æœ‰å¯ç–‘è¾¹ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸æ’å…¥ç‚¹ ğ‘ƒ æ ¹æ®å¯ç–‘è¾¹å¯¹ç«‹çš„é¡¶ç‚¹ qã€‚è®¾å¯ç–‘è¾¹ä¸¤ä¸ªé¡¶ç‚¹ä¸º x, yã€‚æ­¤æ—¶ p, x, q, y ç»„æˆäº†ä¸€ä¸ªå››è¾¹å½¢ï¼Œ**å¦‚æœ q åœ¨ p, x, y ç»„æˆçš„åœ†é‡Œ**ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¦å¯¹å››è¾¹å½¢ p, x, q, y è¿›è¡Œ**è¾¹ç¿»è½¬**æ“ä½œã€‚

<img src="./assets/image-20240529143203332.png" alt="image-20240529143203332" style="zoom:50%;" />

- å¦‚æœè¿›è¡Œäº†è¾¹ç¿»è½¬æ“ä½œï¼Œæˆ‘ä»¬è¦æŠŠ qx, qy ä¹Ÿæ ‡è®°ä¸ºå¯ç–‘è¾¹ã€‚

<img src="./assets/image-20240529143222685.png" alt="image-20240529143222685" style="zoom:50%;" />

- æ’å…¥å®Œæ‰€æœ‰ç‚¹åç®—æ³•å°±ç»“æŸäº†ã€‚

### 1ã€éš¾ç‚¹

è¿™ä¸ªç®—æ³•æœ¬èº«åŒ…å«å‡ ä¸ªéš¾ç‚¹ï¼š

1. **å¦‚æœé«˜æ•ˆçš„è¿›è¡Œç‚¹å®šä½ï¼ˆPoint Locationï¼‰æ“ä½œï¼Ÿå³ç¡®å®šæ’å…¥ç‚¹è½åœ¨å“ªä¸ªä¸‰è§’å½¢å†…éƒ¨ï¼Ÿ**
2. **å¦‚ä½•é«˜æ•ˆçš„æ‰¾åˆ°å¯ç–‘è¾¹å’Œå¯¹ç«‹ç‚¹ï¼Ÿ**
3. **å¦‚ä½•åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨æŸä¸‰ä¸ªç‚¹çš„å¤–æ¥åœ†å†…éƒ¨ï¼Ÿ**

### 2ã€å¹³é¢å›¾è¡¨ç¤ºæ–¹æ³•

#### A.å¦‚ä½•é«˜æ•ˆçš„æ‰¾åˆ°å¯ç–‘è¾¹å’Œå¯¹ç«‹ç‚¹

**ç¬¬ä¸€ä¸ªé—®é¢˜**å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åš**DCEL**ï¼ˆdoubly connected edge listï¼Œå³åŒå‘é“¾æ¥è¾¹è¡¨ï¼‰çš„ç»“æ„å®ç°ï¼Œå¯¹äºè¿™ä¸ªé—®é¢˜æˆ‘è¿›è¡Œäº†ä¸€ç‚¹ç®€åŒ–ï¼Œä½¿ç”¨çš„æ˜¯å•å‘é“¾æ¥è¾¹è¡¨ã€‚

è¿™ä¸ªæ•°æ®ç»“æ„æ˜¯ç”±ä¸‰ä¸ªåŸºæœ¬ç»“æ„ç»„æˆçš„ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨å¹³é¢å›¾ä¸­æœ‰ä¸‰ä¸ªé‡è¦ç»„æˆå…ƒç´ ï¼š**é¡¶ç‚¹ï¼Œè¾¹å’Œé¢**ã€‚

é¡¶ç‚¹å¾ˆå¥½è¡¨ç¤ºï¼Œæˆ‘ä»¬åªå…³å¿ƒå®ƒçš„ä½ç½®ã€‚

å¯¹äºè¾¹å’Œé¢æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•æ›´å¤šä¿¡æ¯ã€‚ä¸ºäº†èƒ½å¤ŸçŸ¥é“è¿™ä¸ªè¾¹ç»„æˆäº†å“ªä¸ªé¢ï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¾¹è¿›è¡Œå®šå‘ï¼Œå¦‚æœæŸä¸€äº›è¾¹é€†æ—¶é’ˆå¯ä»¥ç»„æˆä¸€ä¸ªé¢ï¼Œé‚£ä¹ˆå°±è¯´è¿™äº›è¾¹æ˜¯è¿™ä¸ªé¢çš„**ç»„æˆè¾¹**ï¼Œè¿™ä¸ªé¢å°±æˆä¸ºè¿™äº›è¾¹çš„**ç»„æˆé¢**ï¼Œå¦‚å›¾æ‰€ç¤º

<img src="./assets/image-20240528162041860.png" alt="image-20240528162041860" style="zoom:50%;" />

A é¢æ˜¯ç”±çº¢è‰²çš„è¾¹æ‰€ç»„æˆçš„ï¼ŒB é¢æ˜¯ç”±è“è‰²çš„è¾¹ç»„æˆçš„ï¼Œæ³¨æ„ ac å’Œ ca ç»„æˆçš„é¢æ˜¯ä¸åŒçš„ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œä¸ºäº†èƒ½å¤Ÿéå†ä¸€ä¸ªé¢çš„æ‰€æœ‰ç»„æˆè¾¹ï¼Œå¯¹äºæ¯ä¸€ä¸ªè¾¹æˆ‘ä»¬è§„å®šå®ƒçš„**å‰é©±**æŒ‡é’ˆæŒ‡å‘æ„æˆè¿™ä¸ªé¢çš„é€†æ—¶é’ˆä¸‹ä¸€æ¡è¾¹ã€‚æ¯”å¦‚è¯´ï¼Œca è¿™æ¡è¾¹çš„å‰é©±å°±æ˜¯è¾¹ abã€‚

æœ€åï¼Œä¸ºäº†èƒ½å¤Ÿè·å–å¯¹ç«‹é¡¶ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ç”±ä¸€ä¸ªè·¨é¢çš„æ“ä½œï¼Œå³ä»é¢ A è·¨è¶Šåˆ°å®ƒçš„é‚»æ¥é¢ Bï¼Œæˆ‘ä»¬åªéœ€è¦çŸ¥é“ ac è¾¹çš„å­ªç”Ÿè¾¹ ca å³å¯ã€‚ ca çš„ç»„æˆé¢å°±æ˜¯ Bã€‚æˆ‘ä»¬è¦å¯¹æ¯æ¡è¾¹éƒ½ç»´æŠ¤è¿™ä¹ˆä¸€ä¸ªå­ªç”Ÿè¾¹ã€‚

å‡è®¾æˆ‘ä»¬æƒ³è¦è·å¾— b å¯¹äºè¾¹ ac çš„å¯¹ç«‹é¡¶ç‚¹ï¼Œåªéœ€è¦å…ˆè·å¾— ac è¾¹ï¼Œç„¶åæ‰¾åˆ°å…¶å­ªç”Ÿè¾¹çš„å‰é©±å³å¯ã€‚

è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†å¯¹äºè¿™ä¹ˆä¸€ä¸ªå¹³é¢çš„å›¾çš„è¡¨ç¤ºï¼Œä»¥ä¸‹æ˜¯è¿™ä¸‰ä¸ªç»“æ„çš„æŠ½è±¡è¡¨ç¤ºæ–¹æ³•ï¼š

```
struct Edge {
    // è¾¹çš„èµ·ç‚¹
    Vertex* from;
    // è¾¹çš„ç»ˆç‚¹
    Vertex* to;
    // å­ªç”Ÿè¾¹
    Edge* twin;
    // ç»„æˆé¢
    Face* face;
    // å‰é©±è¾¹
    Edge* next;

 int id;
};

struct Face {
 int id;
    // å…¶ä¸­ä¸€ä¸ªç»„æˆè¾¹
    Edge* edge;
};

struct Vertex {
 int id;
    Vector2 pos;
};
```

#### B.å¦‚æœé«˜æ•ˆçš„è¿›è¡Œç‚¹å®šä½ï¼ˆPoint Locationï¼‰æ“ä½œ

åœ¨çº¿çš„ç‚¹å®šä½ï¼ˆPoint Locationï¼‰é—®é¢˜é€šå¸¸éœ€è¦å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œæ¯”å¦‚Kirpatrickçš„ç®—æ³•å’Œæ¢¯å½¢å›¾ï¼ˆTrapezoidal Mapï¼‰ç®—æ³•ã€‚è¿™äº›ç®—æ³•å¯ä»¥å®ç°å•ç‚¹æœŸæœ› ğ‘‚(logâ¡ğ‘›) çš„æŸ¥è¯¢æ•ˆç‡ï¼Œä½†æ˜¯ä»£ç æå…¶éš¾å†™ä¸”è¾¹ç•Œæ¡ä»¶ä¼—å¤šã€‚

å¯¹äºè¿™é“é¢˜æ¥è¯´ï¼Œæˆ‘ä»¬æœ‰ä¸ªä¼˜åŠ¿å°±æ˜¯å¯ä»¥ä½¿ç”¨ç¦»çº¿çš„ç®—æ³•ï¼Œè€Œä¸”å‡ºä¹æ„æ–™çš„æ˜¯ï¼Œè¿™ä¸ªç®—æ³•æå…¶ç®€å•ï¼Œå¤æ‚åº¦å’Œéšæœºå¢é‡ç®—æ³•ä¸€æ ·çœ‹èµ·æ¥å¾ˆé«˜ï¼Œä½†æ˜¯ç”±äºéšæœºæ€§ï¼Œè¿™ä¸ªç‚¹å®šä½å¯ä»¥åœ¨æœŸæœ›å‡æ‘Š ğ‘‚(ğ‘›) çš„æ—¶é—´è§£å†³ã€‚

è¿™ä¸ªæ–¹æ³•å°±æ˜¯ï¼Œå¯¹äº**æ‰€æœ‰ä¸‰è§’å½¢çš„é¢**æˆ‘ä»¬ç”¨ä¸€ä¸ª**åˆ—è¡¨è®°å½•å“ªäº›ç‚¹åœ¨è¿™ä¸ªä¸‰è§’å½¢å†…**ï¼Œæ¯æ¬¡ä¸‰è§’å½¢æœ‰å˜åŠ¨çš„æ—¶å€™æˆ‘ä»¬æš´åŠ›é‡æ–°åˆ†é…è¿™äº›ç‚¹ï¼Œä»…æ­¤è€Œå·²ã€‚çœ‹èµ·æ¥å¾ˆæš´åŠ›ï¼Œä½†æ˜¯æ•ˆç‡å¥‡é«˜ï¼ˆå¹¶ä¸æ˜¯å› ä¸ºæ•°æ®å¼±å“¦ï¼‰ã€‚

è¿™æ ·æˆ‘ä»¬å¯¹æ¯ä¸ªé¡¶ç‚¹ç»´æŠ¤ä¸€ä¸‹å®ƒè½åœ¨å±äºå“ªä¸ªé¢å³å¯ã€‚

#### C.éå†å¯ç–‘è¾¹

æ¯æ¬¡æ’å…¥ä¸€ä¸ªç‚¹ï¼Œæˆ‘ä»¬ç¡®è®¤äº†è½åœ¨å“ªä¸ªä¸‰è§’å½¢å†…éƒ¨ä»¥åï¼Œåˆ†è£‚å‡ºæ¥çš„ä¸‰ä¸ªä¸‰è§’å½¢çš„å‘å¤–çš„è¾¹éƒ½ä¼šè¢«æ ‡è®°ä¸ºå¯ç–‘è¾¹ï¼Œä¸ºäº†èƒ½å¤ŸæŒ‰ç…§é¡ºåºå¤„ç†ï¼Œæˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—å³å¯ï¼Œè¿›è¡Œè¾¹ç¿»è½¬ä»¥ååŠ å…¥æ–°çš„å¯ç–‘è¾¹è¿›é˜Ÿåˆ—å³å¯.

ä¼ªä»£ç ï¼š

```cpp
std::queue<Edge*> Q;
while (!Q.empty()) {
    auto curEdge = Q.front();
    Q.pop();

    // å¦‚æœæ²¡æœ‰å­ªç”Ÿè¾¹å°±ç•¥è¿‡
    auto twin = curEdge->twin;
    if (!twin) continue;

    auto target = twin->next->to;
    // åˆ¤æ–­å¯¹ç«‹é¡¶ç‚¹æ˜¯å¦åœ¨å¤–æ¥åœ†å†…
    if (inCircumcircle(curEdge->from, curEdge->to, P, target)) {
        // è¿›è¡Œè¾¹ç¿»è½¬ï¼ŒåŒæ—¶åŠ å…¥æ–°çš„å¯ç–‘è¾¹
    }
}
```

#### D.è¾¹ç¿»è½¬

æˆ‘ä»¬åªéœ€è¦æŠŠä¸¤ä¸ªå¯¹ç«‹é¡¶ç‚¹çš„è¾¹ç¿»è½¬åˆ°å¦å¤–ä¸¤ä¸ªå¯¹ç«‹é¡¶ç‚¹å³å¯ï¼Œæ³¨æ„åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æˆ‘ä»¬å¹¶ä¸éœ€è¦å¢åŠ å’Œåˆ é™¤é¢ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åŸæ¥çš„è¾¹å’Œé¢ä¸Šè¿›è¡Œæ“ä½œï¼Œé¦–å…ˆæŠŠè¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹æ¢æ‰ï¼Œç„¶åå¯¹äºè¿™ä¸¤ä¸ªé¢ï¼Œé‡æ–°è¿æ¥è¾¹ï¼Œä»¥åŠå‰é©±ã€‚

åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ä¹Ÿåˆ«å¿˜äº†æŠŠä¹‹å‰ä¸¤ä¸ªé¢è¦†ç›–çš„é¡¶ç‚¹æ‹¿å‡ºæ¥ï¼Œå¹¶ä¸”åœ¨è¾¹ç¿»è½¬ç»“æŸåé‡æ–°æ›´æ–°æ¯ä¸ªé¡¶ç‚¹çš„æ‰€å±é¢ã€‚

```cpp
auto A = curEdge->face;
auto B = twin->face;
// æå–å‡ºè¦†ç›–äº†çš„é¡¶ç‚¹
std::vector<Vertex*> cover;
for (auto vs : A->owned) {
    cover.push_back(vs);
}
for (auto vs : B->owned) {
    cover.push_back(vs);
}
// é‡ç»„ABé¢
// ......
// è¿™éƒ¨åˆ†ä»£ç ç•¥å»ç•™ç»™è¯»è€…è‡ªå·±æ€è€ƒ 


for (auto vs : cover) {
    // å‰”é™¤æ‰æ²¡å¿…è¦æ›´æ–°çš„ç‚¹
    if (vs->id == P->id) continue;
    // æ¯ä¸ªé¡¶ç‚¹é‡æ–°åˆ¤æ–­æ‰€å±é¢
    if (!vs->testInTriangle(A)) {
        vs->belong = B;
        B->owned.push_back(vs);
    }
}
```

#### æ‰“ç¢åŸä¸‰è§’å½¢ï¼ˆæ’å…¥æ–°ç‚¹ï¼‰

ä¸ä¸Šé¢çš„è¾¹ç¿»è½¬ä¸€æ ·ï¼Œè¿™é‡Œæˆ‘ä»¬ä¹Ÿæ²¡å¿…è¦ç”Ÿæˆä¸‰ä¸ªæ–°çš„ä¸‰è§’å½¢ï¼Œè€Œæ˜¯åªç”Ÿæˆä¸¤ä¸ªï¼Œç„¶åå¦ä¸€ä¸ªä½¿ç”¨åŸä¸‰è§’å½¢ã€‚æ›´æ–°é¡¶ç‚¹æ‰€å±é¢å’Œä¸Šé¢ä¸€æ ·æš´åŠ›ã€‚

```
ï¼ˆæ¦‚å¿µè®²è§£ï¼Œæ­¤è®²è§£æ˜¯ç”Ÿæˆä¸‰ä¸ªä¸‰è§’å½¢ï¼‰
åœ¨å¢é‡ä¸‰è§’å‰–åˆ†ç®—æ³•ä¸­ï¼Œâ€œæ‰“ç¢åŸä¸‰è§’å½¢â€çš„æ“ä½œä¸»è¦æ˜¯æŒ‡å½“ä¸€ä¸ªæ–°çš„ç‚¹è¢«æ’å…¥åˆ°ç°æœ‰Delaunayä¸‰è§’ç½‘ä¸­æ—¶ï¼Œè¯¥ç‚¹å¯èƒ½ä½äºæŸä¸ªå·²æœ‰ä¸‰è§’å½¢å†…éƒ¨æˆ–è€…æ°å¥½åœ¨æŸæ¡è¾¹ä¸Šã€‚ä¸ºäº†ç»´æŠ¤ä¸‰è§’å‰–åˆ†çš„è¿è´¯æ€§å’ŒDelaunayæ€§è´¨ï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°å¯¹å—å½±å“çš„ä¸‰è§’å½¢è¿›è¡Œå‰–åˆ†ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥è¢«å½¢è±¡åœ°æè¿°ä¸ºâ€œæ‰“ç¢â€ã€‚

å…·ä½“æ¥è¯´ï¼Œæ‰“ç¢åŸä¸‰è§’å½¢çš„æ“ä½œåŒ…æ‹¬ä»¥ä¸‹æ­¥éª¤ï¼š

1ã€åˆ¤æ–­æ–°ç‚¹çš„ä½ç½®ï¼š
é¦–å…ˆï¼Œç¡®å®šæ–°åŠ å…¥çš„ç‚¹Pä½äºå“ªä¸ªä¸‰è§’å½¢ABCä¹‹å†…ï¼Œæˆ–è€…åˆšå¥½åœ¨ä¸‰è§’å½¢çš„ä¸€æ¡è¾¹ä¸Šã€‚

2ã€æ‰“ç¢åŸä¸‰è§’å½¢ï¼š

aã€å¦‚æœç‚¹Pä½äºä¸‰è§’å½¢ABCå†…éƒ¨ï¼Œé‚£ä¹ˆåŸä¸‰è§’å½¢ABCä¼šè¢«â€œæ‰“ç¢â€æˆä¸‰ä¸ªæ–°çš„ä¸‰è§’å½¢ï¼šAPB, BPC, APCã€‚
bã€å¦‚æœç‚¹Pä½äºæŸä¸ªä¸‰è§’å½¢çš„è¾¹ä¸Šï¼Œå‡è®¾æ˜¯è¾¹ABä¸Šï¼Œåˆ™æ­¤è¾¹çš„ä¸¤ä¸ªç›¸é‚»ä¸‰è§’å½¢ï¼ˆæ¯”å¦‚åˆ†åˆ«ä¸ºä¸‰è§’å½¢ABCå’Œä¸‰è§’å½¢ABDï¼‰éƒ½ä¼šå—å½±å“ï¼Œå®ƒä»¬å°†è¢«â€œæ‰“ç¢â€æˆå››ä¸ªæ–°çš„ä¸‰è§’å½¢ï¼šAPC, APD, BPB, BPDã€‚
3ã€æ›´æ–°ä¸‰è§’ç½‘ï¼š
å°†æ–°ç”Ÿæˆçš„ä¸‰è§’å½¢æ·»åŠ åˆ°ä¸‰è§’ç½‘ä¸­ï¼Œå¹¶ä»æ•°æ®ç»“æ„ä¸­ç§»é™¤è¢«æ‰“ç¢çš„åŸä¸‰è§’å½¢ã€‚è¿™æ ·çš„æ›´æ–°ä¿è¯äº†ä¸‰è§’ç½‘å§‹ç»ˆè¦†ç›–æ‰€æœ‰ç‚¹ï¼Œå¹¶ä¸”æ¯ä¸ªç‚¹éƒ½æ˜¯æŸä¸ªä¸‰è§’å½¢çš„é¡¶ç‚¹ã€‚

4ã€ç¡®ä¿Delaunayæ€§è´¨ï¼š
æ‰“ç¢å¹¶é‡å»ºä¸‰è§’å½¢åï¼Œéœ€è¦æ£€æŸ¥æ–°ç”Ÿæˆçš„ä¸‰è§’å½¢æ˜¯å¦æ»¡è¶³Delaunayæ€§è´¨ï¼Œå³æ²¡æœ‰å…¶ä»–ç‚¹å­˜åœ¨äºä»»ä½•ä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ã€‚å¦‚æœå‘ç°ä¸æ»¡è¶³Delaunayæ€§è´¨çš„æƒ…å†µï¼Œå°±éœ€è¦æ‰§è¡Œè¾¹ç¿»è½¬æ“ä½œæ¥è°ƒæ•´ä¸‰è§’å½¢çš„è¿æ¥æ–¹å¼ï¼Œç›´è‡³æ»¡è¶³Delaunayæ¡ä»¶ã€‚

â€œæ‰“ç¢åŸä¸‰è§’å½¢â€çš„æ“ä½œæ˜¯å¢é‡ä¸‰è§’å‰–åˆ†ç®—æ³•ä¸­ä¿æŒæ•°æ®ç»“æ„ä¸€è‡´æ€§å’Œæœ€ç»ˆç”Ÿæˆæ­£ç¡®Delaunayä¸‰è§’å‰–åˆ†çš„å…³é”®è¿‡ç¨‹ã€‚é€šè¿‡è¿ç»­åœ°æ·»åŠ ç‚¹ï¼Œå¹¶é€‚å½“åœ°è°ƒæ•´ä¸‰è§’å½¢ï¼Œç®—æ³•èƒ½å¤Ÿæœ€ç»ˆæ„é€ å‡ºè¦†ç›–æ‰€æœ‰ç‚¹çš„Delaunayä¸‰è§’ç½‘ã€‚
```

è‡³æ­¤è¿™ä¸ªéšæœºå¢é‡ç®—æ³•çš„å¤§éƒ¨åˆ†ç»†èŠ‚å°±éƒ½ä»‹ç»å®Œæ¯•äº†ï¼Œå¯¹äºè¿™é¢˜å‰©ä¸‹çš„åªè¦éå†æ‰€æœ‰è¾¹ç„¶åæ±‚æœ€å°ç”Ÿæˆæ ‘å³å¯ã€‚æˆªæ­¢ç›®å‰ï¼Œè¿™ä¸ªâ€œçº¯æš´åŠ›â€ç®—æ³•æ˜¯è·‘çš„æœ€å¿«çš„æäº¤ï¼Œæˆ‘çš„ä»£ç è¿˜æœ‰å¾ˆå¤šåœ°æ–¹æ²¡æœ‰ä¼˜åŒ–ï¼Œæ¯”å¦‚æŠŠæŒ‡é’ˆæ›¿æ¢ä¸ºæ•°ç»„ä¸‹æ ‡ï¼Œä»¥åŠæ¯”è¾ƒä¼˜é›…çš„åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨é¢å†…çš„ç®—æ³•ã€‚

ç”±æ­¤å¯ä»¥çœ‹å‡ºï¼ŒéšæœºåŒ–æ€æƒ³åœ¨è®¡ç®—å‡ ä½•ä¸­çš„é‡è¦æ€§ï¼Œå®ƒå…è®¸äº†æˆ‘ä»¬ç”¨æå…¶ä¼˜é›…å’Œç®€å•çš„æ–¹å¼è§£å†³å›°éš¾çš„é—®é¢˜ã€‚


ç®—æ³•æœ¬èº«å®ç°éå¸¸ç®€å•ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦ç›´åˆ°1992å¹´çš„è®ºæ–‡[[Randomized Incremental Construction of Delaunay and Voronoi Diagrams\]](https://link.zhihu.com/?target=http%3A//www.wias-berlin.de/people/si/course/files/Guibas92-RandomizeIncr.pdf)æ‰çœŸæ­£çš„ç¡®è®¤ä¸ºæœŸæœ›$O(n\log{n})$ã€‚

å‚è€ƒä»£ç ï¼Œä¸ºæ´›è°· [P6362 å¹³é¢æ¬§å‡ é‡Œå¾—æœ€å°ç”Ÿæˆæ ‘](https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/problem/P6362) é¢˜è§£ï¼ˆå¾ˆé•¿ï¼Œä½†æ˜¯å¤§éƒ¨åˆ†ä»£ç éƒ½æ˜¯æ•°æ®ç»“æ„çš„è¡¨ç¤ºä»¥åŠå‘é‡çš„æ¿å­ï¼Œæ ¸å¿ƒå°±æ˜¯insertå‡½æ•°ï¼‰

## 2.2å¸¦çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†

å¸¦çº¦æŸçš„å¢é‡å¾·åŠ³å†…ä¸‰è§’å‰–åˆ†ï¼ˆConstrained Delaunay Triangulationï¼ŒCDTï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„ä¸‰è§’å‰–åˆ†ï¼Œå®ƒä¸ä»…æ»¡è¶³å¾·åŠ³å†…æ¡ä»¶ï¼Œå³æ¯ä¸ªä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ä¸åŒ…å«å…¶ä»–é¡¶ç‚¹ï¼ŒåŒæ—¶è¿˜å¼ºåˆ¶åŒ…å«ä¸€äº›é¢„å®šä¹‰çš„è¾¹ç•Œæˆ–è€…çº¿æ®µï¼Œç§°ä¸ºâ€œçº¦æŸâ€ã€‚

ç®—æ³•æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š

1. **åˆå§‹åŒ–**ï¼š
   - å¼€å§‹æ—¶åˆ›å»ºä¸€ä¸ªè¶…çº§ä¸‰è§’å½¢ï¼Œè¿™ä¸ªä¸‰è§’å½¢è¦èƒ½å¤Ÿå®Œå…¨åŒ…å«æ‰€æœ‰è¾“å…¥ç‚¹å’Œçº¦æŸè¾¹ç•Œã€‚
   - å°†è¯¥è¶…çº§ä¸‰è§’å½¢æ·»åŠ åˆ°åˆå§‹çš„ä¸‰è§’å‰–åˆ†ä¸­ã€‚
2. **å¢é‡æ’å…¥**ï¼š
   - å°†è¾“å…¥ç‚¹æŒ‰ç…§æŸç§é¡ºåºé€ä¸ªæ’å…¥åˆ°å·²æœ‰çš„ä¸‰è§’å‰–åˆ†ä¸­ï¼Œå¸¸ç”¨çš„æ–¹å¼æœ‰éšæœºã€ç©ºé—´æ’åºç­‰ã€‚
   - æ¯æ¬¡æ’å…¥ä¸€ä¸ªç‚¹åï¼Œæ›´æ–°ä¸‰è§’ç½‘ï¼Œä»¥ä¿è¯ç»§ç»­æ»¡è¶³å¾·åŠ³å†…æ¡ä»¶ã€‚è¿™é€šå¸¸æ¶‰åŠåˆ°å±€éƒ¨é‡å»ºï¼Œä½¿ç”¨â€œç¿»è½¬ç®—æ³•â€ï¼ˆflip algorithmï¼‰æ¥ç¿»è½¬ä¸æ»¡è¶³å¾·åŠ³å†…æ¡ä»¶çš„è¾¹ã€‚
3. **æ’å…¥çº¦æŸè¾¹**ï¼š
   - æ’å…¥é¢„å®šä¹‰çš„çº¦æŸè¾¹ï¼Œè¿™å¯èƒ½éœ€è¦è¿›ä¸€æ­¥å‰–åˆ†ç°æœ‰çš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœçº¦æŸè¾¹ç©¿è¿‡äº†æŸä¸ªä¸‰è§’å½¢ï¼Œåˆ™å°†è¯¥ä¸‰è§’å½¢åˆ†å‰²ä¸ºæ›´å°çš„ä¸‰è§’å½¢ã€‚
   - å¤„ç†äº¤å‰çº¦æŸï¼šå¦‚æœä¸¤æ¡çº¦æŸè¾¹ç›¸äº¤ï¼Œéœ€è¦åœ¨äº¤ç‚¹å¤„å¼•å…¥æ–°çš„é¡¶ç‚¹ï¼Œå¹¶è°ƒæ•´ç›¸åº”çš„ä¸‰è§’å½¢ã€‚
4. **æ¢å¤å¾·åŠ³å†…æ€§è´¨**ï¼š
   - çº¦æŸè¾¹çš„æ’å…¥å¯èƒ½ä¼šç ´ååŸæœ‰çš„å¾·åŠ³å†…æ€§è´¨ã€‚å› æ­¤ï¼Œåœ¨æ’å…¥æ‰€æœ‰çº¦æŸè¾¹ä¹‹åï¼Œéœ€è¦æ‰§è¡Œå±€éƒ¨ä¼˜åŒ–ï¼Œä»¥ç¡®ä¿æ•´ä¸ªå‰–åˆ†é‡æ–°æ»¡è¶³å¾·åŠ³å†…æ¡ä»¶ã€‚
   - ä½¿ç”¨è¾¹ç¿»è½¬ç­‰æ–¹æ³•å¯¹å½±å“äº†å¾·åŠ³å†…æ€§è´¨çš„åŒºåŸŸè¿›è¡Œè°ƒæ•´ã€‚
5. **ç§»é™¤è¶…çº§ä¸‰è§’å½¢**ï¼š
   - åœ¨æœ€ç»ˆçš„ä¸‰è§’å‰–åˆ†ä¸­ï¼Œç§»é™¤ä¸è¶…çº§ä¸‰è§’å½¢ç›¸å…³çš„æ‰€æœ‰é¡¶ç‚¹å’Œä¸‰è§’å½¢ï¼Œå› ä¸ºå®ƒä»¬ä¸å±äºå®é™…çš„è¾“å…¥æ•°æ®é›†ã€‚
6. **å¯é€‰æ­¥éª¤**ï¼š
   - æ ¹æ®å…·ä½“åº”ç”¨çš„éœ€æ±‚ï¼Œå¯èƒ½è¿˜éœ€è¦æ‰§è¡Œé¢å¤–çš„æ­¥éª¤ï¼Œä¾‹å¦‚ä¼˜åŒ–ä¸‰è§’å½¢çš„å½¢çŠ¶ä»¥é¿å…è¿‡åº¦ç‹­é•¿çš„ä¸‰è§’å½¢ï¼Œæˆ–è€…å¤„ç†æ´ªæ°´å¡«å……ç­‰ç®—æ³•æ¥æ ‡è®°ç”±çº¦æŸè¾¹æ‰€å›´æˆçš„åŒºåŸŸã€‚

å¸¦çº¦æŸçš„å¾·åŠ³å†…ä¸‰è§’å‰–åˆ†æ¯”æ ‡å‡†çš„å¾·åŠ³å†…ä¸‰è§’å‰–åˆ†å¤æ‚ï¼Œå› ä¸ºå®ƒå¿…é¡»å¤„ç†é¢å¤–çš„çº¦æŸè¾¹å¹¶ç¡®ä¿è¿™äº›è¾¹è¢«åŒ…å«åœ¨æœ€ç»ˆçš„å‰–åˆ†ç»“æœä¸­ã€‚æ­¤å¤–ï¼Œçº¦æŸè¾¹çš„æ’å…¥éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼Œä»¥é¿å…äº§ç”Ÿéæ³•çš„ä¸‰è§’å½¢ï¼ˆæ¯”å¦‚ä¸‰è§’å½¢çš„è¾¹é‡å æˆ–é¡¶ç‚¹å…±çº¿ï¼‰ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œè¿™ç±»ç®—æ³•çš„å®ç°å’Œä¼˜åŒ–éƒ½ç›¸å¯¹å¤æ‚ï¼Œéœ€è¦ä»”ç»†å¤„ç†å„ç§è¾¹ç•Œæƒ…å†µå’Œç‰¹æ®Šåœºæ™¯ã€‚

```
å¸¦çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†æ˜¯åœ¨ç»™å®šä¸€ç»„ç‚¹çš„åŸºç¡€ä¸Šï¼ŒåŒæ—¶è€ƒè™‘äº†ä¸€äº›é¢å¤–çš„è¾¹æˆ–çº¦æŸï¼Œå¹¶åœ¨è¿™äº›çº¦æŸä¸‹ç”ŸæˆDelaunayä¸‰è§’å‰–åˆ†ã€‚Delaunayä¸‰è§’å‰–åˆ†æ˜¯å°†ç‚¹é›†è¿æ¥æˆä¸‰è§’å½¢ç½‘æ ¼çš„æ–¹æ³•ï¼Œä½¿å¾—ä»»ä½•ç‚¹éƒ½ä¸åœ¨å…¶å¤–æ¥åœ†å†…ã€‚
è¿™ç§å‰–åˆ†åœ¨è®¡ç®—æœºå›¾å½¢å­¦ã€è®¡ç®—æœºè¾…åŠ©è®¾è®¡ï¼ˆCADï¼‰ã€åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ç­‰é¢†åŸŸä¸­æœ‰å¹¿æ³›åº”ç”¨ã€‚

å¸¦çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†ä¸æ™®é€šçš„Delaunayä¸‰è§’å‰–åˆ†ç›¸æ¯”ï¼Œå¤šäº†ä¸€äº›é™åˆ¶æ¡ä»¶ã€‚è¿™äº›çº¦æŸé€šå¸¸æ˜¯ç”¨æˆ·å®šä¹‰çš„ï¼Œå¯ä»¥æ˜¯é¢„å®šä¹‰çš„è¾¹ç•Œã€åŒºåŸŸè¾¹ç•Œã€ç‰¹å®šçš„çº¿æ®µæˆ–è¾¹ç­‰ã€‚ç”Ÿæˆå¸¦çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†çš„ç®—æ³•è¦ç¡®ä¿ç”Ÿæˆçš„ä¸‰è§’å½¢ç½‘æ ¼æ»¡è¶³è¿™äº›çº¦æŸï¼ŒåŒæ—¶ä¿æŒDelaunayä¸‰è§’å‰–åˆ†çš„æ€§è´¨ã€‚

è¿™ç±»ç®—æ³•çš„åº”ç”¨åœºæ™¯åŒ…æ‹¬æœ‰è§„å®šè¾¹ç•Œçš„åœ°å½¢å»ºæ¨¡ã€CADç³»ç»Ÿä¸­çš„åŒºåŸŸåˆ’åˆ†ã€åœ°å›¾çš„ç‰¹å®šçº¿çº¦æŸç­‰ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¸¦çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†èƒ½å¤Ÿæ›´å¥½åœ°æ»¡è¶³ç‰¹å®šé—®é¢˜çš„è¦æ±‚ï¼Œæä¾›æ›´ç²¾ç¡®å’Œç¬¦åˆå®é™…éœ€æ±‚çš„ç»“æœã€‚
å®šä¹‰1ï¼šç›¸äº’å¯è§æ€§ï¼ˆmutual visibility
å¦‚æœæ²¡æœ‰çº¦æŸè¾¹ç©¿è¿‡å®ƒä»¬çš„è¿æ¥æ®µï¼Œåˆ™ä¸¤ä¸ªé¡¶ç‚¹viå’ŒVJæ˜¯ç›¸äº’å¯è§çš„ã€‚

å®šä¹‰2ï¼šçº¦æŸç©ºåœ†æ ‡å‡†(Constraint empty circle criterion)
ä¸‰è§’ç½‘æ ¼Tçš„ä¸€ä¸ªä¸‰è§’å½¢ t(vi,vj,vk)éµå¾ªçš„çº¦æŸç©ºåœ†ï¼Œå½“ä¸”ä»…å½“æ²¡æœ‰å…¶ä»–ä¸‰è§’ç½‘Tçš„é¡¶ç‚¹ï¼Œä½¿å¾—ï¼š
- é¡¶ç‚¹våŒ…å«åœ¨ä¸‰è§’å½¢tçš„å¤–æ¥åœ†ä¸­
- vä¸èƒ½åŒæ—¶è¢«ä¸‰ä¸ªé¡¶ç‚¹Viã€VJã€VKçœ‹åˆ°ã€‚

å®šä¹‰3ï¼šçº¦æŸä¸‹çš„ä¸‰è§’åˆ¨åˆ†
å¦‚æœæ‰€æœ‰ä¸‰è§’å½¢éƒ½éµå®ˆçº¦æŸç©ºåœ†å‡†åˆ™ï¼Œåˆ™è¯¥ä¸‰è§’å‰–åˆ†æ˜¯çº¦æŸDelaunayä¸‰è§’å‰–åˆ†ã€‚
å› æ­¤ï¼Œå®šä¹‰çš„ä¸‰è§’å‰–åˆ†åŒ…å«çº¦æŸå›¾ä½œä¸ºå…¶è‡ªèº«çš„ä¸€éƒ¨åˆ†ã€‚å¯¹çº¦æŸå­—æ®µè¿›è¡Œç²¾ç¡®éªŒè¯ã€‚
é‡æ–°å®šä¹‰äº†VoronoÃ¯å›¾ï¼Œå¹¶è¯æ˜äº†çº¦æŸVoronoÃ¯å›¾ä¸çº¦æŸDelaunayä¸‰è§’å‰–åˆ†ä¹‹é—´çš„å¯¹å¶æ€§ä»ç„¶å­˜åœ¨ã€‚

Definition 3.4 çº¦æŸæ¬§å‡ é‡Œå¾—è·ç¦»(Constraint Euclidean distance)

Definition 3.5 (Constrained VoronoÃ¯ diagram)

```

![image-20240103155026805](./assets/image-20240103155026805.png)

# ä¸‰ã€æ ¸å¿ƒç±»çš„æ–¹æ³•å®ç°

## 3.1æºç æµç¨‹

## ä¸€äº›å…¨å±€å˜é‡

```
edgePool 
edgePool.allocateEdge(v[0], v[1]



```



### 1.add(Vertex):boolean æ·»åŠ é¡¶ç‚¹

#### 1.1public boolean add(final Vertex v)

```java
public boolean add(final Vertex v) {
    if (isLocked) 
    {//å¦‚æœä¸‰è§’ç½‘å·²ç»é”å®šï¼Œåˆ™ç¦æ­¢æ·»åŠ æˆ–è°ƒç”¨é¡¶ç‚¹ï¼ˆä¾‹å¦‚æ·»åŠ çº¦æŸåˆ°ä¸‰è§’ç½‘æ ¼æˆ–è€…å¤„ç½®ä¸‰è§’ç½‘ä¼šè§¦å‘ï¼‰
      if (isDisposed)
         {//å·²å¤„ç½®ä¸‰è§’ç½‘ã€‚ä¸å½“å‰å®ä¾‹å…³è”çš„æ‰€æœ‰å†…éƒ¨å¯¹è±¡éƒ½è¶…å‡ºäº†ä½œç”¨åŸŸ
           throw new IllegalStateException(
                   "Unable to add vertex after a call to dispose()");
         } else 
         {
           throw new IllegalStateException(
                   "Unable to add vertex, TIN is locked");
         }
    }//isLockedç»“å°¾
      
    nVerticesInserted++;//éœ€è¦æ’å…¥çš„ç‚¹ä¸ªæ•°ï¼Œå¯èƒ½å°äºå®é™…å­˜å‚¨ç‚¹æ•°ï¼ˆå› ä¸ºå†—ä½™æ’å…¥ï¼‰
      
    if (isBootstrapped) 
    {
      //å¦‚æœå·²ç»åˆå§‹åŒ–æˆåŠŸæ‰¾åˆ°äº†åˆå§‹ä¸‰è§’å½¢ï¼Œåˆ™ç›´æ¥è¿›è¡Œæ–°ç‚¹æ’å…¥çš„è¿‡ç¨‹
      return addWithInsertOrAppend(v);
    } else
     {
             if (vertexList == null) 
             {
                 //vertexListï¼Œé¡¶ç‚¹çš„ä¸´æ—¶åˆ—è¡¨ï¼Œåœ¨ä¸‰è§’ç½‘æˆåŠŸåˆå§‹åŒ–åä¿ç•™ï¼Œç„¶åä¸¢å¼ƒã€‚
               vertexList = new ArrayList<>();
               vertexList.add(v);
               return false;
             }
        
          //è¿è¡Œåˆ°æ­¤å¤„ï¼Œè¯´æ˜ä¸‰è§’ç½‘æ ¼æœªåˆå§‹åŒ–ä½†ä¸´æ—¶é¡¶ç‚¹åˆ—è¡¨(vertexList)ä¸­å·²ç»å­˜åœ¨é¡¶ç‚¹
          vertexList.add(v);
          boolean status = bootstrap(vertexList);//æˆåŠŸåˆ™ä¸ºtrue
          //è‡³å°‘ä¸‰ä¸ªç‚¹æ‰èƒ½åˆå§‹åŒ–ï¼Œç¬¬ä¸€æ¬¡æµ‹è¯•æ—¶ï¼Œstatusåœ¨å¡å…¥å…­ä¸ªé¡¶ç‚¹å˜ä¸ºtrueï¼Œ
          //æ‰€ä»¥å¹¶ä¸æ˜¯ä»»æ„ä¸‰ä¸ªé¡¶ç‚¹å°±å¯ä»¥ï¼Œéœ€è¦è¿›ä¸€æ­¥æŸ¥çœ‹å¼•å¯¼å‡½æ•°bootstrapï¼ˆï¼‰
          //æŸ¥çœ‹ä»¥åï¼Œéœ€è¦æ»¡è¶³ä¸‰ä¸ªé¡¶ç‚¹å½¢æˆä¸‰è§’å½¢é¢ç§¯å¤§äºæœ€å°é˜™å€¼
          //å¼•å¯¼æˆåŠŸåisBootstrapped ç½®ä¸º true;
       if (status) 
        {
            // the bootstrap process uses 3 vertices from
            // the vertex list but does not remove them from
            // the list.   The processVertexInsertion method has the ability
            // to ignore multiple insert actions for the same vertex.
            //å¯åŠ¨è¿‡ç¨‹ä½¿ç”¨é¡¶ç‚¹åˆ—è¡¨ä¸­çš„3ä¸ªé¡¶ç‚¹ï¼Œä½†ä¸å°†å®ƒä»¬ä»åˆ—è¡¨ä¸­ç§»é™¤ã€‚
            //------------------------
            // processVertexInsertionæ–¹æ³•èƒ½å¤Ÿå¿½ç•¥åŒä¸€é¡¶ç‚¹çš„å¤šä¸ªæ’å…¥æ“ä½œ
            //å› æ­¤æ— éœ€é¡¾å¿Œç”¨äºå¯åŠ¨åˆå§‹åŒ–çš„æœ€åˆçš„ä¸‰ä¸ªé¡¶ç‚¹
            //--------------------------
            if (vertexList.size() > 3) 
            {
                  //å¯åŠ¨æˆåŠŸåå¦‚æœå¤§äºä¸‰ä¸ªé¡¶ç‚¹ï¼Œåˆ™ä¾¿åˆ©vertexListé€ä¸ªæ’å…¥è¿›è¡Œä¸‰è§’åˆ¨åˆ†
                  for (Vertex vertex : vertexList) 
                  {
                    //é€šè¿‡æ’å…¥æˆ–æ‰©å±•æ·»åŠ 
                    addWithInsertOrAppend(vertex);
                   }
            }
            vertexList.clear();
            vertexList = null;
            return true;
        }
       return false;
    }//elseç»“å°¾
  }
```

#### 1.2add(final List< Vertex > list, IMonitorWithCancellation monitor)

```java
 public boolean add(final List<Vertex> list, IMonitorWithCancellation monitor) {
   
   //1ã€å¦‚æœTINæ˜¯é”å®šçš„ï¼ˆisLocked ä¸º trueï¼‰ï¼Œ
   //åˆ™æ ¹æ®æ˜¯å¦å·²ç»è°ƒç”¨äº† dispose() æŠ›å‡ºä¸åŒçš„ IllegalStateException
    if (isLocked) {
      if (isDisposed) {
        throw new IllegalStateException(
          "Unable to add vertex after a call to dispose()");
      } else {
        throw new IllegalStateException(
          "Unable to add vertex, TIN is locked");
      }
    }
   
   //2ã€å¦‚æœä¼ å…¥çš„ list æ˜¯ null æˆ–è€…ä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å› falseï¼Œè¡¨ç¤ºæ²¡æœ‰é¡¶ç‚¹è¢«æ·»åŠ ã€‚
    if (list == null || list.isEmpty()) {
      return false;
    }
   
    int nVertices = list.size();
    //int iProgressThreshold = Integer.MAX_VALUE;
    //int pProgressThreshold = 0;
   //åˆå§‹åŒ–è¿›åº¦ç›‘æ§å˜é‡ï¼š
   //if (monitor != null) {
   //  monitor.reportProgress(0);
   //  int iPercent = monitor.getReportingIntervalInPercent();
   //  int iTemp = (int) (nVertices * (iPercent / 100.0) + 0.5);
   //  if (iTemp > 1) {
   //    if (iTemp < 10000) {
   //      iTemp = 10000;
   //    }
   //    iProgressThreshold = iTemp;
   //  }
   //}
   
    //æ›´æ–°å·²æ’å…¥é¡¶ç‚¹æ•°
    nVerticesInserted += list.size();
    List<Vertex> aList = list;
    if (!isBootstrapped) {
      //å¦‚æœTINå°šæœªå¯åŠ¨ï¼ˆisBootstrapped ä¸º falseï¼‰ï¼Œ
      //åˆ™å°è¯•ä½¿ç”¨ bootstrap æ–¹æ³•è¿›è¡Œå¯åŠ¨ã€‚
      //å¯åŠ¨å¯èƒ½éœ€è¦ä¹‹å‰æ·»åŠ çš„é¡¶ç‚¹ï¼Œæ‰€ä»¥å¦‚æœ vertexList ä¸æ˜¯ nullï¼Œ
      //åˆ™å°†æ–°çš„é¡¶ç‚¹åˆ—è¡¨æ·»åŠ åˆ°å…¶ä¸­å¹¶é‡æ–°èµ‹å€¼ç»™ aListã€‚
      if (vertexList != null) {
        vertexList.addAll(list);
        aList = vertexList;
      }
      //å¦‚æœvertexListä¸ºnullï¼Œåˆ™ç›´æ¥è¿›è¡Œåˆå§‹åŒ–
      boolean status = bootstrap(aList);
      
      if (!status) {
        //å¦‚æœå¯åŠ¨å¤±è´¥ï¼Œå°†å¤åˆ¶é¡¶ç‚¹åˆ—è¡¨ä»¥ä¾¿äºå°†æ¥æ“ä½œï¼Œå¹¶è¿”å› falseã€‚
        
        //vertexListä¸ºnullï¼ŒæŠŠlistå¡è¿›å»ï¼Œä»¥å¤‡åç”¨ã€‚
        //å¦‚æœä¸ä¸ºnullï¼Œåˆšåˆšå·²ç»å¡è¿‡äº†ï¼ŒvertexList.addAll(list);
        if (vertexList == null) {
          vertexList = new ArrayList<>();
        }
        vertexList.addAll(list);
        return false;
      }
      // if the bootstrap succeeded, just fall through
      // and process the remainder of the list.
      //å¦‚æœå¼•å¯¼æˆåŠŸï¼Œåªéœ€é€šè¿‡å¤„ç†åˆ—è¡¨çš„å…¶ä½™éƒ¨åˆ†ã€‚
    }
//è°ƒç”¨ preAllocateEdges(aList.size()) é¢„å…ˆåˆ†é…è¶³å¤Ÿçš„è¾¹ç¼˜ç©ºé—´ï¼Œå‡†å¤‡æ¥æ”¶æ–°çš„é¡¶ç‚¹ã€‚
    this.preAllocateEdges(aList.size());
    //int nVertexAdded = 0;
    for (Vertex v : aList) {
      addWithInsertOrAppend(v);//é€ä¸ªæ·»åŠ é¡¶ç‚¹åˆ°TINä¸­
      //nVertexAdded++;
      //pProgressThreshold++;
      //if (pProgressThreshold == iProgressThreshold) {
      //  pProgressThreshold = 0;
      //  monitor.reportProgress((int) (0.1 + (100.0 * (nVertexAdded + 1)) / nVertices));
      //}
    }

    if (vertexList != null) {
      vertexList.clear();
      vertexList = null;
    }
    return true;
  }

```



#### 1.3ã€bootstrap( List<Vertex<x>>) :boolean å¯åŠ¨åˆå§‹åŒ–

```java
/**
   * Create the initial three-vertex mesh by selecting vertices from the input
   * list. Logic is provided to attempt to identify a initial triangle with a
   * non-trivial area (on the theory that this stipulation produces a more
   * robust initial mesh). In the event of an unsuccessful bootstrap attempt,
   * future attempts will be conducted as the calling application provides
   * additional vertices.
   * é€šè¿‡ä»è¾“å…¥åˆ—è¡¨ä¸­é€‰æ‹©é¡¶ç‚¹æ¥åˆ›å»ºåˆå§‹çš„ä¸‰é¡¶ç‚¹ç½‘æ ¼ã€‚
   * æä¾›äº†é€»è¾‘æ¥å°è¯•è¯†åˆ«å…·æœ‰éå¹³å‡¡é¢ç§¯çš„åˆå§‹ä¸‰è§’å½¢ï¼ˆåŸºäºè¯¥è§„å®šäº§ç”Ÿæ›´ç¨³å¥çš„åˆå§‹ç½‘æ ¼çš„ç†è®ºï¼‰ã€‚
   * å¦‚æœå¼•å¯¼å°è¯•ä¸æˆåŠŸï¼Œå°†åœ¨è°ƒç”¨åº”ç”¨ç¨‹åºæä¾›é¢å¤–é¡¶ç‚¹æ—¶è¿›è¡Œæœªæ¥çš„å°è¯•ã€‚
   *
   * @param list a valid list of input vertices.
   * @return if successful, true; otherwise, false.
   */
private boolean bootstrap(final List<Vertex> list) {
    //è¿›è¡Œåˆå§‹åŒ–ï¼Œå¦‚æœæˆåŠŸåœ¨è¿”å›åˆå§‹ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹ï¼Œå¦åˆ™è¿”å›null
    Vertex[] v = new BootstrapUtility(thresholds).bootstrap(list);
    if (v == null) {
      return false;
    }

    //å·²ç»æˆåŠŸå¯åŠ¨ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªåˆå§‹çš„ä¸‰è§’å½¢
    //ä¸ºåˆå§‹ä¸‰è§’ç½‘åˆ†é…è¾¹ç¼˜ç¼“å­˜
    QuadEdge e1 = edgePool.allocateEdge(v[0], v[1]);
    QuadEdge e2 = edgePool.allocateEdge(v[1], v[2]);
    QuadEdge e3 = edgePool.allocateEdge(v[2], v[0]);
    QuadEdge e4 = edgePool.allocateEdge(v[0], null);
    QuadEdge e5 = edgePool.allocateEdge(v[1], null);
    QuadEdge e6 = edgePool.allocateEdge(v[2], null);

    //è®¾ç½®å­ªç”Ÿè¾¹
    QuadEdge ie1 = e1.getDual();
    QuadEdge ie2 = e2.getDual();
    QuadEdge ie3 = e3.getDual();
    QuadEdge ie4 = e4.getDual();
    QuadEdge ie5 = e5.getDual();
    QuadEdge ie6 = e6.getDual();

    // establish linkages for initial TIN
    //ä¸ºåˆå§‹TINå»ºç«‹è”ç³»
    //è®¾ç½®å‰é©±è¾¹
    e1.setForward(e2);
    e2.setForward(e3);
    e3.setForward(e1);
    e4.setForward(ie5);
    e5.setForward(ie6);
    e6.setForward(ie4);

    ie1.setForward(e4);
    ie2.setForward(e5);
    ie3.setForward(e6);
    ie4.setForward(ie3);
    ie5.setForward(ie1);
    ie6.setForward(ie2);
    //åˆå§‹åŒ–æ ‡å¿—è®¾ä¸ºtrue
    isBootstrapped = true;

    //ä½¿ç”¨processVertexInsertionæ–¹æ³•æ’å…¥é¡¶ç‚¹æ—¶ï¼Œå°†å¯¹é¡¶ç‚¹æ‰§è¡Œxï¼Œyè¾¹ç•Œæµ‹è¯•ã€‚
    //ä½†ç”±äºè¿™ä¸‰ä¸ªå·²ç»æ˜¯TINçš„ä¸€éƒ¨åˆ†ï¼Œè¯·æ˜ç¡®æµ‹è¯•å®ƒä»¬çš„è¾¹ç•Œã€‚
    //ä½¿ç”¨processVertexInsertionæ–¹æ³•æ’å…¥é¡¶ç‚¹æ—¶ï¼Œå°†å¯¹é¡¶ç‚¹æ‰§è¡Œxï¼Œyè¾¹ç•Œæµ‹è¯•ã€‚
    //ä½†ç”±äºè¿™ä¸‰ä¸ªå·²ç»æ˜¯TINçš„ä¸€éƒ¨åˆ†ï¼Œè¯·æ˜ç¡®æµ‹è¯•å®ƒä»¬çš„è¾¹ç•Œã€‚
    boundsMinX = v[0].x;
    boundsMaxX = boundsMinX;
    boundsMinY = v[0].y;
    boundsMaxY = boundsMinY;
    for (int i = 1; i < 3; i++) {
      if (v[i].x < boundsMinX) {
        boundsMinX = v[i].x;
      } else if (v[i].x > boundsMaxX) {
        boundsMaxX = v[i].x;
      }
      if (v[i].y < boundsMinY) {
        boundsMinY = v[i].y;
      } else if (v[i].y > boundsMaxY) {
        boundsMaxY = v[i].y;
      }
    }

    return true;
  }

//------------------------------------------------


```

##### //BootstrapUtility(thresholds).bootstrap(list);|çœŸæ­£çš„åˆå§‹åŒ–å¯åŠ¨å‡½æ•°

```java
  public Vertex[] bootstrap(final List<Vertex> list) {

    //ç¬¬ä¸€æ­¥
    if (list.size() < 3) {
      return null;  //NOPMD
    }

    Vertex[] v = new Vertex[3];
    Vertex[] vtest = new Vertex[3];
    int n = list.size();
    int nTrial = computeNumberOfTrials(n);//è®¡ç®—å®éªŒæ¬¡æ•°3~16æ¬¡

    double bestScore = Double.NEGATIVE_INFINITY;//æµ®ç‚¹æ•°è´Ÿæ— ç©·
    //å®éªŒnTrialæ¬¡
    for (int iTrial = 0; iTrial < nTrial; iTrial++) {
      
      if (n == 3) {/----------
        //å¦‚æœåªæœ‰ä¸‰ä¸ªç‚¹ï¼Œåˆ™å–è¿™ä¸‰ä¸ªç‚¹
        vtest[0] = list.get(0);
        vtest[1] = list.get(1);
        vtest[2] = list.get(2);
      } else {
        // éšæœºæ‹¾å–ä¸‰ä¸ªå”¯ä¸€çš„é¡¶ç‚¹
        for (int i = 0; i < 3; i++) {
          while (true) {
            //random.nextInt(n) ç”Ÿæˆä¸€ä¸ª[0ï¼Œn)ä¹‹é—´çš„éšæœºæ•´æ•°ï¼Œéšæœºå–é¡¶ç‚¹ã€‚
            int index = random.nextInt(n); // (int) (n * random.nextDouble());
            vtest[i] = list.get(index);//å–ç´¢å¼•ä¸ºindexçš„é¡¶ç‚¹
            // æ£€æŸ¥å½“å‰é€‰æ‹©çš„å…ƒç´ æ˜¯å¦ä¸ä¹‹å‰é€‰æ‹©çš„å…ƒç´ é‡å¤
            for (int j = 0; j < i; j++) {
              if (vtest[j] == vtest[i]) {
                vtest[i] = null;
                break;// é€€å‡ºæ£€æŸ¥é‡å¤çš„å¾ªç¯ï¼Œé‡æ–°é€‰æ‹©å…ƒç´ 
              }
            }
            // å¦‚æœæ²¡æœ‰å‘ç°é‡å¤ï¼Œé€€å‡ºå†…å±‚ while å¾ªç¯
            if (vtest[i] != null) {
              break;// è·³å‡ºå†…å±‚ while å¾ªç¯ï¼Œé€‰æ‹©ä¸‹ä¸€ä¸ªå…ƒç´ 
            }
          }
        }
      }//----------æ‹¾å–ç‚¹ç»“æŸ
      
      double a = geoOp.area(vtest[0], vtest[1], vtest[2]);
      if (a == 0) {//åˆ¤æ–­æ˜¯ä¸æ˜¯å…±çº¿å³é¢ç§¯ä¸º0
        continue;
      } else if (a < 0) {//é¢ç§¯æ˜¯å¦ä¸ºè´Ÿå€¼
        //å¦‚æœé¢ç§¯ a å°äº 0ï¼Œè¡¨ç¤ºä¸‰ä¸ªé¡¶ç‚¹çš„é¡ºåºå¯èƒ½æ˜¯é€†æ—¶é’ˆæ–¹å‘ã€‚
        //äº¤æ¢ vtest[0] å’Œ vtest[2] çš„ä½ç½®ï¼Œä½¿å…¶æˆä¸ºé¡ºæ—¶é’ˆé¡ºåºï¼Œå¹¶å°†é¢ç§¯å–æ­£å€¼ã€‚
        Vertex swap = vtest[0];
        vtest[0] = vtest[2];
        vtest[2] = swap;
        a = -a;
      }
      if (a > bestScore) {
        bestScore = a;
        v[0] = vtest[0];
        v[1] = vtest[1];
        v[2] = vtest[2];
      }
    }//ä¸€æ¬¡è¯•éªŒç»“æŸï¼Œç»§ç»­å¾ªç¯
//triangleMinAreaThreshold = thresholds.getNominalPointSpacing() * MIN_AREA_FACTOR;
    
    //IncrementalTin(final double estimatedPointSpacing) {
   // this.nominalPointSpacing = estimatedPointSpacing;
    //thresholds = new Thresholds(this.nominalPointSpacing);}
    //thresholds.getNominalPointSpacing()å–å†³äºäº†æ„å»ºIncrementalTinæ—¶ä¼ å…¥çš„å˜é‡ã€‚
    
   // MIN_AREA_FACTOR çš„å€¼å¤§çº¦ä¸º 0.00676ã€‚
    //MIN_AREA_FACTOR = Math.sqrt(3.0) / 4.0 / 64.0;
    if (bestScore >= triangleMinAreaThreshold) {
      //è®²ç™½äº†å°±æ˜¯åŸºæœ¬ä¸Šå°±æ˜¯æœ‰é¢ç§¯å°±è¡Œï¼Œè®¾ç½®äº†ä¸€ä¸ªæœ€å°é¢ç§¯çš„ä¸‹é™ï¼Œé˜™å€¼ä¸æ˜¯ç‰¹åˆ«å¤§
      return v;
    }

    if (n == 3) {
      //å¦‚æœå°±ä¸‰ä¸ªç‚¹,ä¸Šé¢çš„è¯•éªŒå·²ç»æµ‹è¯•äº†è¿™ç§æƒ…å†µâ€”â€”é¡¶ç‚¹é›†è¿˜ä¸è¶³ä»¥å¼•å¯¼TIN
      return null; //NOPMD
    }
    
    // å¤§å¤šæ•°æ—¶å€™ï¼Œå¦‚æœè¾“å…¥é›†å½¢å¼è‰¯å¥½ï¼Œåˆ™éšæœºæµ‹è¯•å°†æ‰¾åˆ°æœ‰æ•ˆçš„é¡¶ç‚¹é›†ã€‚
    // ç„¶è€Œï¼Œæœ‰æ—¶æˆ‘ä»¬åªæ˜¯è¿æ°”ä¸å¥½ï¼Œéšæœºé€‰æ‹©é¡¶ç‚¹æ°å¥½é€‰æ‹©äº†ä¸èµ·ä½œç”¨çš„é¡¶ç‚¹ã€‚
    // å…¶ä»–æ—¶å€™ï¼Œè¾“å…¥æ˜¯ç—…ç†æƒ…å†µï¼ˆæ‰€æœ‰é¡¶ç‚¹éƒ½ç›¸åŒï¼Œæˆ–è€…æ‰€æœ‰é¡¶ç‚¹å…±çº¿ï¼‰ã€‚
    // testResultè¯•å›¾æ£€æµ‹ç—…ç†ç—…ä¾‹ï¼Œä¹Ÿè¯•å›¾åœ¨ä¸è¿›è¡Œè¯¦å°½æœç´¢æ‰€éœ€çš„æ½œåœ¨å¤§è§„æ¨¡å¤„ç†çš„æƒ…å†µä¸‹æ‰¾åˆ°æœ‰æ•ˆçš„ä¸‰è§’å½¢
    //è®²ç™½äº†å°±æ˜¯é¿å…è¿æ°”ä¸å¥½ï¼Œæ²¡éšæœºå¥½å¯¼è‡´åˆå§‹åŒ–æ²¡æˆåŠŸ
    List<Vertex> testList = new ArrayList<>(3);
    BootstrapTestResult testResult = this.testInput(list, testList);
    if (testResult == BootstrapTestResult.Valid) {
      v[0] = testList.get(0);
      v[1] = testList.get(1);
      v[2] = testList.get(2);
      return v;
    } else if (testResult != BootstrapTestResult.Unknown) {
      // the testInput method detected a pathological case.
      // there is no point attempting the exhaustive test
      return null;
    }

    // the testInput method could not figure out a good triangle
    // and could not decide whether the input data was pathological
    // or not.  So all it can do is an exhaustic test.testInput
    // æ–¹æ³•æ— æ³•è®¡ç®—å‡ºä¸€ä¸ªå¥½çš„ä¸‰è§’å½¢ï¼Œä¹Ÿæ— æ³•åˆ¤æ–­è¾“å…¥æ•°æ®æ˜¯å¦æ˜¯ç—…ç†æ€§çš„ã€‚æ‰€ä»¥å®ƒæ‰€èƒ½åšçš„åªæ˜¯ä¸€ä¸ªè¯¦å°½çš„æµ‹è¯•ã€‚
    exhaustiveLoop:
    for (int i = 0; i < n - 2; i++) {
      vtest[0] = list.get(i);
      for (int j = i + 1; j < n - 1; j++) {
        vtest[1] = list.get(j);
        for (int k = j + 1; k < n; k++) {
          vtest[2] = list.get(k);
          double a = geoOp.area(vtest[0], vtest[1], vtest[2]);
          double aAbs = Math.abs(a);
          if (aAbs > bestScore) {
            bestScore = aAbs;
            if (a < 0) {
              v[0] = vtest[2];
              v[1] = vtest[1];
              v[2] = vtest[0];
            } else {
              v[0] = vtest[0];
              v[1] = vtest[1];
              v[2] = vtest[2];
            }
            if (aAbs >= triangleMinAreaThreshold) {
              return v;
            }
          }
        }
      }
    }

    // the expensive loop above failed to discover a
    // useful initial triangle.  we'll just have
    // to wait for more vertices.
    //ä¸Šé¢æ˜‚è´µçš„å¾ªç¯æœªèƒ½å‘ç°æœ‰ç”¨çš„åˆå§‹ä¸‰è§’å½¢ã€‚æˆ‘ä»¬åªéœ€è¦ç­‰å¾…æ›´å¤šçš„é¡¶ç‚¹ã€‚
    return null; // NOPMD
  }

```

`bootstrap` æ–¹æ³•æ˜¯ä¸€ä¸ªå‡ ä½•å¤„ç†ç®—æ³•çš„ä¸€éƒ¨åˆ†ï¼Œä¸»è¦ç”¨äºä½¿ç”¨åˆå§‹é¡¶ç‚¹é›†åˆæ¥åˆå§‹åŒ–è¯¸å¦‚ä¸è§„åˆ™ä¸‰è§’ç½‘ï¼ˆTINï¼‰è¿™æ ·çš„ç»“æ„ï¼Œå®ƒå°è¯•æ‰¾åˆ°å½¢æˆä¸€ä¸ªéé€€åŒ–ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹ã€‚è¾“å…¥æ˜¯ `Vertex` å¯¹è±¡çš„åˆ—è¡¨ï¼Œè¾“å‡ºæ˜¯ç»„æˆè¿™æ ·ä¸€ä¸ªä¸‰è§’å½¢çš„ä¸‰ä¸ª `Vertex` å¯¹è±¡çš„æ•°ç»„ï¼Œæˆ–è€…åœ¨æ‰¾ä¸åˆ°åˆé€‚çš„ä¸‰è§’å½¢æ—¶è¿”å› `null`ã€‚

ä»¥ä¸‹æ˜¯è¯¥æ–¹æ³•çš„é€æ­¥è§£è¯»ï¼š

1. **åˆæ­¥æ£€æŸ¥**ï¼š
   - å¦‚æœåˆ—è¡¨ä¸­çš„é¡¶ç‚¹æ•°å°‘äº3ä¸ªï¼Œåˆ™ç«‹å³è¿”å› `null`ï¼Œå› ä¸ºå°‘äº3ä¸ªç‚¹æ— æ³•å½¢æˆä¸‰è§’å½¢ã€‚
2. **è®¾ç½®**ï¼š
   - åˆ›å»ºäº†ä¸¤ä¸ªé¡¶ç‚¹æ•°ç»„ `v` å’Œ `vtest`ï¼Œç”¨æ¥å­˜å‚¨æœ€ä½³å¾—åˆ†ä¸‰è§’å½¢ï¼ˆ`v`ï¼‰å’Œå½“å‰å€™é€‰ä¸‰è§’å½¢ï¼ˆ`vtest`ï¼‰ã€‚
   - åˆå§‹åŒ–å˜é‡ `bestScore` ä¸ºè´Ÿæ— ç©·å¤§ï¼Œç”¨ä»¥å­˜å‚¨è¿„ä»Šä¸ºæ­¢å‘ç°çš„æœ€ä½³ä¸‰è§’å½¢çš„é¢ç§¯ã€‚
   - è®¡ç®— `nTrial` çš„å€¼ï¼Œè¿™ä¸ªå€¼å†³å®šå°†è¿›è¡Œå¤šå°‘æ¬¡éšæœºè¯•éªŒæ¥å¯»æ‰¾ä¸€ä¸ªå¥½çš„èµ·å§‹ä¸‰è§’å½¢ã€‚
3. **éšæœºè¯•éªŒ**ï¼š
   - å¦‚æœæ°å¥½æœ‰3ä¸ªé¡¶ç‚¹åœ¨åˆ—è¡¨ä¸­ï¼Œå®ƒä»¬ç›´æ¥è¢«ç”¨ä½œä¸‰è§’å½¢è€Œä¸è¿›è¡Œéšæœºè¯•éªŒã€‚
   - å¦åˆ™ï¼Œè¿›è¡Œå¤šæ¬¡è¯•éªŒï¼ŒéšæœºæŒ‘é€‰ä¸‰ä¸ªä¸åŒçš„é¡¶ç‚¹ï¼Œå¹¶æ£€æŸ¥å®ƒä»¬æ˜¯å¦å½¢æˆæœ‰æ•ˆçš„ä¸‰è§’å½¢ï¼ˆå³é¢ç§¯éé›¶ï¼‰ã€‚
   - åœ¨è¯•éªŒè¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ‰¾åˆ°æ›´å¥½çš„ä¸‰è§’å½¢ï¼ˆé¢ç§¯æ›´å¤§ï¼‰ï¼Œåˆ™å°†å…¶é¡¶ç‚¹ä¿å­˜åœ¨ `v` ä¸­ã€‚
4. **é¢ç§¯é˜ˆå€¼**ï¼š
   - è€ƒè™‘äº†ä¸‰è§’å½¢çš„æœ€å°é¢ç§¯é˜ˆå€¼ï¼ˆ`triangleMinAreaThreshold`ï¼‰ï¼Œåªæ¥å—é¢ç§¯è¶…è¿‡æ­¤é˜ˆå€¼çš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœæ‰¾åˆ°çš„æœ€ä½³ä¸‰è§’å½¢æ»¡è¶³é¢ç§¯è¦æ±‚ï¼Œåˆ™è¿”å›å…¶é¡¶ç‚¹ã€‚
5. **å¤„ç†è¾¹ç¼˜æƒ…å†µ**ï¼š
   - å¦‚æœåªæœ‰3ä¸ªé¡¶ç‚¹ä¸”æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„ä¸‰è§’å½¢ï¼Œåˆ™è¿”å› `null`ã€‚
   - å¦‚æœéšæœºè¯•éªŒæœªèƒ½äº§ç”Ÿæœ‰æ•ˆçš„ä¸‰è§’å½¢ï¼Œå°†è°ƒç”¨æ›´å¤æ‚çš„æµ‹è¯• (`testInput`) æ¥æ£€æµ‹ç—…æ€æ¡ˆä¾‹ï¼ˆä¾‹å¦‚æ‰€æœ‰é¡¶ç‚¹éƒ½ç›¸åŒæˆ–å…±çº¿ï¼‰æˆ–è€…æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„ä¸‰è§’å½¢ã€‚
   - æ ¹æ® `testInput` çš„ç»“æœï¼Œè¯¥æ–¹æ³•å¯èƒ½è¿”å›ä¸€ä¸ªæœ‰æ•ˆçš„ä¸‰è§’å½¢ï¼Œæˆ–è€…å†³å®šç»§ç»­è¿›è¡Œæ²¡æœ‰æ„ä¹‰å¹¶è¿”å› `null`ã€‚
6. **è¯¦å°½æœç´¢**ï¼š
   - å¦‚æœ `testInput` æ–¹æ³•æ— æ³•ç¡®å®šä¸€ä¸ªå¥½çš„ä¸‰è§’å½¢ï¼Œä¹Ÿæ— æ³•åˆ¤æ–­æ•°æ®æ˜¯å¦æ˜¯ç—…æ€çš„ï¼Œé‚£ä¹ˆå®ƒå°†é‡‡ç”¨è¯¦å°½æœç´¢ï¼Œå°è¯•æ¯ä¸€ç»„ä¸‰ä¸ªé¡¶ç‚¹çš„ç»„åˆï¼Œä»¥å¯»æ‰¾ä¸€ä¸ªæœ‰æ•ˆçš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœåœ¨è¿™ç§æœç´¢ä¸­æ‰¾åˆ°äº†æ»¡è¶³é¢ç§¯æ ‡å‡†çš„æœ‰æ•ˆä¸‰è§’å½¢ï¼Œåˆ™è¿”å›å…¶é¡¶ç‚¹ã€‚
7. **å¤±è´¥æƒ…å†µ**ï¼š
   - å¦‚æœåŒ…æ‹¬è¯¦å°½æœç´¢åœ¨å†…çš„æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥äº†ï¼Œè¯¥æ–¹æ³•è¿”å› `null`ï¼Œè¡¨ç¤ºæ— æ³•ç”¨å½“å‰çš„é¡¶ç‚¹é›†æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„åˆå§‹ä¸‰è§’å½¢ã€‚

åœ¨æ•´æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†å¯¹ç‰¹æ®Šæƒ…å†µçš„æ£€æŸ¥ï¼Œå°è¯•å¤„ç†å®ƒä»¬ï¼Œå¹¶æœ€ç»ˆä½œä¸ºæœ€åæ‰‹æ®µè¿›è¡Œè¯¦å°½æœç´¢ï¼Œä»¥ç¡®ä¿åœ¨å¯èƒ½çš„æƒ…å†µä¸‹æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„å¼•å¯¼ä¸‰è§’å½¢ã€‚å¦‚æœæ–¹æ³•è¿”å› `null`ï¼Œåˆ™è¡¨ç¤ºå­˜åœ¨ç—…æ€æƒ…å†µæˆ–è€…é¡¶ç‚¹æ•°é‡ä¸è¶³ï¼Œæ— æ³•å½¢æˆæœ‰æ•ˆçš„ä¸‰è§’å½¢ã€‚

#### 1.4ã€addWithInsertOrAppend( Vertex ):booleanï½œé€šè¿‡æ’å…¥æˆ–æ‰©å±•æ·»åŠ 

```java
/**
   * Performs processing for the public add() methods by adding the vertex to
   * a fully bootstrapped mesh. The vertex will be either inserted into the
   * mesh or the mesh will be extended to include the vertex.
   * é€šè¿‡å°†é¡¶ç‚¹æ·»åŠ åˆ°å®Œå…¨å¯åŠ¨çš„ç½‘æ ¼æ¥æ‰§è¡Œå¯¹å…¬å…±addï¼ˆï¼‰æ–¹æ³•çš„å¤„ç†ã€‚
   * é¡¶ç‚¹å°†è¢«æ’å…¥åˆ°ç½‘æ ¼ä¸­ï¼Œæˆ–è€…ç½‘æ ¼å°†è¢«æ‰©å±•ä»¥åŒ…æ‹¬é¡¶ç‚¹ã€‚
   è¯´ç™½äº†å°±æ˜¯åœ¨ç½‘æ ¼è¾¹ç•Œå†…æˆ–è€…åœ¨ç½‘æ ¼è¾¹ç•Œå¤–ï¼Œä¸¤ç§ä¸åŒçš„å¤„ç†
   **************************************************
   * @param v a valid vertex. ä¸€ä¸ªæœ‰æ•ˆé¡¶ç‚¹
   * @return true if the vertex was added successfully; otherwise false
   * å¦‚æœä¸€ä¸ªé¡¶ç‚¹æˆåŠŸæ·»åŠ  è¿”å›true
   * (usually in response to redundant vertex specifications).
   */  
private boolean addWithInsertOrAppend(final Vertex v) {
    final double x = v.x;
    final double y = v.y;

    int nReplacements = 0;
    //1ã€åˆ¤æ–­å¹¶æ›´æ–°åŒ…å›´ç›’çš„èŒƒå›´
    //x
    if (x < boundsMinX) {
      boundsMinX = x;
    } else if (x > boundsMaxX) {
      boundsMaxX = x;
    }
    //y
    if (y < boundsMinY) {
      boundsMinY = y;
    } else if (y > boundsMaxY) {
      boundsMaxY = y;
    }

  // å¦‚æœsearchEdgeä¸ºç©ºï¼Œåˆ™è·å–ä¸€ä¸ªèµ·å§‹è¾¹
    if (searchEdge == null) {
      searchEdge = edgePool.getStartingEdge();
    }
   // 2ã€ä½¿ç”¨walker.findAnEdgeFromEnclosingTriangleæ–¹æ³•,ä»å°é—­ä¸‰è§’å½¢ç†å¯»æ‰¾ä¸€æ¡è¾¹
  //è¯¥è¾¹ä»£è¡¨çš„æ˜¯åŒ…å«äº†è¯¥é¡¶ç‚¹çš„ä¸‰è§’å½¢çš„å…¶ä¸­ä¸€æ¡è¾¹
    searchEdge = walker.findAnEdgeFromEnclosingTriangle(searchEdge, x, y);

    // the following is a debugging aid when trying to deal with vertex
    // insertion versus TIN extension.
    ////ä»¥ä¸‹æ˜¯åœ¨å°è¯•å¤„ç†é¡¶ç‚¹æ’å…¥ä¸ä¸‰è§’ç½‘æ‰©å±•æ—¶çš„è°ƒè¯•å¸®åŠ©ã€‚
    // boolean isVertexInside = (searchEdge.getForward().getB() != null);
  
  // 3ã€æ£€æŸ¥ä¼ å…¥é¡¶ç‚¹æ˜¯å¦å’Œæœå¯»åˆ°çš„è¾¹çš„é¡¶ç‚¹åŒ¹é…ï¼ˆå³ä½ç½®éå¸¸æ¥è¿‘ï¼‰
    QuadEdge matchEdge
            = checkTriangleVerticesForMatch(searchEdge, x, y, vertexTolerance2);
    if (matchEdge != null) {
      mergeVertexOrIgnore(matchEdge, v);// å¦‚æœåŒ¹é…ï¼Œåˆ™åˆå¹¶æˆ–å¿½ç•¥
      return false;
    }

    // æ„å»ºç¼“å†²åŒºæä¾›ä¸´æ—¶è·Ÿè¸ªåˆ é™¤å’Œæ›¿æ¢è¾¹çš„åŠŸèƒ½ï¼Œåœ¨æ„å»ºTINè¿‡ç¨‹ä¸­ã€‚
    // å› ä¸ºEdgePoolçš„deleteæ–¹æ³•éœ€è¦è¿›è¡Œå¤§é‡ç°¿è®°å·¥ä½œï¼Œä½¿ç”¨ç¼“å†²åŒºå¯ä»¥æé«˜é€Ÿåº¦ã€‚
    // ç¼“å†²åŒºçš„å¤§å°åªè¶³ä»¥å®¹çº³ä¸€æ¡è¾¹ï¼Œå¦‚æœæ›´å¤§ï¼Œåˆ™ç®¡ç†æˆæœ¬å¯èƒ½è¶…è¿‡èŠ‚çœçš„æ—¶é—´ã€‚

    //æµ‹è¯•è¡¨æ˜ï¼Œç»´æŠ¤ä¸€ä¸ªæ•°ç»„è€Œä¸æ˜¯å•ä¸ªå¼•ç”¨çš„å¼€é”€è¶…è¿‡äº†æ½œåœ¨çš„èŠ‚çœã€‚ç„¶è€Œï¼Œè¿™ä¸¤ç§æ–¹æ³•çš„æ—¶é—´éå¸¸æ¥è¿‘ï¼Œå¾ˆéš¾æ¶ˆé™¤æµ‹é‡è¯¯å·®çš„å½±å“ã€‚
  
  //æœå¯»çš„è¾¹çš„èµ·å§‹ç‚¹
    Vertex anchor = searchEdge.getA();
// åˆå§‹åŒ–ä¸€äº›å˜é‡ï¼ŒåŒ…æ‹¬ç”¨äºæ„å»ºæ–°è¾¹çš„bufferä»¥åŠå¾ªç¯ä¸­ä¼šä½¿ç”¨çš„è¾¹(c, n0, n1, n2)
    QuadEdge buffer = null;
// è¿›è¡ŒDelaunayå±€éƒ¨ä¼˜åŒ–çš„å¾ªç¯ï¼Œå®ƒæ£€æŸ¥å“ªäº›ä¸‰è§’å½¢ä¸æ»¡è¶³Delaunayæ¡ä»¶ï¼Œå¹¶åšç›¸åº”çš„é¡¶ç‚¹æ’å…¥æˆ–ä¸‰è§’å½¢ç¿»è½¬æ“ä½œã€‚
    QuadEdge c, n0, n1, n2;
  // 4ã€åˆ†é…ä¸€æ¡æ–°çš„è¾¹ï¼ŒpStartæŒ‡å‘æ–°æ’å…¥çš„é¡¶ç‚¹vå’Œå½“å‰æœç´¢åˆ°çš„è¾¹çš„èµ·å§‹é¡¶ç‚¹anchor
  //å°±æ˜¯æ’å…¥çš„ç‚¹æŒ‡å‘åŒ…å«ä»–çš„ä¸‰è§’å½¢çš„å…¶ä¸­ä¸€ä¸ªé¡¶ç‚¹
    QuadEdge pStart = edgePool.allocateEdge(v, anchor); 
  // è¿™æ®µä»£ç å¼€å§‹åœ¨TINä¸­æ’å…¥æ–°çš„é¡¶ç‚¹vï¼Œå¹¶è°ƒæ•´ç›¸é‚»çš„ä¸‰è§’å½¢ã€‚
    QuadEdge p = pStart;
    p.setForward(searchEdge);//æ–°è¾¹çš„å‰é©±è¾¹ï¼ˆè‡ªç„¶å°±æ˜¯æœç´¢è¾¹ï¼‰
    n1 = searchEdge.getForward(); //æœç´¢è¾¹çš„å‰é©±è¾¹n1
    n2 = n1.getForward();//n1çš„å‰é©±è¾¹ï¼Œè¯¥å‰é©±è¾¹çš„ç»ˆç‚¹å’Œpè¾¹æ—¶ä¸€æ ·çš„
    n2.setForward(p.getDual());//å°†ä»–çš„å­ªç”Ÿè¾¹è®¾ç½®ä¸ºä»–çš„å‰é©±

    c = searchEdge;// ä»æœç´¢è¾¹å¼€å§‹å¾ªç¯
  
    while (true) {//---------whileå¼€å§‹ ä¸€ç›´å¾ªç¯
      n0 = c.getDual();//å­ªç”Ÿè¾¹
      n1 = n0.getForward();//å­ªç”Ÿè¾¹çš„å‰é©±è¾¹

      // check for the Delaunay in-circle criterion.  In the original
      // implementation, this was accomplished through a call to
      // a method in another class (GeometricOperations), but testing
      // revealed that we could gain nearly 10 percent throughput
      // by embedding the logic in this loop.
      // the three vertices of the neighboring triangle are, in order,
      //æ£€æŸ¥åœ†ä¸­çš„Delaunayå‡†åˆ™ã€‚
      //åœ¨æœ€åˆçš„å®ç°ä¸­ï¼Œè¿™æ˜¯é€šè¿‡è°ƒç”¨å¦ä¸€ä¸ªç±»ï¼ˆGeometricOperationsï¼‰ä¸­çš„æ–¹æ³•æ¥å®ç°çš„ï¼Œä½†æµ‹è¯•è¡¨æ˜ï¼Œ
       //é€šè¿‡åœ¨è¿™ä¸ªå¾ªç¯ä¸­åµŒå…¥é€»è¾‘ï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—è¿‘10%çš„ååé‡ã€‚ç›¸é‚»ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹ä¾æ¬¡ä¸ºï¼Œ
      //n0.getA(), n1.getA(), n1.getB()
      
      // æ£€æŸ¥æ˜¯å¦æ»¡è¶³Delaunayæ¡ä»¶ï¼Œå…·ä½“æ˜¯é€šè¿‡è®¡ç®—ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨å…¶ä»–ä¸‰ä¸ªç‚¹æ„æˆçš„åœ†å†…æ¥åˆ¤æ–­çš„
      //æ£€æŸ¥åœ†ä¸­çš„Delaunayå‡†åˆ™ã€‚
      //ç›¸é‚»ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹ä¾æ¬¡ä¸ºï¼Œ
      // n0.getA(), n1.getA(), n1.getB()
      double h; // ç”¨äºå­˜å‚¨å†…æ¥åœ†è®¡ç®—ç»“æœ
      Vertex vA = n0.getA();
      Vertex vB = n1.getA();
      Vertex vC = n1.getB();
      // æ£€æŸ¥æ˜¯å¦æœ‰â€œé¬¼â€ï¼ˆå³è™šæ‹Ÿï¼‰é¡¶ç‚¹ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è°ƒç”¨ç‰¹æ®Šæ–¹æ³•å¤„ç†
      if (vC == null) {
        h = inCircleWithGhosts(vA, vB, v);
      } else if (vA == null) {
        h = inCircleWithGhosts(vB, vC, v);
      } else if (vB == null) {
        h = inCircleWithGhosts(vC, vA, v);
      } else {
        nInCircle++;
        double a11 = vA.x - x;
        double a21 = vB.x - x;
        double a31 = vC.x - x;

        // column 2
        double a12 = vA.y - y;
        double a22 = vB.y - y;
        double a32 = vC.y - y;
// å†…æ¥åœ†åˆ¤å®šçš„å®é™…è®¡ç®—ï¼Œä½¿ç”¨è¡Œåˆ—å¼æ–¹å¼
        h = (a11 * a11 + a12 * a12) * (a21 * a32 - a31 * a22)
                + (a21 * a21 + a22 * a22) * (a31 * a12 - a11 * a32)
                + (a31 * a31 + a32 * a32) * (a11 * a22 - a21 * a12);
        // å¦‚æœè®¡ç®—ç»“æœæ¥è¿‘é›¶ï¼ˆåœ¨ä¸€å®šé˜ˆå€¼èŒƒå›´å†…ï¼‰ï¼Œåˆ™ä½¿ç”¨æ›´ç²¾ç¡®çš„å››å€ç²¾åº¦æ–¹æ³•è¿›è¡Œé‡æ–°è®¡ç®—
        if (inCircleThresholdNeg < h && h < inCircleThreshold) {
          nInCircleExtendedPrecision++;
          double h2 = h;
          h = geoOp.inCircleQuadPrecision(
                  vA.x, vA.y,
                  vB.x, vB.y,
                  vC.x, vC.y,
                  x, y);
          // å¦‚æœå››å€ç²¾åº¦ç»“æœå’ŒåŸå§‹ç»“æœç¬¦å·ä¸ä¸€è‡´ï¼Œè®°å½•å†²çªæ¬¡æ•°
          if (h == 0) {
            if (h2 != 0) {
              nInCircleExtendedPrecisionConflicts++;
            }
          } else if (h * h2 <= 0) {
            nInCircleExtendedPrecisionConflicts++;
          }
        }
      }//-----------------åˆ°æ­¤åˆ¤æ–­æ˜¯å¦ä¸ºå†…æ¥åœ†å®Œæˆ
      
      if (h >= 0) {
        // å¦‚æœä¸æ»¡è¶³Delaunayæ¡ä»¶ï¼Œéœ€è¦ç¿»è½¬è¾¹ï¼Œå¹¶è°ƒæ•´ä¸‰è§’å½¢
        n2 = n1.getForward();
        n2.setForward(c.getForward());
        p.setForward(n1);
        c.clear();   // æ¸…é™¤å½“å‰è¾¹çš„ä¿¡æ¯// optional, done as a diagnostic
        // we need to get the base reference in order to ensure
        // that any ghost edges we create will start with a
        // non-null vertex and end with a null.
        c = c.getBaseReference(); // è·å–åŸºç¡€è¾¹å¼•ç”¨
        if (buffer == null) {
          c.clear();
          buffer = c; // ä½¿ç”¨bufferä¸´æ—¶å­˜å‚¨è¾¹
        } else {
          edgePool.deallocateEdge(c);// é‡Šæ”¾ä¸éœ€è¦çš„è¾¹å›è¾¹æ± 
        }

        c = n1; // ç§»åŠ¨åˆ°ä¸‹ä¸€æ¡è¾¹
        nReplacements++;// å¢åŠ æ›¿æ¢æ¬¡æ•°
      } else {
        // check for completion
         // å¦‚æœæ»¡è¶³Delaunayæ¡ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰å¤„ç†
        if (c.getB() == anchor) {
          pStart.getDual().setForward(p);
          searchEdge = pStart;
          // TO DO: is buffer ever not null?
          //        i don't think so because it could only
          //        happen in a case where an insertion decreased
          //        the number of edge. so the following code
          //        is probably unnecessary
          //å¾…åŠäº‹é¡¹ï¼šç¼“å†²åŒºæ°¸è¿œä¸ä¸ºç©ºå—ï¼Ÿ
          //æˆ‘ä¸è¿™ä¹ˆè®¤ä¸ºï¼Œå› ä¸ºåªæœ‰åœ¨æ’å…¥å‡å°‘äº†è¾¹ç¼˜æ•°é‡çš„æƒ…å†µä¸‹æ‰ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚
            //æ‰€ä»¥ä¸‹é¢çš„ä»£ç å¯èƒ½æ²¡æœ‰å¿…è¦
          // å¾ªç¯ç»“æŸåï¼Œå¦‚æœæœç´¢ä¸­ä½¿ç”¨äº†bufferï¼Œåˆ™å°†å…¶é‡Šæ”¾å›edgePoolã€‚
           // å¦‚æœbufferä¸ä¸ºç©ºï¼Œåˆ™å°†å…¶é‡Šæ”¾
          if (buffer != null) {
            edgePool.deallocateEdge(buffer);
          }
 // è¿›è¡Œäº†å¤šå°‘æ¬¡è¾¹çš„æ›¿æ¢æ“ä½œï¼Œç”¨äºæ€§èƒ½ç›‘æ§å’Œè°ƒè¯•ã€‚
          nEdgesReplacedDuringBuild += nReplacements;
          if (nReplacements > maxEdgesReplacedDuringBuild) {
            maxEdgesReplacedDuringBuild = nReplacements;
          }

          // ç¬¦åˆå†…æ¥åœ†æ ‡å‡†ï¼Œæ²¡æœ‰éœ€è¦ç¿»è½¬çš„ï¼Œè·³å‡ºå¾ªç¯
          break;
        }

         // ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡è¾¹ï¼ˆä¸‰è§’å½¢çš„ä¸‹ä¸€ä¸ªè¾¹ï¼‰
        n1 = c.getForward();
        QuadEdge e;
        if (buffer == null) {
          e = edgePool.allocateEdge(v, c.getB());// åˆ†é…æ–°çš„è¾¹
        } else {
          buffer.setVertices(v, c.getB());// è®¾ç½®bufferçš„é¡¶ç‚¹
          e = buffer;// è®¾ç½®bufferçš„é¡¶ç‚¹
          buffer = null;// æ¸…ç©ºbuffer
        }
        e.setForward(n1);
        e.getDual().setForward(p);
        c.setForward(e.getDual());
        p = e;// æ›´æ–°å½“å‰çš„pè¾¹ï¼ˆæ’å…¥ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªä¸‰è§’å½¢é¡¶ç‚¹ï¼‰
        c = n1;// ç§»åŠ¨åˆ°ä¸‹ä¸€æ¡è¾¹ï¼ˆåŒ…å«é¡¶ç‚¹çš„ä¸‰è§’å½¢çš„ä¸‹ä¸€ä¸ªè¾¹ï¼‰
      }
    }//-----whileç»“æŸ
    return true; // è¿”å›trueè¡¨ç¤ºé¡¶ç‚¹æ·»åŠ æˆåŠŸ
  }
```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œä½œè€…å®ç°äº†ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ï¼Œé€šè¿‡å±€éƒ¨ä¼˜åŒ–æ¥ç»´æŒDelaunayä¸‰è§’ç½‘çš„ç‰¹æ€§ã€‚è¿™æ¶‰åŠåˆ°æ£€æŸ¥æ–°å¢é¡¶ç‚¹ä¸ç°æœ‰ä¸‰è§’å½¢å…³ç³»ï¼Œæ ¹æ®Delaunayæ¡ä»¶ï¼ˆå³ä¸‰è§’å½¢å†…æ¥åœ†ï¼‰æ¥å†³å®šæ˜¯å¦éœ€è¦ç¿»è½¬è¾¹ç¼˜ã€‚å¦‚æœç¿»è½¬å‘ç”Ÿï¼Œç›¸å…³çš„ä¸‰è§’å½¢ä¹Ÿéœ€è¦æ›´æ–°ã€‚æ•´ä¸ªè¿‡ç¨‹å°†ä¸€ç›´è¿›è¡Œï¼Œç›´è‡³æ‰€æœ‰ä¸æ–°é¡¶ç‚¹ç›¸å…³çš„ä¸‰è§’å½¢éƒ½æ»¡è¶³Delaunayæ¡ä»¶ã€‚

æ€§èƒ½æ–¹é¢ï¼Œä»£ç ä½œè€…è¿˜æåˆ°äº†é€šè¿‡ä½¿ç”¨ä¸€ä¸ªç®€å•çš„bufferæ¥ä¼˜åŒ–å¯¹è¾¹ç¼˜æ± æ“ä½œçš„é€Ÿåº¦ï¼Œå‡å°‘äº†å¤æ‚çš„ç°¿è®°å·¥ä½œã€‚æ­¤å¤–ï¼Œæ³¨é‡Šä¸­è¿˜æåˆ°äº†åœ¨å®é™…è¿è¡Œä¸­å¯¹è¿™ç§ä¼˜åŒ–ç­–ç•¥çš„è€ƒé‡ï¼Œæ¯”å¦‚bufferçš„å¤§å°é€‰æ‹©å’Œæ˜¯å¦çœŸçš„æå‡äº†æ€§èƒ½ç­‰ã€‚

è§£é‡Šå¦‚ä¸‹ï¼š

1. é¦–å…ˆæ£€æŸ¥ `n0.getA()`, `n1.getA()`, å’Œ `n1.getB()` æ˜¯å¦æœ‰ä»»ä½•ä¸€ä¸ªæ˜¯â€œé¬¼â€é¡¶ç‚¹ï¼Œå¦‚æœæœ‰ï¼Œåˆ™è°ƒç”¨ `inCircleWithGhosts` æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚è¿™äº›é¬¼é¡¶ç‚¹é€šå¸¸å‡ºç°åœ¨è¾¹ç•Œè¾¹ä¸Šï¼Œè¡¨ç¤ºæ— é™è¿œçš„è™šæ‹Ÿé¡¶ç‚¹ã€‚

2. å¦‚æœä¸‰ä¸ªé¡¶ç‚¹éƒ½æ˜¯å®é™…çš„é¡¶ç‚¹ï¼Œæ‰§è¡Œæ­£å¸¸çš„å†…æ¥åœ†è®¡ç®—ã€‚è¿™é‡Œä½¿ç”¨äº†è¡Œåˆ—å¼è®¡ç®—ï¼Œå®ƒæ¶‰åŠåˆ°æ¯ä¸ªé¡¶ç‚¹ç›¸å¯¹äºæ–°æ’å…¥é¡¶ç‚¹ `(x, y)` çš„åæ ‡å·®ï¼Œå¹¶è®¡ç®—è¡Œåˆ—å¼å€¼ `h`:

   <img src="./assets/image-20240528193754686.png" alt="image-20240528193754686" style="zoom:50%;" />

3. å…¶ä¸­ *a*11=*vA*.*x*âˆ’*x*, *a*12=*v**A*.*y*âˆ’*y*, *a*21=*v**B*.*x*âˆ’*x*, , ç­‰ç­‰ã€‚å¦‚æœ *h* å¤§äºæˆ–ç­‰äº0ï¼Œåˆ™æ„å‘³ç€æ–°çš„é¡¶ç‚¹ä½äºç°æœ‰ä¸‰è§’å½¢å¤–æ¥åœ†å†…éƒ¨ï¼Œä¸æ»¡è¶³Delaunayæ¡ä»¶ï¼Œéœ€è¦è¿›ä¸€æ­¥å¤„ç†ã€‚

4. å¦‚æœ â„*h* çš„ç»å¯¹å€¼éå¸¸å°ï¼Œå¤„äºå®šä¹‰çš„é˜ˆå€¼ `inCircleThresholdNeg` å’Œ `inCircleThreshold` èŒƒå›´å†…ï¼Œæœ‰å¯èƒ½å‡ºç°æ•°å€¼ç²¾åº¦é—®é¢˜ã€‚æ­¤æ—¶ï¼Œè°ƒç”¨ `geoOp.inCircleQuadPrecision` ä½¿ç”¨æ›´é«˜ç²¾åº¦çš„è®¡ç®—æ¥ç¡®å®šç»“æœã€‚

5. è®°å½•æ‰©å±•ç²¾åº¦è®¡ç®—å’ŒåŸå§‹è®¡ç®—ä¹‹é—´çš„æ½œåœ¨å†²çªï¼Œä»¥ç›‘æ§ç²¾åº¦é—®é¢˜ã€‚

é€šè¿‡ä¸Šè¿°è®¡ç®—å’Œåˆ¤æ–­ï¼Œä»£ç å¯ä»¥ç¡®å®šæ˜¯å¦éœ€è¦å¯¹å½“å‰å’Œé‚»æ¥çš„ä¸‰è§’å½¢è¿›è¡Œè°ƒæ•´ï¼Œä»¥æ»¡è¶³Delaunayä¸‰è§’ç½‘çš„æ¡ä»¶ã€‚

#### 1.5ã€standerç›®å½•ä¸‹çš„StochasticLawsonsWalk.javaåˆ¤æ–­å†…æ¥åœ†

```java
public QuadEdge findAnEdgeFromEnclosingTriangle(
    final QuadEdge startingEdge,
    final double x,
    final double y) {
    Vertex v0, v1, v2;
    double vX0, vY0, vX1, vY1, vX2, vY2;// é¡¶ç‚¹åæ ‡çš„å·®å€¼
    double pX0, pY0, pX1, pY1, pX2, pY2; // è¾¹å‘é‡çš„å‚ç›´å‘é‡
    double h0, h1, h2;// å†³å®šç‚¹çš„ä½ç½®å…³ç³»çš„å¸®åŠ©å˜é‡
    QuadEdge edge = startingEdge;

    if (edge.getForward().getB() == null) {
      // it's an exterior-side edge, use its dual.
      edge = edge.getDual();
    }

    nSLW++;

    v0 = edge.getA();
    v1 = edge.getB();

    vX0 = x - v0.x;
    vY0 = y - v0.y;
    pX0 = v0.y - v1.y;  // the perpendicular
    pY0 = v1.x - v0.x;

    h0 = vX0 * pX0 + vY0 * pY0;

    nSLWTests++;
    if (h0 < this.halfPlaneThresholdNeg) {
      // transfer to opposite triangle.  The opposite triangle will
      // never be null, though it can be a ghost
      edge = edge.getDual();
      v0 = edge.getA();
    } else if (h0 < this.halfPlaneThreshold) {
      // coordinate is close to the ray on which segment t.a, t.getB() lies
      h0 = geoOp.halfPlane(v0.x, v0.y, v1.x, v1.y, x, y);
      if (h0 < 0) {
        edge = edge.getDual();
        v0 = edge.getA();
      }
    }

    while (true) {
      nSLWSteps++;
      // if the search reaches a ghost, the target coordinates
      // are exterior to the TIN.  transition to the perimeter-edge search.
      // Vertex 2 is the vertex opposite the current edge, treating
      // the current edge as an interior-oriented edge of a triangle.
      // It is important to avoid any of the testing below because
      // vertex 2 of a ghost is null and cannot be accessed.
      v1 = edge.getB();
      v2 = edge.getForward().getB();
      if (v2 == null) {
        // edge is in exterior of the TIN
        return findAssociatedPerimeterEdge(edge, x, y);
      }

      // having tested that the vertex is on the included half-plane
      // defined by the triangle's initial segment, test the other two.
      // Lawson showed that when the TIN is not an optimum
      // Delauny Triangulation the walk could fall into an infinite loop.
      // The random operation prevents that (thus the "stochastic" in the name)
      //   One of the key features of the XORSHIFT psuedo-random function
      // is that every bit in the value passes conventional tests for
      // randomness. Thus the code below determines the branch based on
      // the low-order bit value.
      long edgeSelectionForNextTest = randomNext();
      if ((edgeSelectionForNextTest & 1) == 0) {
        nSLWTests++;
        vX1 = x - v1.x;
        vY1 = y - v1.y;
        pX1 = v1.y - v2.y;  // the perpendicular, use -y for x
        pY1 = v2.x - v1.x;
        h1 = vX1 * pX1 + vY1 * pY1;
        if (h1 < halfPlaneThresholdNeg) {
          edge = edge.getForward().getDual();
          v0 = edge.getA(); // should also be v1
          // h0 = -h1;
          continue;
        } else if (h1 < halfPlaneThreshold) {
          h1 = geoOp.halfPlane(
            v1.x, v1.y, v2.x, v2.y, x, y);
          if (h1 < 0) {
            edge = edge.getForward().getDual();
            v0 = edge.getA();
            // h0 = -h1;
            continue;
          }
        }

        nSLWTests++;
        vX2 = x - v2.x;
        vY2 = y - v2.y;
        pX2 = v2.y - v0.y;  // the perpendicular, use -y for x
        pY2 = v0.x - v2.x;
        h2 = vX2 * pX2 + vY2 * pY2;
        if (h2 < halfPlaneThresholdNeg) {
          edge = edge.getReverse().getDual();
          v0 = edge.getA();
          // h0 = -h2;
          continue;
        } else if (h2 < halfPlaneThreshold) {
          h2 = geoOp.halfPlane(
            v2.x, v2.y, v0.x, v0.y, x, y);
          if (h2 < 0) {
            edge = edge.getReverse().getDual();
            v0 = edge.getA();
            // h0 = -h2;
            continue;
          }
        }
      } else {
        nSLWTests++;
        vX2 = x - v2.x;
        vY2 = y - v2.y;
        pX2 = v2.y - v0.y;  // the perpendicular, use -y for x
        pY2 = v0.x - v2.x;
        h2 = vX2 * pX2 + vY2 * pY2;
        if (h2 < halfPlaneThresholdNeg) {
          edge = edge.getReverse().getDual();
          v0 = edge.getA();
          // h0 = -h2;
          continue;
        } else if (h2 < halfPlaneThreshold) {
          h2 = geoOp.halfPlane(
            v2.x, v2.y, v0.x, v0.y, x, y);
          if (h2 < 0) {
            edge = edge.getReverse().getDual();
            v0 = edge.getA();
            // h0 = -h2;
            continue;
          }
        }

        nSLWTests++;
        vX1 = x - v1.x;
        vY1 = y - v1.y;
        pX1 = v1.y - v2.y;  // the perpendicular
        pY1 = v2.x - v1.x;
        h1 = vX1 * pX1 + vY1 * pY1;
        if (h1 < halfPlaneThresholdNeg) {
          edge = edge.getForward().getDual();
          v0 = edge.getA();
          //  h0 = -h1;
          continue;
        } else if (h1 < halfPlaneThreshold) {
          h1 = geoOp.halfPlane(
            v1.x, v1.y, v2.x, v2.y, x, y);
          if (h1 < 0) {
            edge = edge.getForward().getDual();
            v0 = edge.getA();
            // h0 = -h1;
            continue;
          }
        }
      }

      // there was no transfer, the vertex is in the triangle
      // defined by the current edge
      return edge;

    }

  }
```

è¿™ä¸ªå‡½æ•°çš„å·¥ä½œåŸç†æ˜¯ï¼š

1. **åˆå§‹åŒ–**ï¼šä»ä¸€ä¸ªèµ·å§‹è¾¹ `startingEdge` å¼€å§‹ï¼Œè¿™é€šå¸¸æ˜¯ä¸Šæ¬¡æœç´¢ç»“æŸæ—¶çš„è¾¹æˆ–è€…æŸç§å¯å‘å¼å¾—å‡ºçš„è¾¹ã€‚
2. **æ£€æµ‹å¤–å›´è¾¹**ï¼šå¦‚æœ `startingEdge` æ˜¯ä¸€ä¸ªå¤–éƒ¨è¾¹ç¼˜ï¼Œåˆ™è½¬åˆ°å®ƒçš„å¯¹å¶è¾¹ï¼Œå› ä¸ºæˆ‘ä»¬è¦ç¡®ä¿æœç´¢ä» TIN çš„å†…éƒ¨å¼€å§‹ã€‚
3. **æ­¥è¿›æœç´¢**ï¼šåœ¨ TIN ä¸­æ­¥è¿›ï¼Œæ¯æ¬¡è¿­ä»£é€‰æ‹©ä¸€ä¸ªæ–°çš„è¾¹ç¼˜è¿›è¡Œè·Ÿè¸ªã€‚
   - æ£€éªŒç‚¹ `(x, y)` æ˜¯å¦åœ¨å½“å‰ä¸‰è§’å½¢çš„è¾¹ç•Œçš„ä¸€ä¾§ã€‚è¿™é€šè¿‡è®¡ç®—ç‚¹åˆ°è¾¹çš„å‚ç›´è·ç¦»ï¼ˆæŠ•å½±ï¼‰å®Œæˆã€‚
   - å½“ `h0`, `h1` æˆ– `h2` å°äºä¸€ä¸ªè´Ÿé˜ˆå€¼ (`halfPlaneThresholdNeg`) æ—¶ï¼Œç‚¹ä½äºå½“å‰è¾¹æ‰€åœ¨ç›´çº¿çš„ä¸€ä¾§ï¼Œéœ€è¦å°†æœç´¢è½¬ç§»åˆ°å¯¹é¢çš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœ h å€¼åœ¨ä¸€ä¸ªå°çš„æ­£é˜ˆå€¼èŒƒå›´å†…ï¼Œå³æ¥è¿‘ä½†ä¸å®Œå…¨ç­‰äºé›¶ï¼Œåˆ™å¯èƒ½éœ€è¦æ›´ç²¾ç¡®çš„åŠå¹³é¢æµ‹è¯•ã€‚
4. **éšæœºæ€§**ï¼šä¸ºäº†é¿å…å¯èƒ½é™·å…¥å¾ªç¯ï¼Œä½¿ç”¨ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨æ¥å†³å®šæ¥ä¸‹æ¥æµ‹è¯•å“ªæ¡è¾¹ã€‚
5. **è¿”å›ç»“æœ**ï¼šå½“ç‚¹ `(x, y)` è½åœ¨æ‰€æœ‰ä¸‰ä¸ªè¾¹çš„å†…ä¾§æ—¶ï¼Œæˆ‘ä»¬è®¤ä¸ºæ‰¾åˆ°äº†åŒ…å«è¯¥ç‚¹çš„ä¸‰è§’å½¢ï¼Œè¿”å›å½“å‰çš„è¾¹ç¼˜ã€‚

å‡½æ•° `findAssociatedPerimeterEdge` å¯èƒ½å¤„ç†ç€å¯»æ‰¾ä¸ç‰¹å®šç‚¹ç›¸å…³è”çš„å¤–å›´è¾¹ç•Œè¾¹çš„é€»è¾‘ï¼Œé¢„ç¤ºç€ç‚¹ä½äºæ•´ä¸ª TIN å¤–éƒ¨ã€‚

è¿™ç§ç±»å‹çš„ç®—æ³•æ•ˆç‡å¾€å¾€å–å†³äºèµ·å§‹è¾¹çš„é€‰æ‹©å’Œ TIN çš„ç»“æ„ï¼Œä½†é€šå¸¸å®ƒå¯ä»¥å¿«é€Ÿæ‰¾åˆ°æ‰€éœ€çš„ä¸‰è§’å½¢ã€‚

### 2ã€addConstraints(list<>,false)

```java

// è¦†å†™ addConstraints æ–¹æ³•ï¼Œæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šä¸€ä¸ªçº¦æŸåˆ—è¡¨å’Œä¸€ä¸ªå¸ƒå°”å€¼è¡¨ç¤ºæ˜¯å¦æ¢å¤ä¸€è‡´æ€§ã€‚
@Override
public void addConstraints(
  List<IConstraint> constraints,
  boolean restoreConformity) {
  é¢„æ£€æŸ¥: é¦–å…ˆæ£€æŸ¥TINçš„å‡ ä¸ªçŠ¶æ€ï¼š

å¦‚æœTINå·²ç»è¢«é”å®š (isLocked)ï¼Œåˆ™è¿›è¡Œè¿›ä¸€æ­¥çš„æ£€æŸ¥ï¼š
å¦‚æœTINå·²ç»è¢«åºŸå¼ƒ (isDisposed)ï¼Œåˆ™æŠ›å‡ºIllegalStateExceptionã€‚
å¦‚æœTINå·²å­˜åœ¨çº¦æŸ (!constraintList.isEmpty())ï¼Œä¹ŸæŠ›å‡ºIllegalStateExceptionã€‚

  // å¦‚æœ TIN æ˜¯é”å®šçŠ¶æ€ï¼Œå°†è¿›è¡Œå‡ ç§çŠ¶æ€çš„æ£€æŸ¥ã€‚
  if (isLocked) {
    if (isDisposed) {
      // å¦‚æœå¯¹è±¡å·²ç»è¢«åºŸå¼ƒï¼Œåˆ™ä¸èƒ½å†æ·»åŠ æ–°çš„çº¦æŸã€‚
      throw new IllegalStateException(
        "Unable to add constraints after a call to dispose()");
    } else if (!constraintList.isEmpty()) {
      // å¦‚æœå·²ç»å­˜åœ¨çº¦æŸï¼Œåˆ™ä¸å…è®¸æ·»åŠ æ›´å¤šã€‚
      throw new IllegalStateException(
        "Constraints have already been added to TIN and"
        + " no further additions are supported");
    } else {
      // å¦‚æœ TIN è¢«é”å®šä¸”æ— æ³•æ·»åŠ é¡¶ç‚¹ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
      throw new IllegalStateException(
        "Unable to add vertex, TIN is locked");
    }
  }
æ£€æŸ¥è¾“å…¥: å¦‚æœä¼ å…¥çš„constraintsåˆ—è¡¨ä¸ºç©ºæˆ–è€…ä¸ºnullï¼Œåˆ™ç›´æ¥è¿”å›ä¸åšä»»ä½•æ“ä½œã€‚
  // å¦‚æœæä¾›çš„çº¦æŸä¸ºç©ºæˆ–å¤§å°ä¸ºé›¶åˆ™ç›´æ¥è¿”å›ã€‚
  if (constraints == null || constraints.isEmpty()) {
    return;
  }
æ£€æŸ¥çº¦æŸæ•°é‡: å¦‚æœçº¦æŸæ•°é‡è¶…è¿‡äº†æœ€å¤§é™åˆ¶CONSTRAINT_INDEX_MAXï¼Œåˆ™æŠ›å‡ºIllegalArgumentExceptionã€‚
  // æ£€æŸ¥çº¦æŸæ•°é‡æ˜¯å¦è¶…è¿‡äº†æœ€å¤§é™åˆ¶ã€‚
  if (constraints.size() > QuadEdgeConstants.CONSTRAINT_INDEX_MAX) {
    throw new IllegalArgumentException(
      "The maximum number of constraints is "
      + QuadEdgeConstants.CONSTRAINT_INDEX_MAX);
  }
æ·»åŠ çº¦æŸä¸­çš„é¡¶ç‚¹:

é€šè¿‡éå†æ¯ä¸ªçº¦æŸä¸­çš„æ‰€æœ‰é¡¶ç‚¹å¹¶å°†å®ƒä»¬æ·»åŠ åˆ°TINä¸­ã€‚
å¦‚æœæ£€æµ‹åˆ°å†—ä½™çš„é¡¶ç‚¹ï¼Œé‚£ä¹ˆä¼šæ‰¾åˆ°ä¸ä¹‹åŒ¹é…çš„é¡¶ç‚¹å¹¶æ›¿æ¢åŸæ¥çš„é¡¶ç‚¹åˆ—è¡¨ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„çº¦æŸå¹¶æ·»åŠ åˆ°constraintListä¸­ã€‚

  // æ­¥éª¤1: å°†çº¦æŸä¸­æ‰€æœ‰çš„é¡¶ç‚¹æ·»åŠ åˆ° TIN ä¸­ã€‚
  boolean redundantVertex = false;
  for (IConstraint c : constraints) {
    c.complete(); // å®Œæˆçº¦æŸçš„æŸäº›é¢„å¤‡å·¥ä½œã€‚
    IConstraint reference = c; // åˆ›å»ºä¸€ä¸ªå¼•ç”¨æŒ‡å‘å½“å‰çº¦æŸã€‚
    for (Vertex v : c) { // éå†çº¦æŸä¸­çš„æ¯ä¸€ä¸ªé¡¶ç‚¹ã€‚
      boolean status = add(v); // æ·»åŠ é¡¶ç‚¹åˆ° TINï¼Œå¹¶è¿”å›æ“ä½œæˆåŠŸä¸å¦çš„çŠ¶æ€ã€‚
      if (!status) {
        redundantVertex = true; // å¦‚æœæ·»åŠ å¤±è´¥ï¼Œåˆ™æ ‡è®°å­˜åœ¨å†—ä½™é¡¶ç‚¹ã€‚
      }
    }
    // å¦‚æœå­˜åœ¨å†—ä½™é¡¶ç‚¹ï¼Œåˆ™å¯¹è¿™äº›é¡¶ç‚¹åšè¿›ä¸€æ­¥å¤„ç†ã€‚
    if (redundantVertex) {
      Vertex prior = null;
      ArrayList<Vertex> replacementList = new ArrayList<Vertex>(); // åˆ›å»ºæ–°åˆ—è¡¨ä¿å­˜æ›¿æ¢åçš„é¡¶ç‚¹ã€‚
      for (Vertex v : c) {
        Vertex m = this.getMatchingVertex(v); // è·å–åŒ¹é…çš„é¡¶ç‚¹ã€‚
        if (m == v) {
          replacementList.add(v);
          prior = v;
        } else {
          if (m == prior) {
            continue;
          }
          replacementList.add(m);
          prior = m;
        }
      }
      // é€šè¿‡æ›¿æ¢åˆ—è¡¨ç”Ÿæˆä¸€ä¸ªæ–°çš„æœ‰ç€æ–°å‡ ä½•çš„çº¦æŸã€‚
      reference = c.getConstraintWithNewGeometry(replacementList);
    }
      
    constraintList.add(reference); // å°†å¤„ç†å®Œæˆçš„çº¦æŸæ·»åŠ åˆ°åˆ—è¡¨ä¸­ã€‚
  }
æ„é€ çº¦æŸè¾¹ç¼˜:

é”å®šTIN (isLocked = true)ï¼Œé˜²æ­¢è¿›ä¸€æ­¥çš„ä¿®æ”¹ã€‚
éå†æ¯ä¸ªçº¦æŸï¼Œå¹¶ä¸ºæ¯ä¸ªçº¦æŸåˆ›å»ºå’Œæ ‡è®°æ–°çš„è¾¹ç¼˜ã€‚å°†è¿™äº›è¾¹ç¼˜å­˜å‚¨åœ¨efcListä¸­ç”¨äºåç»­å¤„ç†ã€‚
  // æ­¥éª¤2: æ„é€ æ–°çš„è¾¹ç¼˜ä»¥ç¬¦åˆçº¦æŸï¼Œå¹¶æ ‡è®°ä»»ä½•ç°æœ‰çš„è¾¹ç¼˜ã€‚
  ArrayList<ArrayList<IQuadEdge>> efcList = new ArrayList<>(); // å­˜å‚¨æ¯ä¸ªçº¦æŸçš„è¾¹ç¼˜åˆ—è¡¨ã€‚

  isLocked = true; // é”å®š TINï¼Œé˜²æ­¢è¿›ä¸€æ­¥çš„ä¿®æ”¹ã€‚
  int k = 0;
  for (IConstraint c : constraintList) {
    c.setConstraintIndex(this, k); // ä¸ºæ¯ä¸ªçº¦æŸè®¾ç½®ç´¢å¼•ã€‚
    ArrayList<IQuadEdge> edgesForConstraint = new ArrayList<>(); // åˆ›å»ºå½“å‰çº¦æŸçš„è¾¹ç¼˜åˆ—è¡¨ã€‚
    efcList.add(edgesForConstraint); // æ·»åŠ åˆ°ä¸»åˆ—è¡¨ä¸­ã€‚
    processConstraint(c, edgesForConstraint); // å¤„ç†çº¦æŸï¼Œå¯èƒ½æ¶‰åŠåˆ›å»ºæ–°è¾¹ç¼˜æˆ–è°ƒæ•´ç°æœ‰è¾¹ç¼˜ã€‚
    edgesForConstraint.trimToSize(); // ä¼˜åŒ–åˆ—è¡¨å­˜å‚¨ã€‚
    k++;
  }

  // å¦‚æœéœ€è¦æ¢å¤ä¸€è‡´æ€§ï¼Œåˆ™æ‰§è¡Œç›¸å…³æ“ä½œ(æ²¡å¿…è¦)ã€‚
/*  if (restoreConformity) {
    List<IQuadEdge> eList = edgePool.getEdges(); // è·å–æ‰€æœ‰è¾¹ç¼˜ã€‚
    for (IQuadEdge e : eList) {
      if (e.isConstrained()) {
        restoreConformity((QuadEdge) e, 1); // å¯¹å—çº¦æŸçš„è¾¹ç¼˜æ‰§è¡Œæ¢å¤ä¸€è‡´æ€§çš„æ“ä½œã€‚
      }
    }
  }
*/
å¡«å……å—çº¦æŸåŒºåŸŸ:
ä½¿ç”¨BitSetè·Ÿè¸ªè®¿é—®è¿‡çš„è¾¹ç¼˜ã€‚
å¯¹äºæ¯ä¸ªå®šä¹‰äº†å—çº¦æŸåŒºåŸŸçš„çº¦æŸï¼Œä½¿ç”¨æ´ªæ°´å¡«å……ç®—æ³•ï¼ˆflood fill algorithmï¼‰æ¥å¡«å……åŒºåŸŸï¼Œå¹¶è®¾ç½®é“¾æ¥è¾¹ã€‚

åœ¨addConstraintsæ–¹æ³•ä¸­ï¼Œå¡«å……å—çº¦æŸåŒºåŸŸå¯èƒ½æ¶‰åŠçš„å…·ä½“æ“ä½œåŒ…æ‹¬ï¼š
æ ‡è®°è¾¹ç¼˜: å°†å±äºçº¦æŸåŒºåŸŸçš„è¾¹ç¼˜æ ‡è®°å‡ºæ¥ï¼Œä½¿å¾—å®ƒä»¬åœ¨åç»­å¤„ç†ä¸­èƒ½å¤Ÿè¢«è¯†åˆ«å’Œç‰¹æ®Šå¤„ç†ã€‚
æ´ªæ°´å¡«å……ï¼ˆFlood Fillï¼‰: è¿™æ˜¯ä¸€ç§ç®—æ³•ï¼Œç”¨äºç¡®å®šå“ªäº›ä¸‰è§’å½¢å±äºå—çº¦æŸçš„åŒºåŸŸï¼Œç±»ä¼¼äºåœ¨å›¾åƒå¤„ç†ä¸­å¡«å……é¢œè‰²ã€‚åœ¨TINä¸­ï¼Œè¿™å¯èƒ½æ„å‘³ç€ä»ä¸€ä¸ªå·²çŸ¥çš„è¾¹ç•Œè¾¹å¼€å§‹ï¼Œé€æ­¥æ ‡è®°æ‰€æœ‰ä¸è¯¥çº¦æŸç›¸è¿çš„ä¸‰è§’å½¢ï¼Œç›´è‡³è¾¾åˆ°å…¶ä»–çº¦æŸæˆ–TINçš„è¾¹ç•Œã€‚

ç»´æŠ¤å…³è”: å¯¹äºæ¯ä¸ªçº¦æŸåŒºåŸŸï¼Œå­˜å‚¨ç›¸å…³çš„æ•°æ®å¦‚è¾¹ç¼˜é›†åˆï¼Œä»¥ä¾¿å¯ä»¥å¿«é€Ÿè®¿é—®å’Œå¤„ç†å—çº¦æŸçš„åŒºåŸŸã€‚
  // å¯¹äºå®šä¹‰äº†å—çº¦æŸåŒºåŸŸçš„çº¦æŸï¼Œè¿›è¡Œæ´ªæ°´å¡«å……ç®—æ³•å¤„ç†ã€‚
  int maxIndex = getMaximumEdgeAllocationIndex();
  BitSet visited = new BitSet(maxIndex + 1);
  for (int i = 0; i < constraintList.size(); i++) {
    IConstraint c = constraintList.get(i);
    if (c.definesConstrainedRegion()) {
      ArrayList<IQuadEdge> edgesForConstraint = efcList.get(i); // è·å–å½“å‰çº¦æŸçš„è¾¹ç¼˜åˆ—è¡¨ã€‚
      floodFillConstrainedRegion(c, edgesForConstraint, visited); // æ‰§è¡Œæ´ªæ°´å¡«å……ã€‚
      c.setConstraintLinkingEdge(edgesForConstraint.get(0)); // è®¾ç½®çº¦æŸçš„é“¾æ¥è¾¹ã€‚
    }
  }
}

```

ç®€å•æ¦‚æ‹¬ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä½œç”¨æ˜¯åœ¨ä¸€ä¸ªé”å®šçš„çŠ¶æ€ä¸‹ï¼Œå°†ä¸€ç³»åˆ—çš„çº¦æŸæ·»åŠ åˆ°ä¸€ä¸ª TIN ç»“æ„ä¸­ã€‚è¿™æ¶‰åŠåˆ°æ·»åŠ æ–°çš„é¡¶ç‚¹å’Œè¾¹ç¼˜ï¼Œå¹¶å¯èƒ½æ¶‰åŠåˆ°åˆ é™¤ç°æœ‰çš„é‡å¤é¡¶ç‚¹ã€‚è¿™ä¸ªæ–¹æ³•æ‰§è¡Œäº†ä»¥ä¸‹å…³é”®ä»»åŠ¡ï¼š

- æ£€æŸ¥ TIN æ˜¯å¦å¤„äºå¯ä»¥æ·»åŠ çº¦æŸçš„çŠ¶æ€ï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™æŠ›å‡ºç›¸åº”çš„å¼‚å¸¸ã€‚
- å¿½ç•¥ç©ºçš„æˆ–è€… `null` çš„çº¦æŸé›†åˆã€‚
- ç¡®è®¤çº¦æŸæ•°é‡ä¸è¶…è¿‡æœ€å¤§é™åº¦ã€‚
- æ·»åŠ çº¦æŸé›†åˆä¸­çš„æ‰€æœ‰é¡¶ç‚¹åˆ° TIN ä¸­ï¼Œå¹¶å¤„ç†å†—ä½™é¡¶ç‚¹ã€‚
- æ ‡è®°ç°æœ‰è¾¹ç¼˜å¹¶æ ¹æ®çº¦æŸæ„å»ºæ–°çš„è¾¹ç¼˜ã€‚
- å¦‚æœéœ€è¦ï¼Œé€šè¿‡æ‰§è¡Œæ¢å¤ä¸€è‡´æ€§çš„ç®—æ³•æ¥ç¡®ä¿ TIN ç¬¦åˆç‰¹å®šè§„åˆ™ã€‚
- å¯¹é‚£äº›å®šä¹‰äº†å—çº¦æŸåŒºåŸŸçš„çº¦æŸä½¿ç”¨æ´ªæ°´å¡«å……ç®—æ³•è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ã€‚

æ•´ä½“ä¸Šï¼Œè¿™æ®µä»£ç æ˜¯ä¸ºäº†ç¡®ä¿åœ¨æ„å»ºæˆ–ä¿®æ”¹ TIN æ—¶ï¼Œèƒ½å¤Ÿæ­£ç¡®åœ°éµå¾ªä¸€ç³»åˆ—å‡ ä½•å­¦ä¸Šçš„çº¦æŸã€‚



**æ´ªæ°´å¡«å……ç®—æ³•**ï¼ˆFlood Fill Algorithmï¼‰é€šå¸¸ç”¨äºè®¡ç®—å›¾å½¢ä¸­çš„è¿é€šåŒºåŸŸï¼Œå®ƒå¯ä»¥å¡«å……å…·æœ‰ç›¸åŒç‰¹å¾æˆ–æ ‡è¯†ç¬¦çš„é‚»è¿‘åŒºåŸŸã€‚åœ¨å›¾åƒå¤„ç†ã€åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ã€æ¸¸æˆå¼€å‘ç­‰é¢†åŸŸï¼Œè¿™ä¸ªç®—æ³•è¢«å¹¿æ³›ä½¿ç”¨ã€‚

åœ¨ä¸‰è§’ç½‘ï¼ˆTINï¼‰å’Œå…¶ä»–åœ°ç†æ•°æ®ç»“æ„ä¸­ï¼Œæ´ªæ°´å¡«å……ç®—æ³•å¯èƒ½è¢«ç”¨äºä»¥ä¸‹ç›®çš„ï¼š

1. **æ ‡è®°å—çº¦æŸåŒºåŸŸ**ï¼šå¦‚æœä¸€ä¸ªåŒºåŸŸç”±ä¸€ç³»åˆ—è¾¹ç•Œæˆ–çº¦æŸæ‰€å›´ç»•ï¼Œæ´ªæ°´å¡«å……å¯ä»¥å¸®åŠ©è¯†åˆ«å¹¶æ ‡è®°é‚£äº›è¢«è¿™äº›è¾¹ç•Œé™å®šçš„å†…éƒ¨åŒºåŸŸã€‚ä¾‹å¦‚ï¼Œåœ¨å»ºç«‹æ°´æ–‡æ¨¡å‹æ—¶ç¡®å®šæµåŸŸè¾¹ç•Œå†…çš„åŒºåŸŸã€‚
2. **åº”ç”¨å±æ€§æˆ–åˆ†ç±»**ï¼šä¸€æ—¦ç¡®å®šäº†ä¸€ä¸ªåŒºåŸŸï¼Œå¯ä»¥å°†ç‰¹å®šçš„å±æ€§æˆ–åˆ†ç±»åº”ç”¨åˆ°è¿™ä¸ªåŒºåŸŸå†…çš„æ‰€æœ‰å…ƒç´ ä¸Šã€‚æ¯”å¦‚ï¼Œåœ¨åœ°å›¾ä¸Šå¡«å……å›½å®¶çš„è¾¹ç•Œï¼Œä»è€Œä¸ºå›½å®¶å†…éƒ¨çš„æ‰€æœ‰ç‚¹æ ‡æ³¨ç›¸åŒçš„å›½ç±å±æ€§ã€‚
3. **è®¡ç®—åŒºåŸŸæ€§è´¨**ï¼šæ ¹æ®æ ‡è®°çš„åŒºåŸŸï¼Œå¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥åˆ†æï¼Œå¦‚è®¡ç®—é¢ç§¯ã€å‘¨é•¿ã€æˆ–è€…ä¸åŒºåŸŸç›¸å…³çš„å…¶ä»–ç»Ÿè®¡æ•°æ®ã€‚

åœ¨ä»£ç ç‰‡æ®µä¸­ï¼Œ`floodFillConstrainedRegion` æ–¹æ³•ä¼¼ä¹æ˜¯ç”¨æ¥å¤„ç† TIN ä¸­å› æ–°æ·»åŠ çš„çº¦æŸè€Œäº§ç”Ÿçš„å—é™åŒºåŸŸï¼Œå¹¶ä¸”æ ‡è®°å‡ºè¿™äº›åŒºåŸŸçš„è¾¹ç¼˜ã€‚æ¯ä¸ªè¢«çº¦æŸçš„è¿é€šåŒºåŸŸéƒ½ç”±ä¸€ç»„å››è¾¹å½¢è¾¹ï¼ˆIQuadEdgeï¼‰è¡¨ç¤ºï¼Œæ´ªæ°´å¡«å……ç®—æ³•ä¼šéå†è¿™äº›è¾¹å¹¶æ ‡è®°æ•´ä¸ªè¿é€šåŒºåŸŸã€‚è¿™å¯èƒ½æ¶‰åŠæ£€æŸ¥é‚»è¿‘çš„ä¸‰è§’å½¢æ˜¯å¦å±äºåŒä¸€çº¦æŸåŒºåŸŸï¼Œå¹¶ç›¸åº”åœ°æ›´æ–°å…¶çŠ¶æ€æˆ–å±æ€§ã€‚

æ´ªæ°´å¡«å……ç®—æ³•çš„ä¸€ç§ç®€å•å½¢å¼ç±»ä¼¼äºå›¾åƒç¼–è¾‘è½¯ä»¶ä¸­çš„â€œæ²¹æ¼†æ¡¶â€å·¥å…·ï¼Œå®ƒä»ä¸€ä¸ªèµ·ç‚¹å¼€å§‹å‘å¤–æ‰©æ•£ï¼Œç›´åˆ°è¾¾åˆ°éç›®æ ‡åŒºåŸŸçš„è¾¹ç•Œã€‚åœ¨ç®—æ³•çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œé€šå¸¸éœ€è¦è·Ÿè¸ªå·²è®¿é—®çš„å…ƒç´ ä»¥é¿å…é‡å¤å¤„ç†ï¼Œè¿™å¯ä»¥é€šè¿‡é˜Ÿåˆ—ã€æ ˆæˆ–å…¶ä»–æ•°æ®ç»“æ„æ¥å®ç°ã€‚åœ¨GISæˆ–ä¸‰è§’æµ‹é‡ç½‘ç»œåˆ†æä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹æ›´åŠ å¤æ‚ï¼Œå› ä¸ºéœ€è¦è€ƒè™‘åœ°å½¢çš„ç‰¹æ®Šç»“æ„å’Œç©ºé—´å…³ç³»ã€‚

![image-20231225100722165](./assets/image-20231225100722165.png)

#### æ´ªæ°´å¡«å……ç®—æ³•

```java
// å¯¹äºå®šä¹‰äº†å—çº¦æŸåŒºåŸŸçš„çº¦æŸï¼Œè¿›è¡Œæ´ªæ°´å¡«å……ç®—æ³•å¤„ç†ã€‚
  int maxIndex = getMaximumEdgeAllocationIndex();
  BitSet visited = new BitSet(maxIndex + 1);
  for (int i = 0; i < constraintList.size(); i++) {
    IConstraint c = constraintList.get(i);
    if (c.definesConstrainedRegion()) {
      ArrayList<IQuadEdge> edgesForConstraint = efcList.get(i); // è·å–å½“å‰çº¦æŸçš„è¾¹ç¼˜åˆ—è¡¨ã€‚
      floodFillConstrainedRegion(c, edgesForConstraint, visited); // æ‰§è¡Œæ´ªæ°´å¡«å……ã€‚
      c.setConstraintLinkingEdge(edgesForConstraint.get(0)); // è®¾ç½®çº¦æŸçš„é“¾æ¥è¾¹ã€‚
    }
  }
  
/**
*å°†å—çº¦æŸåŒºåŸŸå†…çš„æ‰€æœ‰è¾¹æ ‡è®°ä¸ºè¯¥åŒºåŸŸçš„æˆå‘˜ï¼ˆå°†çº¦æŸçš„ç´¢å¼•å€¼ä¼ é€’åˆ°æˆå‘˜è¾¹ï¼‰
ã€‚è¿™ç§æ–¹æ³•çš„åç§°æ˜¯åŸºäºè¿™æ ·ä¸€ç§æƒ³æ³•ï¼Œå³è¯¥æ“ä½œç±»ä¼¼äºè®¡ç®—æœºå›¾å½¢å­¦ä¸­çš„æ´ªæ°´å¡«å……ç®—æ³•ã€‚
*
*@param c ç»™å‡ºæ´ªæ°´å¡«å……åŒºåŸŸçš„çº¦æŸ
*@param edge åˆ—å‡ºä¸å—çº¦æŸåŒºåŸŸçš„è¾¹ç•Œç›¸å¯¹åº”çš„è¾¹çš„åˆ—è¡¨
*/

private void floodFillConstrainedRegion(
    final IConstraint c,
    final ArrayList<IQuadEdge> edgeList,
    final BitSet visited) {

    int constraintIndex = c.getConstraintIndex();
    for (IQuadEdge e : edgeList) {
      if (e.isConstrainedRegionBorder()) {
        floodFillConstrainedRegionsQueue(constraintIndex, visited, e);
      }
    }
  }

private void floodFillConstrainedRegionsQueue(
    final int constraintIndex,
    final BitSet visited,
    final IQuadEdge firstEdge) {
//è™½ç„¶ä½¿ç”¨é€’å½’å¯ä»¥æ›´ä¼˜é›…åœ°ç¼–ç ä»¥ä¸‹é€»è¾‘ï¼Œä½†é€’å½’çš„æ·±åº¦å¯èƒ½ä¼šå˜å¾—å¦‚æ­¤ä¹‹æ·±ï¼Œä»¥è‡³äºå®ƒä¼šæº¢å‡ºä»»ä½•åˆç†å¤§å°çš„å †æ ˆã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨æ˜¾å¼ç¼–ç å †æ ˆã€‚
//å¯¹äºæ´ªæ°´å¡«å……åŒºå†…å‡ºç°æ›¿ä»£çº¦æŸçš„æƒ…å†µï¼Œè¿™é‡Œæœ‰ç‰¹æ®Šçš„é€»è¾‘ã€‚ä¾‹å¦‚ï¼Œçº¿æ€§çº¦æŸå¯èƒ½å‘ç”Ÿåœ¨å¤šè¾¹å½¢å†…éƒ¨ï¼ˆé“è·¯å¯èƒ½ç©¿è¿‡åŸé•‡ï¼‰ã€‚
//è¯¥é€»è¾‘éœ€è¦ä»æ›¿æ¢çº¦æŸä¸­ä¿ç•™æ‰€åŒ…å«è¾¹çš„çº¦æŸç´¢å¼•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•´ä½“å¡«å……ä¼šç»è¿‡åµŒå…¥çš„è¾¹ï¼Œä½†ä¸ä¼šå¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚
    ArrayDeque<IQuadEdge> deque = new ArrayDeque<>();
    deque.push(firstEdge);
    while (!deque.isEmpty()) {
      if (deque.size() > maxLengthOfQueueInFloodFill) {
        maxLengthOfQueueInFloodFill = deque.size();
      }
      IQuadEdge e = deque.peek();
      IQuadEdge f = e.getForward();
      int fIndex = f.getIndex();
      if (!f.isConstrainedRegionBorder() && !visited.get(fIndex)) {
        visited.set(fIndex);
        f.setConstrainedRegionInteriorFlag();
        f.setConstraintIndex(constraintIndex);
        deque.push(f.getDual());
        continue;
      }
      IQuadEdge r = e.getReverse();
      int rIndex = r.getIndex();
      if (!r.isConstrainedRegionBorder() && !visited.get(rIndex)) {
        visited.set(rIndex);
        r.setConstrainedRegionInteriorFlag();
        r.setConstraintIndex(constraintIndex);
        deque.push(r.getDual());
        continue;
      }
      deque.pop();
    }
  }


```

"æ´ªæ°´å¡«å……ç®—æ³•"ç”¨æ¥æ ‡è®°é€šè¿‡çº¿æ€§çº¦æŸå®šä¹‰çš„å—é™åŒºåŸŸã€‚

å®ƒåœ¨ä¸€ä¸ªä¸‰è§’ç½‘æ ¼ç»“æ„ä¸­å·¥ä½œï¼Œè¯¥ç»“æ„ç”±ç§°ä¸º`IQuadEdge`çš„è¾¹ç»„æˆã€‚

ä»¥ä¸‹æ˜¯è¿™æ®µä»£ç çš„å¤§è‡´é€»è¾‘ï¼š

1. **è·å–æœ€å¤§ç´¢å¼•**:
   - `maxIndex`å˜é‡æ˜¯é€šè¿‡è°ƒç”¨`getMaximumEdgeAllocationIndex()`å‡½æ•°è·å¾—çš„ï¼Œå®ƒå¯èƒ½ä»£è¡¨äº†æ‰€æœ‰è¾¹å¯¹è±¡ä¸­æœ€å¤§çš„ç´¢å¼•å€¼ã€‚
   
2. **åˆå§‹åŒ–è®¿é—®è®°å½•**:

   - ä¸€ä¸ª`BitSet`åä¸º`visited`è¢«åˆå§‹åŒ–ï¼Œå…¶å¤§å°è®¾ç½®ä¸º`maxIndex + 1`ï¼Œç”¨ä»¥è®°å½•æ¯æ¡è¾¹åœ¨æ´ªæ°´å¡«å……è¿‡ç¨‹ä¸­æ˜¯å¦å·²ç»è®¿é—®è¿‡ã€‚

3. **éå†çº¦æŸ**:

   - ä»£ç éå†ä¸€ä¸ªåä¸º`constraintList`çš„åˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨å¯èƒ½åŒ…å«äº†å¤šä¸ªå®šä¹‰äº†å—é™åŒºåŸŸçš„`IConstraint`å¯¹è±¡ã€‚

   - å¯¹äºæ¯ä¸€ä¸ªIConstraintå¯¹è±¡ï¼Œå¦‚æœå®ƒç¡®å®å®šä¹‰äº†ä¸€ä¸ªå—é™åŒºåŸŸ(definesConstrainedRegion()è¿”å›true)ï¼Œåˆ™ï¼š

     - ä»`efcList`ï¼ˆä¸€ä¸ªä¸`constraintList`å¯¹åº”çš„è¾¹åˆ—è¡¨æ•°ç»„ï¼‰ä¸­è·å–ä¸æ­¤çº¦æŸç›¸å…³è”çš„è¾¹åˆ—è¡¨ã€‚
     - ä½¿ç”¨`floodFillConstrainedRegion`æ–¹æ³•å¯¹å—é™åŒºåŸŸè¿›è¡Œæ´ªæ°´å¡«å……æ“ä½œï¼Œä¼ å…¥å½“å‰çº¦æŸã€ç›¸å…³çš„è¾¹åˆ—è¡¨ä»¥åŠ`visited`è®°å½•ã€‚
     - å°†çº¦æŸå…³è”åˆ°å…¶è¾¹ç•Œçš„ç¬¬ä¸€æ¡è¾¹ï¼ˆç”¨ä½œé“¾æ¥æˆ–å‚è€ƒç‚¹ï¼‰ã€‚

4. **æ´ªæ°´å¡«å……å—é™åŒºåŸŸ**:

   - `floodFillConstrainedRegion`æ–¹æ³•æ¥æ”¶ä¸€ä¸ªçº¦æŸå¯¹è±¡`c`ã€ä¸€ä¸ªè¾¹åˆ—è¡¨`edgeList`å’Œ`visited`è®°å½•ã€‚
   - å¯¹äºè¾¹åˆ—è¡¨ä¸­çš„æ¯æ¡è¾¹ï¼Œå¦‚æœè¯¥è¾¹æ˜¯å—é™åŒºåŸŸçš„è¾¹ç•Œï¼Œè°ƒç”¨`floodFillConstrainedRegionsQueue`æ–¹æ³•è¿›è¡Œå®é™…çš„æ´ªæ°´å¡«å……æ“ä½œã€‚

5. **é˜Ÿåˆ—ç®¡ç†çš„æ´ªæ°´å¡«å……**:

   - `floodFillConstrainedRegionsQueue`æ–¹æ³•ä½¿ç”¨æ˜¾å¼å †æ ˆï¼ˆè¿™é‡Œæ˜¯`ArrayDeque`ç±»å‹çš„`deque`ï¼‰æ¥æ¨¡æ‹Ÿé€’å½’ï¼Œå› ä¸ºçœŸæ­£çš„é€’å½’å¯èƒ½ä¼šæ¶ˆè€—å¤ªå¤šçš„å †æ ˆç©ºé—´å¯¼è‡´æº¢å‡ºã€‚
   - ç®—æ³•å¼€å§‹æ—¶å°†ç¬¬ä¸€æ¡è¾¹æ¨å…¥å †æ ˆã€‚
   - ç„¶å while å¾ªç¯ä¿æŒè¿è¡Œï¼Œç›´åˆ°å †æ ˆä¸ºç©ºï¼Œä¾æ¬¡è¿›è¡Œä»¥ä¸‹æ£€æŸ¥å’Œæ“ä½œï¼š
     - æ£€æŸ¥å½“å‰å †æ ˆé•¿åº¦æ˜¯å¦è¶…è¿‡è®°å½•çš„`maxLengthOfQueueInFloodFill`ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™æ›´æ–°è¯¥è®°å½•ã€‚
     - æŸ¥çœ‹å †æ ˆé¡¶éƒ¨çš„è¾¹ï¼Œä½†ä¸ç§»é™¤å®ƒï¼ˆ`peek`æ“ä½œï¼‰ã€‚
     - è·å–å¹¶æ£€æŸ¥å½“å‰è¾¹çš„â€œå‰è¿›â€è¾¹å’Œâ€œåå‘â€è¾¹ï¼Œä»¥ç¡®å®šæ˜¯å¦éœ€è¦ç»§ç»­å¡«å……ã€‚
     - å¦‚æœæŸæ¡è¾¹ä¸æ˜¯å—é™åŒºåŸŸçš„è¾¹ç•Œä¸”æœªè®¿é—®è¿‡ï¼Œå°†å…¶æ ‡è®°ä¸ºå·²è®¿é—®ï¼Œè®¾ç½®ä¸ºå—é™åŒºåŸŸå†…éƒ¨ï¼Œæ›´æ–°å…¶çº¦æŸç´¢å¼•ï¼Œå¹¶å°†å…¶å¯¹å¶è¾¹æ¨å…¥å †æ ˆã€‚
     - å¦‚æœæ²¡æœ‰æ–°è¾¹è¦å¤„ç†ï¼Œä»å †æ ˆä¸­å¼¹å‡ºå½“å‰è¾¹ï¼ˆ`pop`æ“ä½œï¼‰ã€‚

é€šè¿‡ä¸Šè¿°ç®—æ³•ï¼Œæ‚¨å¯ä»¥**å°†ä¸ç‰¹å®šçº¦æŸç›¸å…³è”çš„è¾¹é›†åˆå†…éƒ¨çš„æ‰€æœ‰è¾¹éƒ½æ ‡è®°ä¸ºè¯¥çº¦æŸçš„ä¸€éƒ¨åˆ†**ï¼ŒåŒæ—¶ç¡®ä¿ä¸ä¼šæº¢å‡ºç¨‹åºçš„è°ƒç”¨å †æ ˆï¼Œå¹¶èƒ½æ­£ç¡®å¤„ç†åµŒå¥—çš„å—é™åŒºåŸŸã€‚

#### 2.1ã€processConstraint(


    IConstraint constraint,
    ArrayList< IQuadEdge> edgesForConstraint) 

```java
private void processConstraint(
    IConstraint constraint,
    ArrayList<IQuadEdge> edgesForConstraint) {
    List<Vertex> cvList = new ArrayList<>();
    cvList.addAll(constraint.getVertices());
    if (constraint.isPolygon()) {
      // close the loop
      cvList.add(cvList.get(0));
    }
    int nSegments = cvList.size() - 1;

    double vTolerence = thresholds.getVertexTolerance();
    Vertex v0 = cvList.get(0);
    double x0 = v0.getX();
    double y0 = v0.getY();

    if (searchEdge == null) {
      searchEdge = edgePool.getStartingEdge();
    }
    searchEdge = walker.findAnEdgeFromEnclosingTriangle(searchEdge, x0, y0);
    QuadEdge e0 = null;
    if (isMatchingVertex(v0, searchEdge.getA())) {
      e0 = searchEdge;
    } else if (isMatchingVertex(v0, searchEdge.getB())) {
      e0 = searchEdge.getDual();
    } else { //if (isMatchingVertex(v0, searchEdge.getReverse().getA())) {
      e0 = searchEdge.getReverse();
    }
    Vertex a = e0.getA();
    if (a != v0 && a instanceof VertexMergerGroup) {
      VertexMergerGroup g = (VertexMergerGroup) a;
      if (g.contains(v0)) {
        cvList.set(0, a);
      }
    }

    // because this method may change the TIN, we cannot assume
    // that the current search edge will remain valid.
    searchEdge = null;

    double x1, y1, ux, uy, u, px, py;
    double ax, ay, ah, bx, by, bh;
    Vertex v1, b;
    segmentLoop:
    for (int iSegment = 0; iSegment < nSegments; iSegment++) {
      // e0 is now an edge which has v0 as it's initial vertex.
      // the special case where one of the edges connecting to e0
      // is the edge (v0,v1) benefits from special handling to avoid
      // potential numerical issues... especially in the case where
      // the constraint includes 3 nearly colinear edges in a row.
      // So the code below performs a pinwheel operation to test for that case.
      //   The code also checks to see if the pinwheel will move out
      // of the boundaries of the TIN (when e.getB() returns a null).
      // In that case, one of the edges in the pinwheel is the re-entry edge.
      // we assign e0 to be the re-entry edge.  This only happens when the
      // constraint edge(v0,v1) is not located within the boundary of the TIN,
      // so often the variable reEntry will stay set to null.
      v0 = cvList.get(iSegment);
      v1 = cvList.get(iSegment + 1);
      QuadEdge e = e0;
      {
        boolean priorNull = false;
        QuadEdge reEntry = null;
        do {
          b = e.getB();
          if (b == null) {
            // ghost vertex
            priorNull = true;
          } else {
            if (b == v1) {
              setConstrained(e, constraint, edgesForConstraint);
              e0 = e.getDual(); // set up e0 for next iteration of iSegment
              continue segmentLoop;
            } else if (b instanceof VertexMergerGroup) {
              VertexMergerGroup g = (VertexMergerGroup) b;
              if (g.contains(v1)) {
                cvList.set(iSegment + 1, g);
                setConstrained(e, constraint, edgesForConstraint);
                e0 = e.getDual(); // set up e0 for next iteration of iSegment
                continue segmentLoop;
              }
            }
            if (priorNull) {
              reEntry = e;
            }
            priorNull = false;
          }
          e = e.getDualFromReverse();
        } while (!e.equals(e0));

        if (reEntry != null) {
          e0 = reEntry;
        }
        // if reEntry is null and priorNull is true, then
        // the last edge we tested the B value for was null.
        // this would have been the edge right before e0, which
        // means that e0 is the reEntry edge.
      }

      // pinwheel to find the right-side edge of a triangle
      // which overlaps the constraint segment.  The segment may be entirely
      // contained in this triangle, or may intersect the edge opposite v0.
      x0 = v0.getX();
      y0 = v0.getY();
      x1 = v1.getX();
      y1 = v1.getY();
      ux = x1 - x0;
      uy = y1 - y0;
      u = Math.sqrt(ux * ux + uy * uy);
      // TO DO: test for vector too small
      ux /= u; // unit vector
      uy /= u;
      px = -uy;  // perpendicular
      py = ux;

      // The search should now be positioned on v0.  We've already verified
      // that v0 does not connect directly to v1, so we need to find
      // the next vertex affected by the constraint.
      //    There is also the case where the one of the connecting edges is colinear
      // (or nearly colinear) with the constraint segment. If we find a
      // vertext that is sufficiently close to the constraint segment,
      // we insert the vertex into the constraint (making a new segment)
      // and continue on to the newly formed segment.
      QuadEdge h = null;
      QuadEdge right0 = null;
      QuadEdge left0 = null;
      QuadEdge right1 = null;
      QuadEdge left1 = null;

      // begin the pre-loop initialization.  The search below performs a pinwheel
      // through the edge that start with v0, looking for a case where the
      // edge opposite v0 straddles the constraint segment.  We call the
      // candidate edges n where n=edge(a,b).  As we loop, the b from one
      // test is the same as the a for the next test. So we copy values
      // from b into a at the beginning of the loop.  To support that, we
      // pre-initialize b before enterring the loop.  This pre-initialization
      // must also include the side-of-edge calculation, bh, which is the
      // coordinate of (bx,by) in the direction of the perpendicular.
      //    The pre-test must also test for the case where the first edge
      // in the pinwheel lies on or very close to the ray(v0, v1).
      // The logic is similar to that inside the loop, except that a
      // simple dot product is sufficient to determine if the vertex is
      // in front of, or behind, the ray (see the comments in the loop for
      // more explanation.
      b = e0.getB();
      bx = b.getX() - x0;
      by = b.getY() - y0;
      bh = bx * px + by * py;
      if (Math.abs(bh) <= vTolerence && bx * ux + by * uy > 0) {
        // edge e0 is either colinear or nearly colinear with
        // ray(v0,v1). insert it into the constraint, set up e0 for the
        // next segment, and advance to the next segment in the constraint.
        cvList.add(iSegment + 1, b);
        nSegments++;
        setConstrained(e0, constraint, edgesForConstraint);
        e0 = e0.getDual(); // set up e0 for next iteration of iSegment
        continue; // continue segmentLoop;
      }

      // perform a pinwheel, testing each sector to see if
      // it contains the constraint segment.
      e = e0;
      do {
        // copy calculated values from b to a.
        ax = bx;
        ay = by;
        ah = bh;
        QuadEdge n = e.getForward(); //the edge opposite v0

        // TO DO: the following code is commented out because it should
        // no longer be necessary.  The test for the reEntry edge above
        // should have positioned e0 so that the pinwheel will find the
        // straddle point before it reaches the ghost edge.  The only case
        // where this code would fail (and b would be null) would be when
        // something we haven't anticipated happens and the straddle isn't found.
        //   // be wary of the ghost vertex case
        //   b = n.getB();
        //   if (b == null) {
        //      // TO DO: does this actually happen anymore now that
        //      // the reEntry logic was added above?
        //      bh = Double.NaN;
        //      e = e.getDualFromReverse();
        //      continue;
        //   }
        b = n.getB();
        bx = b.getX() - x0;
        by = b.getY() - y0;
        bh = bx * px + by * py;
        if (Math.abs(bh) <= vTolerence) {
          // the edge e is either colinear or nearly colinear with the
          // line through vertices v0 and v1.  We need to see if the
          // straddle point lies on or near the ray(v0,v1).
          // this is complicated slightly by the fact that some points
          // on the edge n could be in front of v0 (a positive direction
          // on the ray) while others could be behind it.  So there's
          // no way around it, we have to compute the intersection.
          // Of course, we don't need to compute the actual points (x,y)
          // of the intersection, just the parameter t from the parametric
          // equation of a line. If t is negative, the intersection is
          // behind the ray. If t is positive, the intersection is in front
          // of the ray.  If t is zero, the TIN insertion algorithm failed and
          // we have an implementation problem elsewhere in the code.
          double dx = bx - ax;
          double dy = by - ay;
          double t = (ax * dy - ay * dx) / (ux * dy - uy * dx);
          if (t > 0) {
            // edge e is either colinear or nearly colinear with
            // ray(v0,v1). insert it into the constraint, set up e0 for
            // the next loop, and then advance to the next constraint segment.
            cvList.add(iSegment + 1, b);
            nSegments++;
            e0 = e.getReverse(); // will be (b, v0), set up for next iSegment
            setConstrained(e0.getDual(), constraint, edgesForConstraint);
            continue segmentLoop;
          }
        }

        // test to see if the segment (a,b) crosses the line (v0,v1).
        // if it does, the intersection will either be behind the
        // segment (v0,v1) or on it.  The t variable is from the
        // parametric form of the line equation for the intersection
        // point (x,y) such that
        //   (x,y) = t*(ux, uy) + (v0.x, v0.y)
        double hab = ah * bh;
        if (hab <= 0) {
          double dx = bx - ax;
          double dy = by - ay;
          double t = (ax * dy - ay * dx) / (ux * dy - uy * dx);
          if (t > 0) {
            right0 = e;
            left0 = e.getReverse();
            h = n.getDual();
            break;
          }
        }
        e = e.getDualFromReverse();
      } while (!e.equals(e0));

      // step 2 ------------------------------------------
      // h should now be non-null and straddles the
      // constraint, vertex a is to its right
      // and vertex b is to its left.  we have already
      // tested for the cases where either a or b lies on (v0,v1)
      // begin digging the cavities to the left and right of h.
      if (h == null) {
        throw new IllegalStateException("Internal failure, constraint not added");
      }
      Vertex c = null;
      while (true) {
        right1 = h.getForward();
        left1 = h.getReverse();
        c = right1.getB();
        if (c == null) {
          throw new IllegalStateException("Internal failure, constraint not added");
        }
        removeEdge(h);
        double cx = c.getX() - x0;
        double cy = c.getY() - y0;
        double ch = cx * px + cy * py;
        if (Math.abs(ch) < vTolerence && cx * ux + cy * uy > 0) {
          // Vertex c is on the edge.  We will break the loop and
          // then construct a new segment from v0 to c.
          //   We need to ensure that c shows up in the constraint
          // vertex list.  But it is possible that c is actually a
          // vertex merger group that contains v1 (this could happen
          // if there were sample points in the original tin that
          // we coincident with v1 and also some that appeared between
          // v0 and v1, so that the above tests didn't catch an edge.

          if (!c.equals(v1)) {
            if (c instanceof VertexMergerGroup && ((VertexMergerGroup) c).contains(v1)) {
              cvList.set(iSegment + 1, c);
            } else {
              cvList.add(iSegment + 1, c);
              nSegments++;
            }
          }

          break;
        }

        double hac = ah * ch;
        double hbc = bh * ch;
        if (hac == 0 || hbc == 0) {
          throw new IllegalStateException("Internal failure, constraint not added");
        }

        if (hac < 0) {
          // branch right
          h = right1.getDual();
          bx = cx;
          by = cy;
          bh = bx * px + by * py;
        } else {
          // branch left (could hbc be zero?)
          h = left1.getDual();
          ax = cx;
          ay = cy;
          ah = ax * px + ay * py;
        }
      }

      // insert the constraint edge
      QuadEdge n = edgePool.allocateEdge(v0, c);
      setConstrained(n, constraint, edgesForConstraint);
      QuadEdge d = n.getDual();
      n.setForward(left1);
      n.setReverse(left0);
      d.setForward(right0);
      d.setReverse(right1);
      e0 = d;

      fillCavity(n);
      fillCavity(d);
    }

    searchEdge = e0;
  }
```



## 3.2æºç æµç¨‹æ¢³ç†

<img src="./assets/image-20240603092335506.png" alt="image-20240603092335506" style="zoom:50%;" />

```
Inserts a list of vertices into the collection of vertices managed by the TIN. If the TIN is not yet bootstrapped, the vertices will be retained in a simple list until enough vertices are received in order to bootstrapthe TIN.

1ã€Performance Consideration Related to List

In the bootstrap phase, three points are chosen at random from the vertex list to create the initial triangle for insertion. The initialization will make a small number of selection attempts and select the triangle with the largest number. In the event that this process does not find three points that are not a suitable choice (as when they are collinear or nearly collinear), the process will be repeated until a valid initial triangle is selected.

Thus, there is a small performance advantage in supplying the vertices using a list that can be accessed efficiently in a random order (see the discussion of the Java API for the List and java.util.RandomAccess interfaces). Once the initial triangle is established, the list will be traversed sequentially to build the TIN and random access considerations will no longer apply.

2ã€Performance Consideration Related to Location of Vertices

The performance of the insertion process is sensitive to the relative location of vertices. An input data set based on <strong>purely random</strong> vertex positions represents one of the worst-case input sets in terms of processing time.

Ordinarily, the most computationally expensive operation for inserting
a vertex into the Delaunay triangulation is locating the triangle
that contains its coordinates. But Tinfour implements logic to
expedite this search operation by taking advantage of a characteristic
that occurs in many data sets:  the location of one vertex in a sequence
is usually close to the location of the vertex that preceded it.
By starting each search at the position in the triangulation where a vertex
was most recently inserted, the time-to-search can be reduced dramatically.
Unfortunately, in vertices generated by a random process, this assumption
of sequential proximity (i.e. "spatial autocorrelation") is not true.

To assist in the case of random or poorly correlated vertex geometries,
application can take advantage of the HilbertSort class which is supplied
as part of the Core Tinfour module. In the example shown below, the
use of the HilbertSort yields a <strong>factor of 100</strong>
improvement in the time to perform the .add() method.
<pre>
     int nVertices = 1_000_000;
     List&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;();
     for (int i = 0; i &lt; nVertices; i++) {
       double x = Math.random() * 1000;
       double y = Math.random() * 1000;
       vertices.add(new Vertex(x, y, 0));
     }

     HilbertSort hs = new HilbertSort();
     hs.sort(vertices);
     IIncrementalTin tin = new IncrementalTin();
     tin.add(vertices, null);
</pre>
å°†é¡¶ç‚¹åˆ—è¡¨æ’å…¥åˆ°ç”±TINç®¡ç†çš„é¡¶ç‚¹é›†åˆä¸­ã€‚å¦‚æœTINå°šæœªå¯åŠ¨ï¼Œåˆ™è¿™äº›é¡¶ç‚¹å°†è¢«ä¿ç•™åœ¨ä¸€ä¸ªç®€å•çš„åˆ—è¡¨ä¸­ï¼Œç›´åˆ°æ”¶åˆ°è¶³å¤Ÿæ•°é‡çš„é¡¶ç‚¹ä»¥ä¾¿äºå¯åŠ¨TINã€‚

1ã€ä¸åˆ—è¡¨ç›¸å…³çš„æ€§èƒ½è€ƒè™‘

åœ¨å¯åŠ¨é˜¶æ®µï¼Œä¼šéšæœºä»é¡¶ç‚¹åˆ—è¡¨ä¸­é€‰æ‹©ä¸‰ä¸ªç‚¹æ¥åˆ›å»ºç”¨äºæ’å…¥çš„åˆå§‹ä¸‰è§’å½¢ã€‚åˆå§‹åŒ–ä¼šè¿›è¡Œå°‘é‡çš„é€‰æ‹©å°è¯•ï¼Œå¹¶é€‰æ‹©å…·æœ‰æœ€å¤§é¢ç§¯çš„ä¸‰è§’å½¢ã€‚å¦‚æœè¯¥è¿‡ç¨‹æ²¡æœ‰æ‰¾åˆ°ä¸‰ä¸ªé€‚åˆçš„ç‚¹ï¼ˆæ¯”å¦‚å½“å®ƒä»¬å…±çº¿æˆ–å‡ ä¹å…±çº¿æ—¶ï¼‰ï¼Œåˆ™è¯¥è¿‡ç¨‹å°†é‡å¤è¿›è¡Œï¼Œç›´åˆ°é€‰å®šä¸€ä¸ªæœ‰æ•ˆçš„åˆå§‹ä¸‰è§’å½¢ã€‚

å› æ­¤ï¼Œåœ¨æä¾›å¯ä»¥é«˜æ•ˆéšæœºè®¿é—®çš„åˆ—è¡¨æ–¹é¢æœ‰å°çš„æ€§èƒ½ä¼˜åŠ¿ï¼ˆå‚è§Java APIä¸­çš„Listå’Œjava.util.RandomAccessæ¥å£çš„ç›¸å…³è®¨è®ºï¼‰ã€‚ä¸€æ—¦å»ºç«‹äº†åˆå§‹ä¸‰è§’å½¢ï¼Œå°±ä¼šé¡ºåºéå†åˆ—è¡¨ä»¥å»ºç«‹TINï¼Œéšæœºè®¿é—®çš„è€ƒè™‘å°†ä¸å†é€‚ç”¨ã€‚

2ã€ä¸é¡¶ç‚¹ä½ç½®ç›¸å…³çš„æ€§èƒ½è€ƒè™‘

æ’å…¥è¿‡ç¨‹çš„æ€§èƒ½å¯¹é¡¶ç‚¹çš„ç›¸å¯¹ä½ç½®æ•æ„Ÿã€‚åŸºäºçº¯éšæœºé¡¶ç‚¹ä½ç½®çš„è¾“å…¥æ•°æ®é›†ä»£è¡¨äº†å¤„ç†æ—¶é—´ä¸Šçš„æœ€åæƒ…å†µä¹‹ä¸€ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œå°†ä¸€ä¸ªé¡¶ç‚¹æ’å…¥åˆ°Delaunayä¸‰è§’å‰–åˆ†ä¸­æœ€è®¡ç®—é‡å¤§çš„æ“ä½œæ˜¯å®šä½åŒ…å«å…¶åæ ‡çš„ä¸‰è§’å½¢ã€‚ä½†æ˜¯Tinfourå®ç°äº†é€»è¾‘ä»¥åŠ å¿«è¿™ä¸€æœç´¢æ“ä½œï¼Œåˆ©ç”¨è®¸å¤šæ•°æ®é›†ä¸­å‘ç”Ÿçš„ä¸€ä¸ªç‰¹å¾ï¼šåºåˆ—ä¸­é¡¶ç‚¹çš„ä½ç½®é€šå¸¸æ¥è¿‘äºä¹‹å‰é¡¶ç‚¹çš„ä½ç½®ã€‚é€šè¿‡ä»ä¸‰è§’å‰–åˆ†ä¸­æœ€è¿‘æ’å…¥é¡¶ç‚¹çš„ä½ç½®å¼€å§‹æ¯æ¬¡æœç´¢ï¼Œå¯ä»¥æ˜¾è‘—å‡å°‘æœç´¢æ—¶é—´ã€‚ä¸å¹¸çš„æ˜¯ï¼Œåœ¨éšæœºç”Ÿæˆçš„é¡¶ç‚¹ä¸­ï¼Œè¿™ç§é¡ºåºé‚»è¿‘æ€§ï¼ˆå³â€œç©ºé—´è‡ªç›¸å…³æ€§â€ï¼‰å¹¶ä¸æˆç«‹ã€‚

ä¸ºäº†ååŠ©å¤„ç†éšæœºæˆ–ç›¸å…³æ€§å·®çš„é¡¶ç‚¹å‡ ä½•ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥åˆ©ç”¨ä½œä¸ºCore Tinfouræ¨¡å—ä¸€éƒ¨åˆ†æä¾›çš„HilbertSortç±»ã€‚å¦‚ä¸‹é¢çš„ä¾‹å­æ‰€ç¤ºï¼Œä½¿ç”¨HilbertSortåœ¨æ‰§è¡Œ.add()æ–¹æ³•çš„æ—¶é—´ä¸Šå¸¦æ¥äº†100å€çš„æ”¹è¿›ã€‚
```

### æå‡è¿ç®—æ•ˆç‡

```
int	 nVertices = 1_000_000;
     List<Vertex> vertices = new ArrayList<>();
     for (int i = 0; i < nVertices; i++) {
       double x = Math.random() * 1000;
       double y = Math.random() * 1000;
       vertices.add(new Vertex(x, y, 0));
     }

     HilbertSort hs = new HilbertSort();
     hs.sort(vertices);
     IIncrementalTin tin = new IncrementalTin();
     tin.add(vertices, null);
```



**a.åˆå§‹åŒ–**

è¿™æ®µä»£ç ä¼¼ä¹æ˜¯å°è¯•æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¥½çš„åˆå§‹ä¸‰è§’å½¢ä»¥å¼€å§‹å¢é‡å¾·åŠ³å†…ä¸‰è§’å‰–åˆ†ï¼Œä½†å®ƒå¹¶ä¸æ˜¯é€šè¿‡åˆ›å»ºä¸€ä¸ªè¶…çº§ä¸‰è§’å½¢æ¥å®ç°çš„ã€‚ç›¸åï¼Œå®ƒä½¿ç”¨äº†ä¸€ç§å¯å‘å¼çš„æ–¹æ³•æ¥é€‰æ‹©åˆå§‹ä¸‰è§’å½¢ã€‚ä»¥ä¸‹æ˜¯è¯¥æ–¹æ³•çš„å¤§è‡´æµç¨‹ï¼š

1. **æ£€æŸ¥è¾“å…¥åˆ—è¡¨**ï¼šå¦‚æœè¾“å…¥çš„ `list` çš„å¤§å°å°äº 3ï¼Œå³æ²¡æœ‰è¶³å¤Ÿçš„é¡¶ç‚¹æ¥æ„é€ ä¸€ä¸ªä¸‰è§’å½¢ï¼Œåˆ™è¿”å› `null`ã€‚
2. **åˆå§‹åŒ–å˜é‡**ï¼š
   - åˆ›å»ºä¸¤ä¸ª `Vertex` æ•°ç»„ `v` å’Œ `vtest`ï¼Œç”¨æ¥åˆ†åˆ«å­˜å‚¨æœ€ä½³å¾—åˆ†çš„ä¸‰è§’å½¢å’Œå½“å‰æµ‹è¯•çš„ä¸‰è§’å½¢ã€‚
   - è®¡ç®—åŸºäºè¾“å…¥åˆ—è¡¨å¤§å° `n` çš„å°è¯•æ¬¡æ•° `nTrial`ã€‚
   - åˆå§‹åŒ– `bestScore` ä¸ºè´Ÿæ— ç©·å¤§ï¼Œç”¨äºè¿½è¸ªç›®å‰ä¸ºæ­¢æœ€å¤§é¢ç§¯çš„ä¸‰è§’å½¢ã€‚
3. **éšæœºé€‰æ‹©å’Œè¯„åˆ†**ï¼š
   - è¿›è¡Œ `nTrial` æ¬¡å¾ªç¯ï¼Œæ¯æ¬¡å°è¯•é€‰æ‹©å¹¶æµ‹è¯•ä¸€ä¸ªæ–°çš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœ `n` æ˜¯ 3ï¼Œåˆ™ç›´æ¥ä½¿ç”¨æ‰€æœ‰è¾“å…¥é¡¶ç‚¹ä½œä¸ºåˆå§‹ä¸‰è§’å½¢ã€‚
   - å¯¹äº `n` å¤§äº 3 çš„æƒ…å†µï¼Œä½¿ç”¨éšæœºçš„æ–¹å¼æŒ‘é€‰ä¸‰ä¸ªäº’ä¸ç›¸åŒçš„é¡¶ç‚¹æ„é€  `vtest` ä¸‰è§’å½¢ã€‚
   - åˆ©ç”¨ `geoOp.area(vtest[0], vtest[1], vtest[2])` è®¡ç®—é¢ç§¯ `a` ä»¥è¯„ä¼°ä¸‰è§’å½¢çš„åˆç†æ€§ã€‚
   - å¿½ç•¥é¢ç§¯ä¸ºé›¶çš„é€€åŒ–ä¸‰è§’å½¢ï¼ˆè¯´æ˜é¡¶ç‚¹å…±çº¿ï¼‰ã€‚
   - ç¡®ä¿ä¸‰è§’å½¢é¡¶ç‚¹æŒ‰é€†æ—¶é’ˆæ’åˆ—ï¼Œå¦‚æœé¢ç§¯ `a` ä¸ºè´Ÿå€¼åˆ™äº¤æ¢é¡ºåºã€‚
   - å¦‚æœä¸‰è§’å½¢é¢ç§¯ `a` å¤§äºå½“å‰ `bestScore`ï¼Œæ›´æ–° `v` ä»¥å­˜å‚¨è¿™ä¸ªä¸‰è§’å½¢ã€‚
4. **æ£€æŸ¥æœ€ä½³å¾—åˆ†**ï¼š
   - å¦‚æœæ‰¾åˆ°çš„æœ€ä½³ä¸‰è§’å½¢é¢ç§¯å¤§äºç­‰äºç»™å®šçš„é˜ˆå€¼ `triangleMinAreaThreshold`ï¼Œåˆ™è¿”å› `v` ä½œä¸ºåˆå§‹ä¸‰è§’å½¢ã€‚
5. **å¤‡ä»½ç­–ç•¥**ï¼š
   - å¦‚æœéšæœºæµ‹è¯•å¤±è´¥ï¼Œå°è¯•è°ƒç”¨ä¸€ä¸ªåä¸º `testInput` çš„æ–¹æ³•æ¥æ£€æµ‹è¾“å…¥æ•°æ®æ˜¯å¦æœ‰é—®é¢˜ï¼Œå¹¶ä¸”å°è¯•æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„åˆå§‹ä¸‰è§’å½¢ã€‚
   - å¦‚æœ `testInput` è¿”å›æœ‰æ•ˆç»“æœï¼Œåˆ™ä½¿ç”¨è¿”å›çš„ä¸‰è§’å½¢ã€‚
   - å¦‚æœ `testInput` ä¸èƒ½ç¡®å®šæˆ–å‘ç°è¾“å…¥æ•°æ®å­˜åœ¨é—®é¢˜ï¼Œåˆ™è¿›è¡Œä¸‹ä¸€æ­¥ã€‚
6. **ç©·ä¸¾æœç´¢**ï¼š
   - å¦‚æœä¸Šè¿°æ­¥éª¤å‡æœªæˆåŠŸï¼Œæ‰§è¡Œç©·ä¸¾æœç´¢ï¼Œå°è¯•åˆ—è¡¨ä¸­æ‰€æœ‰å¯èƒ½çš„ä¸‰å…ƒç»„æ¥æ‰¾åˆ°ä¸€ä¸ªéé€€åŒ–çš„åˆå§‹ä¸‰è§’å½¢ã€‚
   - å¦‚æœæ‰¾åˆ°æ»¡è¶³æœ€ä½é¢ç§¯è¦æ±‚çš„ä¸‰è§’å½¢ï¼Œåˆ™è¿”å›è¯¥ `v`ã€‚
7. **å¦‚æœæ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥**ï¼š
   - å¦‚æœä»¥ä¸Šæ‰€æœ‰å°è¯•å‡æœªèƒ½æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„åˆå§‹ä¸‰è§’å½¢ï¼Œåˆ™è¿”å› `null`ï¼Œè¿™è¡¨ç¤ºç›®å‰æ— æ³•æ„å»ºä¸‰è§’å‰–åˆ†ï¼Œå¯èƒ½éœ€è¦æ›´å¤šçš„é¡¶ç‚¹ã€‚

è¿™ä¸ªæ–¹æ³•çš„è®¾è®¡ç›®çš„æ˜¯åœ¨ä¸åˆ›å»ºè¶…çº§ä¸‰è§’å½¢çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡å°è¯•å’Œè¯„ä¼°éšæœºé€‰æ‹©çš„ä¸‰è§’å½¢é›†åˆæ¥æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„ã€å¹¶ä¸”å…·æœ‰ä¸€å®šå¥½çš„å‡ ä½•ç‰¹å¾ï¼ˆå¦‚è¾ƒå¤§é¢ç§¯ï¼‰çš„åˆå§‹ä¸‰è§’å½¢ã€‚æ­¤å¤–ï¼Œè¿˜æä¾›äº†ä¸€ç§åå¤‡æ–¹æ¡ˆï¼Œåœ¨éšæœºæ–¹æ³•å¤±è´¥çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨ç©·ä¸¾æœç´¢æ¥ç¡®ä¿å¯ä»¥æ‰¾åˆ°ä¸€ä¸ªå¯åŠ¨å‰–åˆ†è¿‡ç¨‹çš„ä¸‰è§’å½¢ã€‚

# å››ã€æ ¸å¿ƒç®—æ³•å’Œæ•°æ®ç»“æ„

TIN ï¼šä»£è¡¨ä¸‰è§’ç½‘æ ¼

## 0--å¹½çµä¸‰è§’å½¢ï¼š

![image-20240602171050283](./assets/image-20240602171050283.png)

## 1--QuadEdge(è¾¹ç»“æ„)

è¾¹çš„ä¸€ç§è¡¨ç¤ºå½¢å¼ã€‚
å…·æœ‰ä¸€ä¸‹å‡ ä¸ªå±æ€§

- ç´¢å¼•å·index

- æ­£æ–¹å‘è¾¹(f)
- åæ–¹å‘è¾¹(r)
- èµ·å§‹ç‚¹(v)
- ç»ˆç‚¹(dual.v)
- å¯¹å¶çš„å­ªç”Ÿè¾¹(dual)ï¼ˆåŒæ ·çš„ç«¯ç‚¹ã€åæ–¹å‘ï¼Œå…¶å­ªç”Ÿè¾¹çš„èµ·ç‚¹å°±æ˜¯å®ƒçš„ç»ˆç‚¹ï¼‰ã€‚

```java
public class QuadEdge implements IQuadEdge {

  int index;

  /**
   * The dual of this edge (always valid, never null.
   */
  QuadEdge dual;
  /**
   * The initial vertex of this edge, the second vertex of
   * the dual.
   */
  Vertex v;
  /**
   * The forward link of this edge.
   */
  QuadEdge f;
  /**
   * The reverse link of this edge.
   */
  QuadEdge r;

  /**
   * Constructs the edge and its dual.
   */
  QuadEdge() {
    dual = new QuadEdgePartner(this);
  }

  /**
   * Construct the edge setting its dual with the specified reference.
   *
   * @param partner a valid element.
   */
  QuadEdge(final QuadEdge partner) {
    dual = partner;
  }

  /**
   * Construct the edge and its dual assigning the pair the specified index.
   *
   * @param index an arbitrary integer value.
   */
  public QuadEdge(final int index) {
    dual = new QuadEdgePartner(this);
    this.index = index;
  }

  /**
   * Sets the vertices for this edge (and its dual).
   *
   * @param a the initial vertex, must be a valid reference.
   * @param b the second vertex, may be a valid reference or a
   * null for a ghost edge.
   */
  public void setVertices(final Vertex a, final Vertex b) {
    this.v = a;
    this.dual.v = b;
  }

  /**
   * Gets the initial vertex for this edge.
   *
   * @return a valid reference.
   */
  @Override
  public final Vertex getA() {
    return v;
  }

  /**
   * Sets the initial vertex for this edge.
   *
   * @param a a valid reference.
   */
  public final void setA(final Vertex a) {
    this.v = a;
  }

  /**
   * Gets the second vertex for this edge.
   *
   * @return a valid reference or a null for a ghost edge.
   */
  @Override
  public final Vertex getB() {
    return dual.v;
  }

  /**
   * Sets the second (B) vertex for this edge (also the A reference of
   * the dual edge).
   *
   * @param b a valid reference or a null for a ghost edge.
   */
  public final void setB(final Vertex b) {
    dual.v = b;
  }

  /**
   * Gets the forward reference of the edge.
   *
   * @return a valid reference.
   */
  @Override
  public final QuadEdge getForward() {
    return f;
  }

  /**
   * Gets the reverse reference of the edge.
   *
   * @return a valid reference.
   */
  @Override
  public final QuadEdge getReverse() {
    return r;
  }

  /**
   * Gets the forward reference of the dual.
   *
   * @return a valid reference
   */
  @Override
  public final QuadEdge getForwardFromDual() {
    return dual.f;
  }

  /**
   * Gets the reverse link of the dual.
   *
   * @return a valid reference
   */
  @Override
  public final QuadEdge getReverseFromDual() {
    return dual.r;
  }

  /**
   * Gets the dual of the reverse link.
   *
   * @return a valid reference
   */
  @Override
  public final QuadEdge getDualFromReverse() {
    return r.dual;
  }

  /**
   * Sets the forward reference for this edge.
   *
   * @param e a valid reference
   */
  public final void setForward(final QuadEdge e) {
    this.f = e;
    e.r = this;
    // forwardCheck(this, e);
  }

  /**
   * Sets the reverse reference for this edge.
   *
   * @param e a valid reference
   */
  public final void setReverse(final QuadEdge e) {
    this.r = e;
    e.f = this;
    // forwardCheck(e, this);
  }

  /**
   * Sets the forward link to the dual of this edge.
   *
   * @param e a valid reference
   */
  public final void setDualForward(final QuadEdge e) {
    dual.f = e;
    e.r = dual;
    // forwardCheck(dual, e);
  }

  /**
   * Sets the reverse link of the dual to this edge.
   *
   * @param e a valid reference
   */
  public final void setDualReverse(final QuadEdge e) {
    dual.r = e;
    e.f = dual;
    // forwardCheck(e, dual);
  }

  /**
   * Gets the dual edge to this instance.
   *
   * @return a valid edge.
   */
  @Override
  public final QuadEdge getDual() {
    return dual;
  }

  /**
   * Gets the index value for this edge.
   *
   * @return an integer value
   */
  @Override
  public int getIndex() {
    return index;
  }

  @Override
  public int getBaseIndex(){
    return index;
  }

  /**
   * Sets the index value for this edge. Because this index value is
   * used by edge-pool implementations and for other data management activities,
   * the scope of this method is limited to protected. The actual definition
   * of this element is left to the application that uses it.
   *
   * @param index an integer value
   */
  protected void setIndex(final int index) {
    this.index = index;
  }

  /**
   * Gets the reference to the side-zero edge of the pair.
   *
   * @return a link to the side-zero edge of the pair.
   */
  @Override
  public QuadEdge getBaseReference() {
    return this;
  }

  /**
   * Gets the index of the constraint associated with this edge.
   * Constraint index values must be in the range 0 to Integer.MAX_VALUE,
   * with negative numbers being reserved for internal use by the
   * Tinfour library,
   *
   * @return if constrained, a positive integer; otherwise, a negative value.
   */
  @Override
  public int getConstraintIndex() {
    return dual.getConstraintIndex();
  }

  @Override
  public void setConstraintIndex(int constraintIndex) {
    dual.setConstraintIndex(constraintIndex);
  }

  /**
   * Gets the index of the constrain associated with
   *
   * @return true if the edge is constrained; otherwise, false.
   */
  @Override
  public boolean isConstrained() {
    return dual.isConstrained();
  }

  @Override
  public void setConstrained(int constraintIndex) {
    dual.setConstrained(constraintIndex);
  }

  /**
   * Sets all vertices and link references to null (the link to a dual
   * is not affected).
   */
  public void clear() {
    // note that the index of the partner is set to -1,
    // but the index of the base, which is used for management purposes
    // is left alone.
    this.v = null;
    this.f = null;
    this.r = null;
    dual.v = null;
    dual.f = null;
    dual.r = null;
    dual.index = 0;
  }

  /**
   * Gets a name string for the edge by prepending the index value
   * with a + or - string depending on its side (+ for side zero, - for side 1).
   *
   * @return a valid string.
   */
  String getName() {
    return Integer.toString(getIndex()) ;
  }

  @Override
  public String toString() {
    Vertex a = v;
    Vertex b = dual.v;
    if (a == null && b == null) {
      return String.format("%9d  -- Undefined", getIndex());
    }

    StringBuilder sb = new StringBuilder();
    try (Formatter fmt = new Formatter(sb)) {
      fmt.format("%9s  %9s <-- (%9s,%9s) --> %9s",
        getName(),
        r == null ? "null" : r.getName(),
        a == null ? "gv" : a.getLabel(),
        b == null ? "gv" : b.getLabel(),
        f == null ? "null" : f.getName()
      );

      fmt.flush();
    }

    if (this.isConstrained()) {
      sb.append("    constrained ");
      if (this.isConstrainedRegionBorder()) {
        sb.append("region border ");
      }
      sb.append(Integer.toString(getConstraintIndex()));
    } else if (isConstrainedRegionInterior()) {
      sb.append("    constrained region interior ");
      sb.append(Integer.toString(getConstraintIndex()));
    }

    return sb.toString();
  }

  /**
   * Gets the length of the edge.
   *
   * @return a positive floating point value
   */
  @Override
  public double getLength() {
    if (v == null || dual.v == null) {
      return Double.NaN;
    }
    double dx = v.x - dual.v.x;
    double dy = v.y - dual.v.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Indicates which side of an edge a particular QuadEdge instance is
   * attached to. The side value is a strictly arbitrary index used for
   * algorithms that need to be able to assign a unique index to
   * both sides of an edge.
   *
   * @return a value of 0 or 1.
   */
  @Override
  public int getSide() {
    return 0;
  }

  /**
   * An implementation of the equals method which check for a matching
   * reference.
   *
   * @param o a valid reference or a null
   * @return true if the specified reference matches this.
   */
  @Override
  public boolean equals(Object o) {
    if (o instanceof QuadEdge) {
      return this == o;
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash = 11 * hash + this.index;
    return hash;
  }

  @Override
  public boolean isConstrainedRegionMember() {
    return dual.isConstrainedRegionMember();
  }

  @Override
  public boolean isConstrainedRegionInterior() {
    return dual.isConstrainedRegionInterior();
  }

  @Override
  public boolean isConstrainedRegionBorder() {
    return dual.isConstrainedRegionBorder();
  }


  @Override
  public boolean isConstraintLineMember(){
    return dual.isConstraintLineMember();
  }

  @Override
  public void setConstraintLineMemberFlag(){
     dual.setConstraintLineMemberFlag();
  }


  @Override
  public void setConstrainedRegionBorderFlag() {
    dual.setConstrainedRegionBorderFlag();
  }

  @Override
  public void setConstrainedRegionInteriorFlag() {
    dual.setConstrainedRegionInteriorFlag();
  }

  @Override
  public void setSynthetic(boolean status){
    dual.setSynthetic(status);
  }

  @Override
  public boolean isSynthetic(){
    return dual.isSynthetic();
  }


  @Override
  public Iterable<IQuadEdge> pinwheel() {
    return new QuadEdgePinwheel(this);
  }

  @Override
  public void setLine2D(AffineTransform transform, Line2D l2d) {
    Vertex A = getA();
    Vertex B = getB();
    double[] c = new double[8];
    if (A == null && B == null) {
      // uninitialized edge, shouldn't happen
      l2d.setLine(0, 0, 0, 0);
      return;
    } else if (A == null) {
      c[0] = B.getX();
      c[1] = B.getY();
      c[2] = B.getX();
      c[3] = B.getY();
    } else if (B == null) {
      c[0] = A.getX();
      c[1] = A.getY();
      c[2] = A.getX();
      c[3] = A.getY();
    } else {
      c[0] = A.getX();
      c[1] = A.getY();
      c[2] = B.getX();
      c[3] = B.getY();
    }
    transform.transform(c, 0, c, 4, 2);
    l2d.setLine(c[4], c[5], c[6], c[7]);
  }
}
```

## 2--EdgePool

```java
/**
 * æä¾›ä¸€ä¸ªå¯¹è±¡æ± å®ç°ï¼Œå®ƒç®¡ç†ç€è¾¹ï¼ˆEdgeï¼‰çš„åˆ†é…ã€åˆ é™¤å’Œé‡ç”¨ã€‚
 * <p>è¯¥ç±»é‡‡ç”¨éå¸¸ä¼ ç»Ÿçš„ç¼–ç¨‹æ–¹æ³•æ¥ç¼–å†™ï¼Œç›®çš„æ˜¯ä¸ºäº†å°½å¯èƒ½å‡å°‘å¯¹è±¡è¢«åƒåœ¾æ”¶é›†çš„é¢‘ç‡ã€‚
 * åœ¨æ„å»º TINï¼ˆä¸‰è§’ä¸è§„åˆ™ç½‘ç»œï¼‰æ—¶ï¼Œè¾¹ä¼šè¢«å¤§é‡åœ°åˆ†é…å’Œé‡Šæ”¾ã€‚
 * å¦‚æœè¿™äº›è¾¹ä»…ä»…æ˜¯åˆ›å»ºå¹¶ä¸”ç½®äºä½œç”¨åŸŸä¹‹å¤–ï¼Œéšåè¿›è¡Œçš„åƒåœ¾æ”¶é›†å¯èƒ½ä¼šé™ä½æ€§èƒ½ã€‚
 * <p>æ³¨æ„ï¼Œè¿™ä¸ªç±»<strong>ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„</strong>ã€‚
 * <p>å‡ºäºæ€§èƒ½è€ƒè™‘ï¼Œè¿™ä¸ªç±»ä¸­çš„è®¸å¤šæ–¹æ³•éƒ½å‡è®¾ä»»ä½•ä¼ å…¥æ–¹æ³•çš„è¾¹éƒ½æ˜¯ç”±å½“å‰å®ä¾‹ç®¡ç†çš„ã€‚å¦‚æœè¿åäº†è¿™ä¸€å‡è®¾ï¼Œå¯èƒ½ä¼šå‘ç”Ÿä¸¥é‡çš„é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªåº”ç”¨ç¨‹åºä½¿ç”¨ä¸€ä¸ªè¾¹æ± æ¥åˆ†é…ä¸€ä¸ªè¾¹ï¼Œç„¶åå°†å…¶ä¼ é€’ç»™å¦ä¸€ä¸ªè¾¹æ± å®ä¾‹çš„ deallocEdge æ–¹æ³•ï¼Œä¸¤ä¸ªå®ä¾‹å¯èƒ½éƒ½ä¼šå˜å¾—ä¸¥é‡æŸåã€‚
 */

Page[] pages;
 /**
   * Construct a QuadEdge manager allocating a small number
   * of initial edges.
   * æ„é€ ä¸€ä¸ªåˆ†é…å°‘é‡åˆå§‹è¾¹çš„QuadEdgeç®¡ç†å™¨ã€‚
   *
   */
  public EdgePool() {
    this.pageSize = EDGE_POOL_PAGE_SIZE;
    this.pageSize2 = EDGE_POOL_PAGE_SIZE*2;
    pages = new Page[1];
    pages[0] = new Page(0);
    nextAvailablePage = pages[0];
    nextAvailablePage.initializeEdges();
    nFree = pageSize;
  }
```

### class Page

```java
private class Page {
    int pageID;
    int pageOffset;
    int nAllocated;
    QuadEdge[] edges;
    Page nextPage;

    Page(int pageID) {
      this.pageID = pageID;
      pageOffset = pageID * pageSize2;
      edges = new QuadEdge[pageSize];
    }

    /**
     * Sets up the array of free Edges. This method is almost always
     * called when a new page is created. The only time it is not is in the
     * compact() operation where Edges will be shifted around.
     */
    void initializeEdges() {
      for (int i = 0; i < pageSize; i++) {
        edges[i] = new QuadEdge(pageOffset + i*2); //NOPMD
      }
    }

    QuadEdge allocateEdge() {
      QuadEdge e = edges[nAllocated];
      e.setIndex(pageID * pageSize2 + nAllocated*2);
      nAllocated++;
      return e;
    }

    /**
     * Free the QuadEdge for reuse, setting any external references to null,
     * but not damaging any arrays or management structures.
     * <p>
     * Note that it is important that deallocation set the
     * QuadEdge back to its initialization states. To conserve processing
     * the allocation routine assumes that any unused QuadEdge in
     * the collection is already in its initialized state and so doesn't
     * do any extra work.
     *
     * @param e a valid QuadEdge
     */
    @SuppressWarnings("PMD.CollapsibleIfStatements")
    void deallocateEdge(QuadEdge be) {
      // reset to initialization state as necessary.
      // in this following block, we clear all flags that matter.
      // We also set any references to null to prevent
      // object retention and expedite garbage collection.
      //   Note that the variable arrayIndex is NOT the edge index,
      // but rather the array index for the edge within the array of edge pairs
      // stored by this class.

      QuadEdge e = be.getBaseReference();
      int arrayIndex = (e.getIndex() - pageOffset)/2;
      e.clear();

      // The array of Edges must be kept
      // so that all allocated Edges are together at the beginning
      // of the array and all the free Edges are together at
      // the end of the array.  If the removal
      // left a "hole" in the section of the array dedicated to allocated
      // Edges, shift Edges around, reassigning the managementID
      // of the QuadEdge that was shifted into the hole.
      nAllocated--;
      // nAllocated is now the index of the last allocated QuadEdge
      // in the array.  We can modify the allocationID of that
      // QuadEdge and its position in the array because the
      // EdgeManager class is the only one that manipulates these
      // values.

      if (arrayIndex < nAllocated) {
        QuadEdge swap = edges[nAllocated];
        edges[arrayIndex] = swap;
        int oldIndex = swap.getIndex();
        int newIndex = pageOffset + arrayIndex*2;
        swap.setIndex(newIndex);
        edges[nAllocated] = e;

        // the swap operation will change the index of the line. And, because
        // the index is used as a key into the constraint maps, we need to
        // adjust the entries.  The fact that this action is necessarily
        // highlights one of the disadvantages of the design choice of
        // swapping edges.  It was chosen in an effort to save memory
        // (constrast it with the semi-virtual implementation which
        // maintains a free list).  But it did have side-effects. The
        // semi-virtual implementation may have the better approach.
        if (swap.isConstraintLineMember()) {
          if (linearConstraintMap.containsKey(oldIndex)) {
            IConstraint c = linearConstraintMap.get(oldIndex);
            linearConstraintMap.remove(oldIndex);
            linearConstraintMap.remove(oldIndex ^ 1);
            linearConstraintMap.put(newIndex, c);
            linearConstraintMap.put(newIndex ^ 1, c);
          }
        }
        if (swap.isConstrainedRegionBorder()) {
          if (borderConstraintMap.containsKey(oldIndex)) {
            IConstraint c = borderConstraintMap.get(oldIndex);
            borderConstraintMap.remove(oldIndex);
            borderConstraintMap.put(newIndex, c);
          }
          oldIndex ^= 1;  // set index to dual
          newIndex ^= 1;
          if (borderConstraintMap.containsKey(oldIndex)) {
            IConstraint c = borderConstraintMap.get(oldIndex);
            borderConstraintMap.remove(oldIndex);
            borderConstraintMap.put(newIndex, c);
          }
        }

        e.setIndex(pageOffset + nAllocated*2);  // pro forma, for safety
      }
    }

    boolean isFullyAllocated() {
      return nAllocated == edges.length;
    }
  }
```

#### åˆ†æ

è¿™ä¸ªJavaç±»æ˜¯`EdgePool`ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªå¯¹è±¡æ± å®ç°ï¼Œç”¨äºç®¡ç†è¾¹(`Edges`)çš„åˆ†é…ã€åˆ é™¤å’Œé‡ç”¨ã€‚è¯¥ç±»æ˜¯ä¸ºäº†æ„å»ºTINï¼ˆä¸‰è§’ä¸è§„åˆ™ç½‘ç»œï¼‰è€Œè®¾è®¡çš„ï¼Œå…¶ä¸­æ¶‰åŠå¤§é‡è¾¹çš„åŠ¨æ€åˆ†é…å’Œé‡Šæ”¾ã€‚ä½¿ç”¨å¯¹è±¡æ± å¯ä»¥æœ€å°åŒ–åƒåœ¾å›æ”¶çš„é¢‘ç‡ï¼Œä»è€Œä¼˜åŒ–æ€§èƒ½ã€‚

ä»¥ä¸‹æ˜¯`EdgePool`ç±»çš„å…³é”®ç‰¹ç‚¹å’Œç»„æˆéƒ¨åˆ†çš„æ¦‚æ‹¬ï¼š

- `EDGE_POOL_PAGE_SIZE`: é™æ€å¸¸é‡ï¼Œé»˜è®¤1024ï¼Œè¡¨ç¤ºæ¯é¡µå¯ä»¥å­˜å‚¨çš„è¾¹çš„æ•°é‡ã€‚
- `pageSize` å’Œ `pageSize2`: åˆ†åˆ«ä»£è¡¨æ¯é¡µå­˜å‚¨çš„è¾¹çš„æ•°é‡å’Œè¯¥å€¼çš„ä¸¤å€ã€‚
- `pages`: å­˜å‚¨é¡µé¢æ•°ç»„ï¼Œæ¯ä¸ªé¡µé¢åŒ…å«å¤šä¸ªè¾¹ã€‚
- `nextAvailablePage`: æŒ‡å‘ä¸‹ä¸€ä¸ªæœ‰å¯ç”¨è¾¹çš„é¡µé¢çš„æŒ‡é’ˆã€‚
- `nAllocated`, `nFree`, `nAllocationOperations`, `nFreeOperations`: ç”¨äºè·Ÿè¸ªå·²åˆ†é…çš„è¾¹ã€ç©ºé—²çš„è¾¹ä»¥åŠåˆ†é…å’Œé‡Šæ”¾æ“ä½œçš„è®¡æ•°ã€‚
- `borderConstraintMap` å’Œ `linearConstraintMap`: ç”¨äºå°†çº¦æŸå¯¹è±¡å…³è”åˆ°ç›¸åº”çš„è¾¹ï¼Œé¿å…åœ¨æ¯æ¡è¾¹ä¸Šç›´æ¥å­˜å‚¨çº¦æŸå¼•ç”¨ï¼Œä»¥èŠ‚çœå†…å­˜ã€‚

ä¸»è¦æ–¹æ³•ï¼š

- `preAllocateEdges(int n)`: é¢„åˆ†é…ä¸€å®šæ•°é‡çš„è¾¹ã€‚
- <img src="./assets/image-20240604193943753.png" alt="image-20240604193943753" style="zoom:50%;" />
- `allocateEdge(Vertex a, Vertex b)`: åˆ†é…ä¸€ä¸ªæ–°è¾¹ï¼Œå¹¶è®¾ç½®å…¶é¡¶ç‚¹ã€‚
- `deallocateEdge(QuadEdge e)`: é‡Šæ”¾ç»™å®šçš„è¾¹ï¼Œå°†å…¶è¿”å›åˆ°å¯¹è±¡æ± ä¸­ä¾›æœªæ¥é‡ç”¨ã€‚
- `getStartingEdge()`, `getStartingGhostEdge()`: è·å–éå¹½çµè¾¹çš„èµ·å§‹è¾¹æˆ–å¹½çµè¾¹ã€‚
- ![image-20240604194034035](./assets/image-20240604194034035.png)
- `getEdges()`: è·å–å½“å‰æ‰€æœ‰å·²åˆ†é…è¾¹çš„åˆ—è¡¨ã€‚
- `splitEdge(QuadEdge e, Vertex m)`: å°†ç»™å®šçš„è¾¹åˆ†å‰²ä¸ºä¸¤æ¡ï¼Œæ’å…¥ä¸€ä¸ªæ–°çš„é¡¶ç‚¹mã€‚
- `addBorderConstraintToMap`, `addLinearConstraintToMap`, `removeBorderConstraintFromMap`: ç®¡ç†ä¸è¾¹ç›¸å…³çš„çº¦æŸæ˜ å°„ã€‚
- `dispose()`: æ¸…é™¤æ‰€æœ‰å¼•ç”¨ï¼Œå¸®åŠ©åƒåœ¾å›æ”¶ã€‚
- `clear()`: æ¸…ç©ºå¯¹è±¡æ± ï¼Œä½†ä¸åˆ é™¤ç°æœ‰å¯¹è±¡ã€‚
- `printDiagnostics(PrintStream ps)`: æ‰“å°è¯Šæ–­ä¿¡æ¯ã€‚

å†…éƒ¨ç±» `Page` è¡¨ç¤ºå¯¹è±¡æ± çš„ä¸€ä¸ªé¡µé¢ï¼Œè´Ÿè´£å­˜å‚¨å’Œç®¡ç†ä¸€ç»„è¾¹ã€‚æ¯ä¸ª`Page`å¯¹è±¡éƒ½æœ‰ä¸€ä¸ª`pageID`ï¼Œ`edges`æ•°ç»„å­˜å‚¨è¾¹çš„å®ä¾‹ï¼Œ`nAllocated`è®°å½•åˆ†é…çš„è¾¹çš„æ•°é‡ã€‚

æ•´ä½“ä¸Šçœ‹ï¼Œæ­¤ç±»æ˜¯Tinfouråº“çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºé«˜æ•ˆç®¡ç†åœ°ç†ä¿¡æ¯ç³»ç»Ÿä¸­çš„æ•°æ®ç»“æ„ã€‚å®ƒé€šè¿‡å‡å°‘åŠ¨æ€å†…å­˜åˆ†é…å’Œåƒåœ¾æ”¶é›†æ¥ä¼˜åŒ–æ€§èƒ½ï¼Œå¹¶ä¸”ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

## 3--Vertex

```java
public class Vertex implements ISamplePoint {

  //åˆæˆç‚¹æ ‡å¿—ä½
  public static final int BIT_SYNTHETIC = 0x01;

  //çº¦æŸè¾¹æ ‡å¿—ä½
  public static final int BIT_CONSTRAINT = 0x02;

  //ä¿ç•™ä½†ä¸å‚ä¸ç½‘æ ¼æ„å»ºçš„ç‚¹
  public static final int BIT_WITHHELD = 0x04;
  
  //ç´¢å¼•ï¼Œä½†å¹¶ä¸æ˜¯finalä¸å¯ä¿®æ”¹çš„ï¼Œå¯ä»¥åœ¨ç¨‹åºä¸­è‡ªç”±ä¿®æ”¹
  private int index;

  //ç¬›å¡å°”åæ ‡ç³» x
  public final double x;
  //ç¬›å¡å°”åæ ‡ç³» y
  public final double y;

  /**
   * The z coordinate of the vertex (immutable); treated as a dependent
   * variable of (x,y).
   */
  final float z;

  //é¡¶ç‚¹çš„ä½å›¾çŠ¶æ€æ ‡å¿—ã€‚è¯¥å­—æ®µçš„ä½çš„æ„ä¹‰åˆ†é…ç”±è¯¥ç±»çš„é™æ€æˆå‘˜å®šä¹‰ã€‚
  protected byte status;
  /**
   * An unused field reserved for use by applications and derived classes
   */
  protected byte reserved0;
  /**
   * An unused field reserved for use by applications and derived classes
   */
  protected byte reserved1;
  
  //ä¸ºå›¾ç€è‰²ç®—æ³•å’Œå…¶ä»–ç¨‹åºæä¾›çš„è¾…åŠ©ç´¢å¼•
  protected byte auxiliary;

  /**
  * æ„é€ ä¸€ä¸ªå…·æœ‰æŒ‡å®šåæ ‡å’Œzå€¼çš„é¡¶ç‚¹ã€‚ç”¨äºDataModeã€‚ä¸æ–­çš„å¦‚æœzå€¼ä¸ºNanï¼Œåˆ™é¡¶ç‚¹å°†è¢«è§†ä¸ºâ€œç©ºæ•°æ®å€¼â€
  *
  *@param xå®šä¹‰é¡¶ç‚¹çš„æ›²é¢ä¸Šçš„åæ ‡
  *@param yå®šä¹‰é¡¶ç‚¹çš„æ›²é¢ä¸Šçš„åæ ‡
  *@param zæ•°æ®å€¼ï¼ˆæ›²é¢çš„zåæ ‡ï¼‰
  */
  public Vertex(final double x, final double y, final double z) {
    this.x = x;
    this.y = y;
    this.z = (float) z;
    this.index = 0;
  }

  /**
   * Construct a vertex with the specified coordinates and ID value. If the z
   * value is NaN then the vertex will be treated as a "null data value".
   *
   * @param x the coordinate on the surface on which the vertex is defined
   * @param y the coordinate on the surface on which the vertex is defined
   * @param z the data value (z coordinate of the surface)
   * @param index the ID of the vertex (intended as a diagnostic)
   */
  public Vertex(
    final double x,
    final double y,
    final double z,
    final int index) {
    this.x = x;
    this.y = y;
    this.z = (float) z;
    this.index = index;

  }

  /**
   * Gets a string intended for labeling the vertex in images or
   * reports. The default label is the index of the vertex preceeded
   * by the letter S if the vertex is synthetic. Note that the
   * index of a vertex is not necessarily unique but left to the
   * requirements of the application that constructs it.
   *
   * @return a valid, non-empty string.
   */
  public String getLabel() {
    return (isSynthetic() ? "S" : "") + Integer.toString(index);
  }

  @Override
  public String toString() {
    String s = (isSynthetic() ? "S" : " ")
      + index + ": "
      + "x=" + x + ", "
      + "y=" + y + ", "
      + "z=" + z;
    return s;
  }

  /**
   * åˆ°æŒ‡å®šç‚¹è·ç¦»çš„å¹³æ–¹
   *
   * @param v a valid vertex
   * @return the square of the distance
   */
  public double getDistanceSq(final Vertex v) {
    double dx = x - v.x;
    double dy = y - v.y;
    return dx * dx + dy * dy;
  }

  /**
   * åˆ°æŒ‡å®šç‚¹è·ç¦»çš„å¹³æ–¹
   *
   * @param x coordinate of arbitrary point
   * @param y coordinate of arbitrary point
   * @return a distance in units squared
   */
  @Override
  public double getDistanceSq(final double x, final double y) {
    double dx = this.x - x;
    double dy = this.y - y;
    return dx * dx + dy * dy;
  }

  /**
   * é¡¶ç‚¹åˆ°ä»»æ„ç‚¹ç‚¹è·ç¦».
   *
   * @param x coordinate of arbitrary point
   * @param y coordinate of arbitrary point
   * @return the distance in the applicable coordinate system
   */
  public double getDistance(final double x, final double y) {
    double dx = this.x - x;
    double dy = this.y - y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Get the distance to the vertex.
   *
   * @param v a valid vertex
   * @return the distance to the vertex
   */
  public double getDistance(final Vertex v) {
    double dx = x - v.x;
    double dy = y - v.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Get the x coordinate associated with the vertex. The x coordinate is
   * immutable and established when the vertex is constructed. it is
   * populated whether the vertex contains a null data value (Z value or I
   * value).
   *
   * @return a valid floating point value.
   */
  @Override
  public double getX() {
    return x;
  }

  /**
   * Get the y coordinate associated with the vertex. The y coordinate is
   * inmmutable and established when the vertex is constructed. it is
   * populated whether the vertex contains a null data value (Z value or I
   * value).
   *
   * @return a valid floating point value.
   */
  @Override
  public double getY() {
    return y;
  }

  /**
   * Get the z value associated with the vertex. If the vertex is null, the
   * return value for this method is Double.NaN ("not a number").
   *
   * @return a floating point value or Double.NaN if z value is null.
   */
  @Override
  public double getZ() {
    return z;
  }

  /**
   * Indicates whether the vertex has been marked as having a null data value.
   *
   * @return true if vertex is marked as null; otherwise, false.
   */
  public boolean isNull() {
    return Double.isNaN(z);
  }

  /**
   * Gets the arbitrary index associated with the vertex. Indexes allow
   * vertices to be associated with an array of values and are also used
   * internally for diagnostic purposes.
   * <p>
   * This method permits public readonly access to the index.
   *
   * @return an integer value.
   */
  public int getIndex() {
    return index;
  }

  /**
   * Sets the arbitrary index associated with the vertex. Indexes allow
   * vertices to be associated with an array of values and are also used
   * internally for diagnostic purposes.
   *
   * @param index an integer value.
   */
  public void setIndex(final int index) {
    this.index = index;
  }

  /**
   * Indicates whether a vertex is synthetic (was created through
   * a Tinfour procedure rather than supplied by an application).
   *
   * @return true if vertex is synthetic; otherwise, false
   */
  //åˆæˆç‚¹æ ‡å¿—ä½
  public boolean isSynthetic() {
    return (status & BIT_SYNTHETIC) != 0;
  }

  /**
   * Sets or clears the is-synthetic status of a vertex.
   *
   * @param synthetic true if vertex is synthetic; otherwise, false
   */
  public void setSynthetic(boolean synthetic) {
    if (synthetic) {
      status |= BIT_SYNTHETIC;
    } else {
      status &= ~BIT_SYNTHETIC;
    }
  }

  /**
   * Sets or clears the is-constraint-member status of a vertex.
   *
   * @param constraintMember true if vertex is a part of a constraint definition
   * or lies on the border of an area constraint; otherwise,  false
   */
  /**è®¾ç½®æˆ–æ¸…é™¤é¡¶ç‚¹çš„is-constraint-memberçŠ¶æ€ã€‚
  *
  *@param constraintMember trueå¦‚æœé¡¶ç‚¹æ˜¯çº¦æŸå®šä¹‰çš„ä¸€éƒ¨åˆ†
  *æˆ–è€…ä½äºåŒºåŸŸçº¦æŸçš„è¾¹ç•Œä¸Šï¼›å¦åˆ™ï¼Œfalse
  */
  public void setConstraintMember(boolean constraintMember) {
    if (constraintMember) {
      status |= BIT_CONSTRAINT;
    } else {
      status &= ~BIT_CONSTRAINT;
    }
  }



  
  /**
  *æŒ‡ç¤ºé¡¶ç‚¹æ˜¯å¦æ ‡è®°ä¸ºä¿ç•™ã€‚æ­¤è®¾ç½®æ˜¯
  *é€šå¸¸ç”±åº”ç”¨ç¨‹åºä»£ç æˆ–å…¶ä»–å®ç”¨ç¨‹åºè®¾ç½®ï¼Œè€Œä¸æ˜¯ç”±Tinfourè®¾ç½®
  *å†…éƒ¨è¿ä½œã€‚
  *
  *@å¦‚æœä¿ç•™é¡¶ç‚¹ï¼Œåˆ™è¿”å›trueï¼›å¦åˆ™ï¼Œfalse
  */
  public boolean isWithheld() {
    return (status & BIT_WITHHELD) != 0;
  }

   /**
   * Sets or clears the is-withheld status of a vertex.
   *
   * @param synthetic true if vertex is withheld; otherwise, false
   */
  public void setWithheld(boolean synthetic) {
    if (synthetic) {
      status |= BIT_WITHHELD;
    } else {
      status &= ~BIT_WITHHELD;
    }
  }



  /**
  *è®¾ç½®é¡¶ç‚¹çš„çŠ¶æ€å€¼ã€‚æ­¤æ–¹æ³•æ—¨åœ¨
  *æä¾›äº†ä¸€ç§åŒæ—¶è®¾ç½®å¤šä¸ªçŠ¶æ€æ ‡å¿—çš„æœ‰æ•ˆæ–¹å¼ã€‚
  *
  *@param statusæ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„çŠ¶æ€å€¼ã€‚å› ä¸ºçŠ¶æ€å®šä¹‰ä¸º
  *å•ä¸ªå­—èŠ‚çš„é«˜é˜¶å­—èŠ‚å°†è¢«å¿½ç•¥ã€‚
  */
  public void setStatus(int status) {
    this.status = (byte) status;
  }

  /**
   * Gets the current value of the status flags for this vertex.
   *
   * @return a positive integer in the range 0 to 255.
   */
  public int getStatus() {
    return ((int) status) & 0xff;
  }

  /**
   * Indicates whether a vertex is part of a constraint definition or
   * lies on the border of an area constraint.
   *
   * @return true if vertex is a constraint member; otherwise, false
   */
  public boolean isConstraintMember() {
    return (status & BIT_CONSTRAINT) != 0;
  }

  /**
   * Gets the auxiliary index for the vertex. The auxiliary index
   * field is one byte in size and supports integer values in the
   * range 0 to 255.  It is used to support graph-coloring algorithms
   * but is available for other uses as well.
   * @return  an integer value in the range 0 to 255
   */
  public int getAuxiliaryIndex() {
    return auxiliary;
  }

  /**
   * Sets the auxiliary index for the vertex. The auxiliary index
   * field is one byte in size and supports integer values in the
   * range 0 to 255.  It is used to support graph-coloring algorithms
   * but is available for other uses as well.
   * @param auxiliaryIndex a value in the range 0 to 255
   */
  public void setAuxiliaryIndex(int auxiliaryIndex) {
    if((auxiliaryIndex&0xffffff00)!=0){
      throw new IllegalArgumentException(
              "Color index out of valid range [0..255]");
    }
    this.auxiliary = (byte)(auxiliaryIndex&0xff);
  }

}
```



# äº”ã€æ–‡ç« 



## 2.2æ„å»ºä¸‰è§’ç½‘æ ¼çš„ç®—æ³•å’Œç»“æ„

### 2.2.1é€šè¿‡å¢é‡æ’å…¥æ„å»ºç½‘æ ¼

æ„é€ æœ€ä¼˜ä¸‰è§’ç½‘æ ¼æ˜¯è®¡ç®—å‡ ä½•ä¸­çš„ä¸€ä¸ªé‡è¦è¯¾é¢˜ï¼Œå·²è¢«å¹¿æ³›ç ”ç©¶ã€‚Suå’ŒDrysdaleï¼ˆ1996ï¼‰ç¡®å®šäº†ä¸‰å¤§ç±»ç”¨äºæ„å»ºä¸‰è§’ç½‘æ ¼çš„ç®—æ³•ï¼šåˆ†æ²»æ³•ã€æ‰«æ çº¿æ³•å’Œå¢é‡æ’å…¥æ³•ã€‚Tinfouråº“ä½¿ç”¨å¢é‡æ’å…¥ç®—æ³•ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨â€œå¼•å¯¼â€è¿‡ç¨‹åˆ›å»ºä¸€ä¸ªç”±ä¸‰ä¸ªé¡¶ç‚¹ç»„æˆçš„åˆå§‹ç½‘æ ¼ã€‚ä¸€æ—¦æ„å»ºäº†åˆå§‹ç½‘æ ¼ï¼Œå°±ä¼šä¸€æ¬¡å°†é¡¶ç‚¹æ·»åŠ åˆ°ä¸€ä¸ªç½‘æ ¼ä¸­ã€‚è¯¥è¿‡ç¨‹å¦‚ä¸‹å›¾8æ‰€ç¤ºã€‚é¡¶ç‚¹3å’Œ4å°†æ’å…¥åˆ°ç°æœ‰ç½‘æ ¼çš„å†…éƒ¨ã€‚é¡¶ç‚¹5å»¶ä¼¸ç½‘æ ¼ã€‚è¯·æ³¨æ„ï¼Œæ¯æ¬¡æ·»åŠ éƒ½ä¼šæ›´æ”¹ä¸‰è§’å½¢çš„ç»“æ„ï¼Œå¹¶æœ‰å¯èƒ½ç ´åå…ˆå‰å­˜åœ¨çš„è¾¹ï¼ˆçº¿æ®µï¼‰ã€‚ä¾‹å¦‚ï¼Œé¡¶ç‚¹4çš„æ’å…¥å…·æœ‰ç ´åè¾¹2-3å¹¶ç”¨æ–°è¾¹3-4å’Œ2-4æ›¿æ¢å®ƒçš„æ•ˆæœ

![image-20231221214112253](./assets/image-20231221214112253.png)

åœ¨æ„å»ºåŒ…å«å¤§é‡é¡¶ç‚¹çš„ä¸‰è§’ç½‘çš„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥æ„å»ºè¾¹ï¼Œç„¶åå¤šæ¬¡æ›¿æ¢è¾¹ã€‚ä½œä¸ºå®šæœŸå¤„ç†çš„ä¸€éƒ¨åˆ†ï¼ŒTinfourè·Ÿè¸ªæ›´æ¢æ“ä½œçš„æ•°é‡ã€‚åœ¨ä½¿ç”¨ç†Šå±±æ ·æœ¬çš„æ¿€å…‰é›·è¾¾æ•°æ®è¿›è¡Œæµ‹è¯•æ—¶ï¼Œå¹³å‡æ›´æ¢æ¬¡æ•°çº¦ä¸º6.5æ¬¡ï¼ˆå¯¹äºä¸€ç»„è¶…è¿‡300ä¸‡æ¡è¾¹ç¼˜ï¼‰ã€‚è¿™ä¸€ç»Ÿè®¡æ•°æ®è¡¨æ˜ï¼Œå¤„ç†è¾¹ç¼˜æ›¿æ¢çš„æœ‰æ•ˆæ–¹æ³•æ˜¯è®¾è®¡è‰¯å¥½TINå®ç°çš„å¿…è¦æ¡ä»¶ã€‚
Tinfouré€šè¿‡ä½¿ç”¨ç§°ä¸ºEdgePoolé›†åˆçš„å¯é‡ç”¨å¯¹è±¡æ± æ¥å®ç°è¿™ä¸€æ•ˆç‡ã€‚EdgePoolçš„ç‰ˆæœ¬ç•¥æœ‰ä¸åŒï¼Œç”¨äºæ ‡å‡†å’ŒåŠè™šæ‹Ÿå®ç°ã€‚ä¸Šå›¾è¿˜è¯´æ˜äº†TINçš„ä¸€ä¸ªæ˜¾è‘—ç‰¹å¾ã€‚ä¸‰è§’ç½‘çš„å‘¨é•¿å§‹ç»ˆæ˜¯ä¸€ä¸ªå‡¸å¤šè¾¹å½¢ã€‚

### 2.2.2å¾·åŠ³å†…ä¸‰è§’åˆ¨åˆ†

å¦‚ä¸Šæ‰€è¿°ï¼ŒTinfourå®ç°çš„åŸºæœ¬äº§å“æ˜¯Delaunayä¸‰è§’æµ‹é‡ã€‚Delaunayå‡†åˆ™è¦æ±‚æ„é€ ä¸‰è§’å½¢ç½‘æ ¼ï¼Œä½¿å¾—æ²¡æœ‰ç‚¹ä½äºä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ï¼Œè¯¥ç‚¹ä¸æ˜¯ä¸‰è§’å½¢çš„æˆå‘˜ã€‚åœ¨ä¸‹é¢å›¾9çš„å·¦ä¾§ï¼Œç‚¹Dä¸åœ¨ä¸‰è§’å½¢âˆ†ABCçš„å¤–æ¥åœ†å†…ï¼Œå› æ­¤ä¸‰è§’å½¢å¯¹âˆ†ABCå’Œâˆ†CBDæ»¡è¶³Delaunayå‡†åˆ™ã€‚å¦‚å³å›¾æ‰€ç¤ºï¼Œå¦‚æœç‚¹Dåœ¨å¤–æ¥åœ†å†…ï¼Œåˆ™éœ€è¦é€šè¿‡ç¿»è½¬è¾¹BCé‡æ–°ç»„ç»‡ä¸‰è§’æµ‹é‡ï¼Œä½¿å…¶è¿æ¥è¾¹ADï¼Œå½¢æˆä¸¤ä¸ªäº¤æ›¿çš„ä¸‰è§’å½¢âˆ†ABDå’Œâˆ†DCAã€‚è¯·æ³¨æ„ï¼Œåœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œæ€»æ˜¯ç»™å®šç‚¹ï¼Œä»¥ä¾¿å®ƒä»¬æŒ‰é€†æ—¶é’ˆé¡ºåºæŒ‡å®šä¸‰è§’å½¢çš„è¾¹ã€‚

æ¯æ¬¡å°†æ–°é¡¶ç‚¹æ’å…¥ä¸‰è§’å½¢ç½‘æ ¼æ—¶ï¼ŒTinfouréƒ½ä¼šæ ¹æ®éœ€è¦è°ƒæ•´å±€éƒ¨è¾¹ï¼Œä»¥ç¡®ä¿éµå®ˆæ ‡å‡†ã€‚å› æ­¤ï¼Œåœ¨æ–½å·¥çš„æ‰€æœ‰é˜¶æ®µï¼Œè½¯ä»¶éƒ½ä¼šç»´æŠ¤ä¸€ä¸ªé€‚å½“çš„Delaunayä¸‰è§’æµ‹é‡ã€‚

![image-20231221214410935](./assets/image-20231221214410935.png)

ç¨‹ï¼ˆ2013ï¼Œç¬¬57é¡µï¼‰æä¾›äº†ä¸€ç§è®¡ç®—æ–¹æ³•ï¼Œç”¨äºç¡®å®šç‚¹Dæ˜¯å¦ç”±åæ ‡ç»™å‡º
(ğ‘‘ğ‘¥, ğ‘‘ğ‘¦)ä½äºä¸‰è§’å½¢âˆ†ABCçš„å¤–æ¥åœ†å†…ï¼Œåæ ‡ä¸º(ğ‘ğ‘¥, ğ‘ğ‘¦) ,((ğ‘ğ‘¥, ğ‘ğ‘¦) ,ä»¥åŠ(ğ‘ğ‘¥, ğ‘ğ‘¦)
é€šè¿‡è¯„ä¼°ä»¥ä¸‹è¡Œåˆ—å¼ï¼š

![image-20231221214437759](./assets/image-20231221214437759.png)

å¦‚æœInCircleï¼ˆaï¼Œbï¼Œcï¼Œdï¼‰çš„å€¼å¤§äºé›¶ï¼Œåˆ™dä½äºâˆ†ABCçš„å¤–æ¥åœ†å†…ï¼Œå¹¶ä¸”è¿åDelaunayæ ‡å‡†ã€‚è¦æ¢å¤Delaunayå±æ€§ï¼Œæˆ‘ä»¬å¿…é¡»æ‰§è¡Œå¦‚ä¸Šæ‰€è¿°çš„è¾¹ç¼˜äº¤æ¢æ“ä½œã€‚å¦‚æœè¯¥å€¼å°äºé›¶ï¼Œåˆ™Dåœ¨å¤–æ¥åœ†ä¹‹å¤–ï¼Œå¹¶ä¸”æ»¡è¶³æ ‡å‡†ã€‚å¦‚æœè¯¥å€¼æ°å¥½ä¸ºé›¶ï¼Œåˆ™è¯¥ç‚¹ä½äºå¤–æ¥åœ†ä¸Šï¼Œå¹¶ä¸”æ ¹æ®Delaunayæ ‡å‡†ï¼Œä»»ä½•ä¸€ç§ç‚¹æ’åˆ—éƒ½æ˜¯å¯æ¥å—çš„ã€‚åœ¨è¿™ç§æ¨¡æ£±ä¸¤å¯çš„æƒ…å†µä¸‹ï¼Œå¿…é¡»é‡‡ç”¨å…¶ä»–ä¸€äº›æ ‡å‡†æ¥é€‰æ‹©é¦–é€‰ç»“æ„ã€‚

æ£€æŸ¥å›¾9ä¸­çš„å›¾çº¸æ—¶äº§ç”Ÿçš„ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œç‚¹Dæ˜¯å¦åœ¨âˆ†ABCçš„å¤–æ¥åœ†ä¹‹å¤–è¿™ä¸€äº‹å®æ˜¯å¦å‘Šè¯‰æˆ‘ä»¬ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šç‚¹Aåœ¨âˆ†CBDçš„å¤–æ¥ç¯ä¹‹å¤–ã€‚ç¨å¾®æ€è€ƒä¸€ä¸‹å°±ä¼šå‘ç°ï¼ŒInCircleï¼ˆcï¼Œbï¼Œdï¼ŒAï¼‰çš„è®¡ç®—ç›¸å½“äºå°†InCircleçš„è¡Œåˆ—å¼ä¸­çš„è¡Œäº¤æ¢å¶æ•°æ¬¡ï¼Œæ ¹æ®è¡Œåˆ—å¼çš„è¡Œæ€§è´¨ï¼Œè¿™å°†äº§ç”Ÿä¸åŸå§‹é¡ºåºç›¸åŒçš„å€¼ã€‚äº‹å®ä¸Šï¼Œä»»ä½•ä¿æŒä¸‰è§’å½¢é¡¶ç‚¹é€†æ—¶é’ˆæ’åºçš„è¡Œæ’åˆ—æ€»æ˜¯éœ€è¦å¶æ•°æ¬¡äº¤æ¢ã€‚å› æ­¤ï¼Œåªéœ€å¯¹ä¸€ä¸ªè¡Œåˆ—å¼è¿›è¡Œè¯„ä¼°ï¼Œå°±å¯ä»¥å†³å®šæ˜¯å¦éœ€è¦è¿›è¡Œè¾¹ç¼˜ç¿»è½¬è¿ç®—

### 2.2.3è¡¨ç¤ºå›¾çš„æ•°æ®åŸºå…ƒå’Œç»“æ„

ä¸‰è§’ç½‘æ ¼å¯ä»¥çœ‹ä½œç”±ä¸‰ä¸ªå‡ ä½•å›¾å…ƒç»„æˆï¼š

![image-20231221214632623](./assets/image-20231221214632623.png)

Delaunayè¡¨æ˜ï¼Œéšç€Delaunayä¸‰è§’æµ‹é‡ä¸­é¡¶ç‚¹æ•°é‡çš„å¢åŠ ï¼Œæ¯ç§ç‰¹å¾çš„æ•°é‡éƒ½æ¥è¿‘ä»¥ä¸‹å€¼ï¼š

![image-20231221214659807](./assets/image-20231221214659807.png)

â€‹       è¿™äº›å…³ç³»åœ¨æ•´ä¸ªä¸‰è§’ç½‘çš„æ‰€æœ‰è¶³å¤Ÿå¤§çš„å­åŒºåŸŸï¼ˆé è¿‘å¤–éƒ¨è¾¹ç•Œçš„åŒºåŸŸé™¤å¤–ï¼‰éƒ½ä¿æŒä¸å˜ã€‚
â€‹      å¯¹äºæ•°æ®é›†ä¸­çš„æ¯ä¸ªæ ·æœ¬ï¼Œæˆ‘ä»¬æ„é€ ä¸€ä¸ªé¡¶ç‚¹ã€‚åœ¨æ¿€å…‰é›·è¾¾è°ƒæŸ¥ç­‰æ•°æ®é›†ä¸­ï¼Œæ ·æœ¬æ•°é‡é€šå¸¸ä»¥ç™¾ä¸‡è®¡ï¼Œè¾¹ç¼˜å’Œé¡¶ç‚¹çš„æ•°é‡ä¹Ÿä¼šåŒæ ·å¤§ã€‚

### 2.2.4å››è¾¹å½¢æ•°æ®ç»“æ„

Tinfouråˆ›å»ºçš„ä¸‰è§’å½¢ç½‘æ ¼æ˜¯ç”±Guibaså’ŒStolfiåœ¨20ä¸–çºª80å¹´ä»£ä¸­æœŸæ¨å¹¿çš„å››è¾¹å½¢æ•°æ®ç»“æ„è¡¨ç¤ºçš„è¿æ¥è¾¹é›†åˆæ„å»ºçš„ï¼ˆGuibasï¼Œ1985ï¼Œç¬¬74é¡µï¼‰ã€‚å®ƒé€‚ç”¨äºæ„å»ºè®¸å¤šä¸åŒç±»åˆ«çš„åŸºäºå¤šè¾¹å½¢çš„å›¾ï¼ŒåŒ…æ‹¬Delaunayä¸‰è§’å›¾å’ŒVoronoiå›¾ã€‚

å››è¾¹å½¢ç»“æ„çš„å•ä¸ªå®ä¾‹ç”¨äºè¡¨ç¤ºç”±ä¸€å¯¹é¡¶ç‚¹å’Œ4æ¡ç›¸é‚»è¾¹çš„é“¾æ¥ç»„æˆçš„å•ä¸ªè¾¹ã€‚å¦‚ä¸‹å›¾10æ‰€ç¤ºï¼Œé¡¶ç‚¹Aå’ŒBå®šä¹‰äº†ä¸€ä¸ªçº¿æ®µABåŠå…¶â€œå¯¹å¶â€BAã€‚Tinfourä¸­çš„è¾¹æ€»æ˜¯è¢«è§†ä¸ºæœ‰æ–¹å‘ï¼Œæ¯æ¡è¾¹éƒ½æœ‰ç›¸åæ–¹å‘çš„å¯¹å¶ã€‚è¾¹çš„é“¾æ¥å–å†³äºå®ƒä»¬çš„æ–¹å‘ã€‚æ¥è‡ªABçš„æ­£å‘é“¾æ¥å°†ç”±é¡¶ç‚¹BRçš„ç¬¬äºŒä¸ªå››è¾¹å½¢è¾¹è¡¨ç¤ºã€‚æ¥è‡ªABçš„åå‘è¾¹å°†æ˜¯å››è¾¹å½¢è¾¹PAã€‚è¿™äº›å››è¾¹å½¢è¾¹åŠ åœ¨ä¸€èµ·å¯ä»¥ç”¨æ¥æŒ‡ç¤ºå¤šè¾¹å½¢çš„å­˜åœ¨ã€‚åœ¨ä¸‰è§’ç½‘ä¸­ï¼Œæ‰€æœ‰è¿™æ ·çš„å¤šè¾¹å½¢éƒ½æ˜¯ä¸‰è§’å½¢ï¼Œå¹¶ä¸”æ‰€æœ‰é“¾æ¥éƒ½è¢«å¡«å……ï¼Œå°½ç®¡è¿™ç§é™åˆ¶ä¸ä¸€å®šé€‚ç”¨äºå…¶ä»–ç±»å‹çš„å›¾ã€‚è¡¨1ä¸­ç»™å‡ºäº†è¾¹ç¼˜çš„é“¾æ¥ã€‚

```
æ•°æ®ç»“æ„åˆ†ä¸ºå››ä¸ªå±æ€§ 

         Edge Forward  Reverse  Dual
ä¾‹å¦‚ è¡¨ä¸­  AB   BR        PA      BA
          BA  AQ         SB     AB
 ä»¥ä¸Šä¸ºABåŠå…¶é¢†è¾¹çš„è®°å½•
```



![image-20231221221049575](./assets/image-20231221221049575.png)

ä¸¤ä¸ªç›¸é‚»çš„ä¸‰è§’å½¢å¦‚ä¸‹å›¾11æ‰€ç¤º

![image-20231221221211039](./assets/image-20231221221211039.png)

Tinfourä¸­çš„ç½‘æ ¼è¡¨ç¤ºä¸ä¼šå°†ä¸‰è§’å½¢æŒ‡å®šä¸ºæ˜¾å¼å¯¹è±¡ã€‚ä¸‰è§’å½¢æ˜¯ç”±ä¸ç½‘æ ¼é›†åˆä¸­çš„è¾¹é›†å…³è”çš„é“¾æ¥æ‰€æš—ç¤ºçš„ã€‚è¡¨ç¤ºé¡¶ç‚¹çš„æ•°æ®å¯¹è±¡ä¸æºå¸¦ä»»ä½•å°†é¡¶ç‚¹æ˜ç¡®åœ°ç»‘å®šåˆ°è¾¹çš„ä¿¡æ¯ã€‚è¾¹çŸ¥é“é¡¶ç‚¹ï¼Œé¡¶ç‚¹ä¸çŸ¥é“è¾¹ã€‚å› æ­¤ï¼Œä½¿ç”¨Tinfourçš„è½¯ä»¶å¯ä»¥å°†é¡¶ç‚¹å®šä¹‰ä¸ºä¸å¯å˜å¯¹è±¡ï¼Œæˆ–è€…ç®€å•åœ°å°†å®ƒä»¬ä¼ é€’åˆ°åº“ä¸­ï¼Œè€Œä¸ç”¨æ‹…å¿ƒå®ƒä»¬ä¼šè¢«æ›´æ”¹ã€‚

### 2.2.5 Ghost Vertexå’Œå¼•å¯¼ç¨‹åºå¸ƒå±€ï¼ˆBootstrapå¸ƒå±€ï¼‰

å› ä¸ºå‰é¢çš„ä¸¤ä¸ªä¾‹å­éƒ½åªæ˜¯ç½‘æ ¼çš„ç‰‡æ®µï¼Œæ‰€ä»¥æœ‰äº›é“¾æ¥ä¸æ˜¯è®°å½•ã€‚ä½¿ç”¨å››è¾¹å½¢ç»“æ„æ„å»ºä¸‰è§’å½¢ç½‘æ ¼çš„ä¸€ä¸ªå…³é”®å› ç´ æ˜¯è§„å®šå¡«å……ç»“æ„ä¸­çš„æ¯ä¸ªé“¾æ¥ã€‚è¿™æ ·åšç®€åŒ–äº†è®¸å¤šç¼–ç é—®é¢˜ï¼Œä½†æ˜¯ç¡®å®éœ€è¦ç‰¹æ®Šçš„é€»è¾‘æ¥å¤„ç†ä½äºç½‘æ ¼å‘¨è¾¹ä¸Šçš„è¾¹ã€‚

æœ‰ä¸åŒçš„ç­–ç•¥æ¥é¿å…æˆ–ä»¥å…¶ä»–æ–¹å¼ç®¡ç†ä¸åŒä¸‰è§’å½¢ç½‘æ ¼ä¸­çš„é›¶é“¾æ¥Tinfourä¾èµ–äºä¸€ä¸ªè¢«ç§°ä¸ºâ€œé‡å½±é¡¶ç‚¹â€çš„æ¦‚å¿µï¼ˆChengï¼Œ2013ï¼Œç¬¬61é¡µï¼‰ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªç®€å•çš„ä¸‰è§’å½¢ç½‘æ ¼åŒ…å«ä¸€ä¸ªå…·æœ‰ä¸‰æ¡å‘¨é•¿è¾¹çš„ä¸‰è§’å½¢ã€‚å¡«å……å¯¹äºè¿™äº›è¾¹çš„é›¶é“¾æ¥ï¼ŒTinfouræŒ‡å®šè™šç‚¹ã€é‡å½±é¡¶ç‚¹çš„å­˜åœ¨ï¼Œå…¶è¿æ¥åˆ°TINçš„å‘¨è¾¹ä¸Šçš„æ¯ä¸ªé¡¶ç‚¹ã€‚é€šè¿‡è¿™æ ·åšï¼Œå®ƒç¡®ä¿äº†å‘¨è¾¹çš„åå‘é“¾æ¥éƒ½å·²å¡«å……ã€‚æŸäº›å®ç°ä¸ºé‡å½±ç‚¹æä¾›äº†é€šè¿‡æƒ³è±¡å®ƒå­˜åœ¨äºæ¯”å…¶ä»–æ‰€æœ‰ç»´åº¦æ›´é«˜çš„ç»´åº¦æ¥å®ç°å®é™…çš„å‡ ä½•è§„èŒƒç½‘æ ¼ä¸­çš„ç‚¹ã€‚ä¾‹å¦‚åœ¨å¹³é¢ä¸Šç»„ç»‡çš„ä¸€ç»„åæ ‡çš„2Dä¸‰è§’å½¢ç½‘æ ¼ä¸­ï¼Œé‡å½±ç‚¹å¯ä»¥è¢«è§†ä¸ºå­˜åœ¨äºç¬¬ä¸‰ç»´åº¦ä¸­ï¼Œé«˜äºé£æœºTinfouråšäº†ä¸€äº›ä¸åŒçš„äº‹æƒ…ï¼Œå°†é‡å½±é¡¶ç‚¹å®ç°ä¸ºnullå¯¹è±¡å‚è€ƒã€‚

ä¸‹é¢çš„å›¾12è¯´æ˜äº†åŒ…å«ä¸‰ä¸ªç‚¹çš„ç½‘æ ¼çš„é“¾æ¥ï¼Œå› ä¸ºå®ƒå°†åœ¨åˆå§‹å¼•å¯¼æ“ä½œã€‚åœ¨å›¾ä¸­ï¼Œå®çº¿æ˜¯å®é™…çš„è¾¹ï¼Œè€Œè™šçº¿è¡¨ç¤ºè¿æ¥å’Œç®­å¤´æŒ‡ç¤ºé“¾æ¥æ–¹å‘ã€‚ç½‘æ ¼ç”±ä¸‰ä¸ªå®é™…é¡¶ç‚¹ç»„æˆâ€”â€”Aã€Bå’ŒCâ€”â€”ä»¥åŠå•ä¸ªé‡å½±é¡¶ç‚¹ã€‚å°½ç®¡å›¾ä¸­çš„é‡å½±é¡¶ç‚¹æ˜¾ç¤ºåœ¨ä¸‰ä¸ªä½ç½®ï¼Œä½†å®ƒæ˜¯å•ä¸ªå®ä½“ï¼Œå› æ­¤ï¼Œæ€»æ˜¯æ ‡è®°ä¸ºgã€‚

é™¤äº†ç¡®ä¿æ²¡æœ‰è¾¹å…·æœ‰ç©ºé“¾æ¥å¤–ï¼Œå¼•å¯¼æ“ä½œè¿˜å»ºç«‹å‡ ä½•å°†åœ¨æ‰€æœ‰åç»­ç‚¹æ’å…¥ä¸­ç»´æŠ¤çš„å…³ç³»ã€‚ç‰¹åˆ«æ˜¯å‰å‘é“¾è·¯å¯¹äºä¸‰è§’å½¢çš„å†…è¾¹ç¼˜âˆ†ABCï¼Œå»ºç«‹ä¸‰è§’å½¢çš„é€†æ—¶é’ˆæ’åºã€‚TinfouræŒ‰é€†æ—¶é’ˆé¡ºåºä¿æŒä¸‰è§’ç½‘å†…éƒ¨çš„æ‰€æœ‰ä¸‰è§’å½¢ã€‚è€Œå¤–éƒ¨é“¾æ¥å…·æœ‰æ²¡æœ‰çœŸæ­£çš„å‡ ä½•ä½“ï¼ˆå› ä¸ºé‡å½±ç‚¹ä¸ºç©ºï¼‰ï¼ŒåŸºäºå®ƒæ‰€åŒ…æ‹¬çš„å‘¨è¾¹çš„æ–¹å‘ã€‚

![image-20231221222234907](./assets/image-20231221222234907.png)

### 2.2.6ç½‘æ ¼ä¸­çš„è¾¹ç¼˜éå†å’Œå¯¼èˆª

Tinfouråº“ä¸­çš„è®¸å¤šæ“ä½œéƒ½æ¶‰åŠä»ä¸€æ¡è¾¹åˆ°ç›¸é‚»è¾¹çš„æŸç§éå†ã€‚å¯¹äºä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ªèµ·å§‹è¾¹ï¼Œå°±å¯ä»¥é€šè¿‡åœ¨å‰å‘é“¾æ¥ä¸Šç§»åŠ¨æ¥æ„å»ºä¸€ä¸ªä¸‰è§’å½¢ç›´åˆ°éå†è¿”å›åˆ°åŸå§‹è¾¹ã€‚ä¸‹é¢çš„å›¾13æ˜¾ç¤ºäº†ä»ä¸€å¼€å§‹çš„éå†è¾¹ç¼˜eåˆ°å…¶é™„è¿‘çš„è¾¹ç¼˜ã€‚

![image-20231221222308305](./assets/image-20231221222308305.png)

**(è¡¨ä¸­nåº”è¯¥æ˜¯CB)**

å¦‚ä¸Šæ‰€è¿°ï¼ŒTinfourä¿æŒé“¾æ¥ï¼Œä»¥ä¾¿å½¢æˆç½‘æ ¼çš„æ‰€æœ‰ä¸‰è§’å½¢éƒ½åœ¨æ­£å‘éå†ä¸‹çš„é€†æ—¶é’ˆé¡ºåºã€‚æ‰€ä»¥åé¢ä¸‰ä¸ªgetForwardï¼ˆï¼‰çš„ç»“æœè¿ç®—äº§ç”Ÿä¸€ä¸ªå®Œæ•´çš„ä¸‰è§’å½¢å¾ªç¯ã€‚

ä½œä¸ºè¾¹ç¼˜éå†çš„æœ€åä¸€ä¸ªç¤ºä¾‹ï¼Œä¸‹é¢çš„Javaä»£ç ç‰‡æ®µæ˜¾ç¤ºäº†ä¸€ä¸ªæ“ä½œç»°å·â€œé£è½¦â€ã€‚

è¯¥ä»£ç æ”¶é›†è¿æ¥åˆ°ä¸­å¿ƒçš„æ‰€æœ‰é¡¶ç‚¹çš„åˆ—è¡¨é€šè¿‡ä¸€ç»„è¿æ¥è¾¹â€œå›ºå®šâ€é¡¶ç‚¹ã€‚åœ¨è¡ŒåŠ¨å¼€å§‹æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªä¼˜åŠ¿ä»é”šç‚¹é¡¶ç‚¹Aå¼€å§‹ã€‚è¯¥è¾¹çš„getAï¼ˆï¼‰æ–¹æ³•å°†è·å¾—é”šç‚¹é¡¶ç‚¹ã€‚è¿™ä¸ªgetBï¼ˆï¼‰æ–¹æ³•è·å–è¾¹å¦ä¸€ç«¯çš„é¡¶ç‚¹ã€‚åœ¨æ¥ä¸‹æ¥çš„å¾ªç¯ä¸­getDualFromReverseï¼ˆï¼‰æ–¹æ³•ç”¨äºéå†è¿æ¥åˆ°é”šç‚¹çš„è¾¹ï¼Œä»¥ä¾¿å¯ä»¥æå–ç›¸é‚»é¡¶ç‚¹å¹¶å°†å…¶æ·»åŠ åˆ°ç»“æœåˆ—è¡¨ä¸­ã€‚æ”¶é›†å·¥ä½œåœ¨ä»¥ä¸‹æƒ…å†µä¸‹ç»ˆæ­¢éå†å›´ç»•é”šç‚¹é¡¶ç‚¹è¿›è¡Œä¸€ä¸ªå®Œæ•´çš„å¾ªç¯ï¼Œå¹¶åˆ°è¾¾åˆå§‹è¾¹ã€‚

```
IQuadEdge e; // given e starts with vertex A
ArrayList<Vertex> result = new ArrayList<>(); // a vertex collection
IQuadEdge cursor = e;
do{
 Vertex b = cursor.getB();
 result.add(b);
 cursor = cursor.getDualFromReverse();
}while(!cursor.equals(e));

```

åœ¨Tinfourå¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬é‡åˆ°äº†è®¸å¤šç½‘æ ¼å¤„ç†åº”ç”¨ç¨‹åºï¼Œéœ€è¦åƒé£è½¦ä¸€æ ·çš„æ“ä½œï¼Œæˆ‘ä»¬æ·»åŠ äº†ä¸€ä¸ªæ–¹ä¾¿åŠŸèƒ½æ¥ç®€åŒ–å®ƒçš„ä½¿ç”¨ã€‚ç»™å®šä¸€ä¸ªèµ·å§‹è¾¹ç¼˜eã€ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç å®ç°ä¸ä¸Šé¢æ‰€ç¤ºç›¸åŒçš„ç»“æœï¼š

```
for(IQuadEdge cursor: e.pinwheel()){
result.add(cursor.getB();
} 
```

### 2.2.7å››è¾¹å½¢ç»“æ„åœ¨ä»£ç ä¸­çš„å®ç°

â€‹        å½“æˆ‘ä»¬è€ƒè™‘è¾¹ç¼˜éå†åº”ç”¨ç¨‹åºçš„å®é™…é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬ç»å¸¸å‘ç°å¯¼èˆªä¸‰è§’å½¢ç½‘æ ¼çš„ä»£ç éœ€è¦äº†è§£è¾¹ç¼˜ éå†çš„æ–¹å‘ã€‚åœ¨å›¾è®ºä¸­ï¼Œä¸‰è§’ç½‘æ ¼æ˜¯æ— å‘å›¾ã€‚ä½†å‡ºäºè½¯ä»¶ç›®çš„ï¼Œä¸ºå„ä¸ªè¾¹ç¼˜æä¾›æ–¹å‘æ„Ÿæ˜¯å¾ˆæœ‰ç”¨ çš„ã€‚å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ Java å¯¹è±¡è¡¨ç¤ºè¾¹ï¼Œé‚£ä¹ˆæœ‰å…³æ–¹å‘çš„ä¿¡æ¯å¿…é¡»æ˜¯ Java ç±»è®¾è®¡çš„ä¸€ éƒ¨åˆ†ã€‚ Tinfour é€šè¿‡å°†æ¯æ¡è¾¹å®ç°ä¸ºä¸€å¯¹é“¾æ¥å¯¹è±¡æ¥æ»¡è¶³è¿™ä¸€è¦æ±‚ï¼Œæ¯ä¸ªé“¾æ¥å¯¹è±¡å¯¹åº”ä¸€ä¸ªéå† æ–¹å‘ã€‚å®é™…ä¸Šï¼Œå®ƒå°†å››è¾¹ç»“æ„åˆ†æˆä¸¤éƒ¨åˆ†ã€‚æ¯ä¸ªéƒ¨åˆ†éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„ Java å¯¹è±¡ã€‚æ¯ä»¶ä½œå“éƒ½æœ‰ å…¶å¯¹å¶çš„å‚è€ƒã€‚ä¸¤ä¸ªéƒ¨åˆ†åŒæ—¶å®ä¾‹åŒ–ï¼Œå¹¶é€šè¿‡è®¾ç½®å¯¹å…¶å¯¹åº”éƒ¨åˆ†çš„åŒé‡å¼•ç”¨å°†å…¶è”ç³»åœ¨ä¸€èµ·ã€‚ 

â€‹      è¾¹ç¼˜è¡¨ç¤ºçš„ä¸»ç±»åä¸º QuadEdgeã€‚ QuadEdge çš„æ¯ä¸ªå®ä¾‹éƒ½ä¼´éšæœ‰æ¥è‡ª QuadEdgePartner ç±»çš„ä¼´ ç”Ÿå¯¹è±¡ï¼Œè¯¥ç±»æ´¾ç”Ÿè‡ª QuadEdgeã€‚å› æ­¤ï¼ŒTIN ä¸­çš„æ¯æ¡è¾¹éƒ½æœ‰ä¸¤ä¸ªå…³è”çš„å¯¹è±¡ã€‚ç”±äºä¸º Delaunay  ä¸‰è§’å‰–åˆ†ä¸­çš„æ¯ä¸ªé¡¶ç‚¹æ„å»ºäº†å¤§çº¦ 3 ä¸ªè¾¹å¯¹ï¼Œå¹¶ä¸”æ•°æ®æ ·æœ¬ä¸­çš„é¡¶ç‚¹æ•°é‡å¯èƒ½è¾¾åˆ°æ•°ç™¾ä¸‡ï¼Œå› æ­¤ å®Œå…¨å¡«å……çš„ TIN ä¸­çš„å¯¹è±¡å®ä¾‹æ•°é‡å¯èƒ½ä¼šå˜å¾—ç›¸å½“å¤§ã€‚

å› æ­¤ï¼Œç´§å‡‘çš„ç±»è®¾è®¡å¯¹äºèŠ‚çœå†…å­˜è‡³å…³é‡è¦ã€‚ä¾‹å¦‚ï¼Œä¸¤ä¸ªé¡¶ç‚¹å®šä¹‰çº¿æ®µï¼Œå› æ­¤æ¯æ¡è¾¹éƒ½éœ€è¦å¼•ç”¨ä¸¤ä¸ªé¡¶ç‚¹å¯¹è±¡ã€‚ä½†æ˜¯QuadEdgeå®ç°ä»…å®ç°ä¸€ä¸ªã€‚ç”±äºQuadEdgeå¯¹è±¡æ€»æ˜¯ä¸QuadEdgePartnerå¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡åªéœ€è¦æºå¸¦ä¸€ä¸ªå¼•ç”¨ã€‚ç¬¬äºŒä¸ªé¡¶ç‚¹å¼•ç”¨å› ä¸ºè¯¥å¯¹çš„ä»»ä¸€ä¾§æ€»æ˜¯å¯ä»¥ä»å…¶å¯¹åº”ç‰©è·å¾—ã€‚

åœ¨HotSpotè™šæ‹Ÿæœºä¸‹è¿è¡Œæ—¶ï¼ŒQuadEdgeå¯¹è±¡çš„æ¯ä¸ªå®ä¾‹éƒ½éœ€è¦32ä¸ªå­—èŠ‚ä½¿ç”¨å‹ç¼©å¼•ç”¨é€‰é¡¹ã€‚QuadEdgePartnerä¹Ÿéœ€è¦åŒæ ·çš„åŠŸèƒ½ã€‚è¡¨5æ˜¾ç¤ºäº†å¸ƒå±€ç±»ä¸­å…ƒç´ çš„ã€‚å› ä¸ºæ¯æ¡è¾¹éœ€è¦ä¸€å¯¹å¯¹è±¡ï¼Œæ¯æ¡è¾¹éœ€è¦2Ã—32=64å­—èŠ‚çš„å†…å­˜ã€‚ç”±äºæ¯ä¸ªé¡¶ç‚¹æœ‰3ä¸ªè¾¹å¯¹ï¼Œå› æ­¤æ¯ä¸ªé¡¶ç‚¹çš„æ€»å†…å­˜ç”¨äºQuadEdgeè¡¨ç¤ºä¸º3Ã—64=196å­—èŠ‚ã€‚Vertexç±»æœ¬èº«çš„å®ä¾‹éœ€è¦40ä¸ªå­—èŠ‚ã€‚æ‰€ä»¥æ¯ä¸ªæ•°æ®æ ·æœ¬ï¼ˆåŒ…æ‹¬è¾¹å’Œé¡¶ç‚¹ï¼‰çš„å¹³å‡å†…å­˜ä½¿ç”¨é‡ä¸º196+40=226å­—èŠ‚ã€‚JVMå†…å­˜ç®¡ç†å¸¦æ¥çš„é¢å¤–å¼€é”€å°†è¯¥å€¼æé«˜åˆ°ä¸­å¼•ç”¨çš„246å­—èŠ‚ç¬¬2.1æ®µæ€§èƒ½å’Œè®°å¿†ã€‚

![image-20231221222549303](./assets/image-20231221222549303.png)

### 2.2.8 Vertex Insertion Processï¼ˆé‡è¦ ç®—æ³•è¿‡ç¨‹ï¼‰

Tinfour ä½¿ç”¨åŸºäº Bowyer (1981) å’Œ Watson (1981) ä¸¤ç¯‡è‘—åè®ºæ–‡çš„ç®—æ³•å°†é¡¶ç‚¹æ’å…¥ç½‘æ ¼ä¸­ã€‚ è¿™äº›è®ºæ–‡ä¹‹æ‰€ä»¥å‡ºåï¼Œæ˜¯å› ä¸ºå®ƒä»¬å‡ ä¹åœ¨åŒä¸€æ—¶é—´æäº¤ç»™åŒä¸€æœŸåˆŠï¼Œå¹¶ä¸”éƒ½æå‡ºäº†é‡è¦ä¸”å¯†åˆ‡ç›¸ å…³çš„ç»“æœã€‚å½“ã€Šè®¡ç®—æœºæ‚å¿—ã€‹çš„ç¼–è¾‘æ”¶åˆ°è¿™ä¸¤ç¯‡è®ºæ–‡æ—¶ï¼Œä»–ä»¬é€‰æ‹©åœ¨åŒä¸€æœŸå¹¶åˆ—å‘è¡¨å®ƒä»¬ã€‚ ä½œä¸ºä»‹ç»ï¼Œæˆ‘å°†ç”¨ä¸€ç§æ›´æ—©ä¸”æ›´ç®€å•çš„æŠ€æœ¯æ¥è®¨è®º Bowyer-Watson ç®—æ³•ï¼Œä»¥è¯´æ˜å…¶ä¸€äº›åŸºæœ¬åŸ ç†ã€‚ Lawson (1977) æè¿°çš„è¾¹ç¼˜ç¿»è½¬ç®—æ³•å®é™…ä¸Šæ˜¯ Tinfour å®ç°çš„ç¬¬ä¸€ä¸ªç®—æ³•ã€‚å®ƒå…·æœ‰ä»£ç ç´§ å‡‘ä¸”æ˜“äºç†è§£çš„å¸å¼•åŠ›ã€‚ç„¶è€Œï¼Œå½“ç”¨ Bowyer-Watson æ–¹æ³•å–ä»£å®ƒæ—¶ï¼Œæ„å»º TIN æ‰€éœ€çš„æ—¶é—´å‡å°‘ äº† 50%ã€‚

#### 2.2.8.1 Simple Insertion with Edge Flippingï¼ˆé€šè¿‡è¾¹ç¼˜ç¿»è½¬è¿›è¡Œç®€å•æ’å…¥ï¼‰

Lawson çš„åŸå§‹ç®—æ³•ä½¿ç”¨ç®€å•çš„æ’å…¥è¿‡ç¨‹åˆ›å»º Delaunay ç½‘æ ¼ã€‚ä»ä¸‰ä¸ªç‚¹çš„åˆå§‹ç½‘æ ¼ï¼ˆTinfour  ç§°ä¹‹ä¸ºâ€œå¼•å¯¼ç½‘æ ¼â€ï¼‰å¼€å§‹ï¼Œè¯¥ç®—æ³•ä½¿ç”¨ä»¥ä¸‹æ­¥éª¤æ’å…¥æ¯ä¸ªé¡¶ç‚¹ï¼š 

1.æ‰¾åˆ°åŒ…å«çš„ä¸‰è§’å½¢ã€‚ 

2.é€šè¿‡å°†é¡¶ç‚¹é“¾æ¥åˆ°ç°æœ‰ä¸‰è§’å½¢ä¸­çš„æ¯ä¸ªé¡¶ç‚¹ï¼Œå°†é¡¶ç‚¹æ’å…¥ä¸‰è§’å½¢ä¸­ã€‚ 

3.æ ¹æ®éœ€è¦é€’å½’â€œç¿»è½¬â€è¾¹ä»¥æ¢å¤ Delaunay å±æ€§ã€‚

Lawsonæ–¹æ³•çš„å…³é”®æ˜¯ç¬¬ä¸‰æ­¥ã€‚



å½“å°†é¡¶ç‚¹æ’å…¥åˆ°åŒ…å«ä¸‰è§’å½¢ä¸­æ—¶ï¼Œä»»ä½•æˆ–æ‰€æœ‰ç”Ÿæˆçš„ä¸‰è§’å½¢éƒ½å¯èƒ½æ˜¯ é Delaunay çš„ã€‚å¦‚æœä¸è¿›è¡ŒæŸç§æ ¡æ­£ï¼Œç»“æœå°†é€æ¸å…·æœ‰ä¸ä¸Šé¢å›¾ 1 ä¸­ç»™å‡ºçš„é Delaunay ç½‘ æ ¼ä¸ Delaunay ä¸‰è§’å‰–åˆ†ç¤ºä¾‹ç›¸åŒçš„æ¬¡ä¼˜å¤–è§‚ã€‚åŠ³æ£®é€šè¿‡æµ‹è¯•æ¯æ¡æ–°è¾¹æ¥æŸ¥çœ‹å…¶ç›¸å¯¹è¾¹ä¸Šçš„ä¸‰è§’ å½¢æ˜¯å¦æ»¡è¶³å¾·åŠ³å†…æ ‡å‡†ï¼Œä»è€Œæ¢å¤äº†å¾·åŠ³å†…æ€§è´¨ã€‚å¦‚æœæ²¡æœ‰ï¼Œè¾¹ç¼˜å°†è¢«â€œç¿»è½¬â€ï¼Œä»è€Œäº§ç”Ÿä¸€ç»„å¤‡ ç”¨ä¸‰è§’å½¢ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º

![image-20240117202723160](./assets/image-20240117202723160.png)

ä¸å¹¸çš„æ˜¯ï¼Œå½“â€œéå¾·åŠ³å†…â€è¾¹è¢«ç¿»è½¬æ—¶ï¼Œæ¢å¤å¾·åŠ³å†…æœ€ä¼˜æ€§çš„å·¥ä½œä¸ä¸€å®šå®Œæˆã€‚å½“æ’å…¥ç‚¹ä½äºç´§é‚» ä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…æ—¶ï¼Œå®ƒä¹Ÿå¯èƒ½ä½äºä¸é‚»å±…ç›¸é‚»çš„ä¸€ä¸ªæˆ–å¤šä¸ªä¸‰è§’å½¢çš„å¤–æ¥åœ†å†…ã€‚å› æ­¤ï¼Œå½“æ’å…¥ é€»è¾‘æ£€æµ‹åˆ°é Delaunay ä¸‰è§’å½¢æ—¶ï¼Œå®ƒå¿…é¡»é€’å½’æœç´¢â€œé‚»å±…çš„é‚»å±…â€ï¼Œå¯»æ‰¾éœ€è¦ç¿»è½¬çš„é™„åŠ è¾¹ä»¥æ¢ å¤ Delaunay æœ€ä¼˜æ€§ã€‚å¹¸è¿çš„æ˜¯ï¼Œå½“æœç´¢é‡åˆ°â€œDelaunay è¾¹â€ï¼ˆä¸éœ€è¦ç¿»è½¬çš„è¾¹ï¼‰æ—¶ï¼Œä¸éœ€è¦ç»§ç»­è¶…å‡ºè¯¥ç‚¹ã€‚å¦å¤–ï¼Œå¦‚æœæœç´¢é‡åˆ°å‘¨ç•Œè¾¹ç¼˜ï¼Œåˆ™æ— éœ€ç»§ç»­è¿›ä¸€æ­¥ã€‚å› æ­¤é€’å½’æœç´¢å°†å§‹ç»ˆç»ˆæ­¢ å³ä½¿ä¿è¯ç»ˆæ­¢	ï¼Œé€’å½’æœç´¢ä¹Ÿå¯èƒ½å‘å¤–è¾å°„å¹¶å½±å“ç›¸é‚»ä¸‰è§’å½¢çš„å‡ å±‚ã€‚æœ‰å‡ å±‚ï¼Ÿç†è®ºä¸Šï¼Œæ’å…¥å¯ä»¥ å½±å“æ•´ä¸ª TINã€‚åœ¨å¤„ç†ç†Šå±±æ ·æœ¬æ—¶ï¼Œæ—©æœŸçš„å®ç°é‡åˆ°äº†ç¿»è½¬æ“ä½œå‘å¤–è¾å°„åˆ°å‘¨å›´43å±‚ä¸‰è§’å½¢çš„æƒ… å†µã€‚åœ¨å®è·µä¸­ï¼ŒDelaunay ç‰¹æ€§çš„æ¢å¤é€šå¸¸æ¶‰åŠä¸è¶…è¿‡ä¸¤å±‚ï¼ˆæˆ–å…­æ¡è¾¹ï¼‰ã€‚å³ä¾¿å¦‚æ­¤ï¼Œä¸æµ‹è¯•å’Œä¿® æ”¹è¾¹ç¼˜é“¾æ¥ç›¸å…³çš„å¼€é”€è¶³ä»¥ä¿è¯é‡‡ç”¨æ›¿ä»£æ–¹æ³•ã€‚

#### 2.2.8.2 Improved Performance using the Bowyer-Watson Algorithmï¼ˆï¼ˆé‡è¦ï¼ï¼ï¼2ã€ç¡®è®¤ä¸‰è§’å½¢åæ’å…¥æ“ä½œï¼‰

 ä½¿ç”¨ Bowyer-Watson ç®—æ³•æé«˜æ€§èƒ½ã€‚

ä½¿ç”¨ Bowyer-Watson ç®—æ³•æ’å…¥é¡¶ç‚¹åˆ† 4 ä¸ªé˜¶æ®µè¿›è¡Œï¼Œå¦‚å›¾æ‰€ç¤ºå¦‚ä¸‹å›¾ 15ã€‚ ä¸€æ—¦æ‰¾åˆ°åŒ…å«ä¸‰è§’å½¢ï¼Œè¯¥è¿‡ç¨‹å°±ä¼šé€šè¿‡åˆ é™¤é Delaunay è¾¹åœ¨ TIN ä¸­åˆ›å»ºç©ºè…”ã€‚ç„¶åå®ƒå°†æ’å…¥é¡¶ç‚¹è¿æ¥åˆ°ç©ºè…”çš„å†…è¾¹ç¼˜ï¼Œæ¢å¤ä¸‰è§’å½¢ç½‘æ ¼ã€‚ Bowyer å’ŒWatson çš„è®ºæ–‡è¡¨æ˜ï¼Œç”Ÿæˆçš„ç½‘æ ¼æ˜¯ Delaunay æœ€ä¼˜çš„ã€‚

![image-20240117202922234](./assets/image-20240117202922234.png)

ä½œä¸ºè¿›ä¸€æ­¥çš„æ”¹è¿›ï¼ŒTinfour å°†å‹è…”åˆ›å»ºå’Œé“¾æ¥è¿æ¥æ­¥éª¤åˆå¹¶åˆ°å•ä¸ªæ“ä½œä¸­ã€‚è¿™æ ·åšå¯ä»¥å‡å°‘å¿…é¡»é‡æ–°åˆ†é…è¾¹ç¼˜é“¾æ¥çš„æ¬¡æ•°ï¼Œä»è€Œæé«˜æ’å…¥ä¾‹ç¨‹çš„æ€§èƒ½ã€‚ç„¶è€Œï¼Œå®ƒç¡®å®ä½¿ä»£ç å˜å¾—å¤æ‚ã€‚ä¸ºäº†æ¸…æ¥šèµ·è§ï¼Œè¿™äº›æ³¨é‡Šå°†æ’å…¥ç®—æ³•æè¿°ä¸ºå•ç‹¬çš„æ­¥éª¤ã€‚å¯¹å®é™…å®ç°ç»†èŠ‚æ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥æŸ¥çœ‹ IncrementalTin ç±»ä¸­ **addWithInsertOrAppend()** æ–¹æ³•çš„æºä»£ç ã€‚ é¡ºä¾¿æåŠï¼Œæœ¯è¯­â€œé¡¶ç‚¹æ’å…¥â€ä¹Ÿç”¨äºæè¿°è¦æ·»åŠ çš„é¡¶ç‚¹ä½äºTINä¹‹å¤–çš„æƒ…å†µã€‚ Cheng (2013) è¯¦ç»†ä»‹ç»äº†å¦‚ä½•é€šè¿‡å¯¹ä¸‹è¿°æ•´ä½“é€»è¾‘è¿›è¡Œå¾®å°æ”¹åŠ¨æ¥å¤„ç†â€œå¹½çµä¸‰è§’å½¢â€ï¼ˆåŒ…æ‹¬å‘¨è¾¹è¾¹ç¼˜å’Œå¹½çµé¡¶ç‚¹ï¼‰ ï¼ˆç¬¬ 59 é¡µï¼‰

#### 2.2.8.3 Overview of Bowyer-Watson insertion ã€‚  Bowyer-Watson æ’å…¥æ¦‚è¿°

ä¸€æ—¦å¼•å¯¼æ“ä½œå®Œæˆå¹¶ä¸”åˆå§‹ä¸‰è§’ç½‘æ ¼å¯ç”¨ï¼ŒBowyerWatson ç®—æ³•å°†ä½¿ç”¨ä»¥ä¸‹æ­¥éª¤å°†é¡¶ç‚¹æ’å…¥ç½‘æ ¼ä¸­ï¼š 

1. ä½ç½®ï¼šå¯¹äºè¦æ’å…¥çš„æ¯ä¸ªé¡¶ç‚¹ï¼Œç¡®å®šåŒ…å›´çš„ä¸‰è§’å½¢ã€‚å¦‚æœç‚¹ä½äº TIN å¤–éƒ¨ï¼Œåˆ™å®šä½å¹»å½±ä¸‰è§’å½¢ï¼Œä½¿ä¸‰è§’å½¢çš„å‘¨è¾¹æœ€æ¥è¿‘æ’å…¥ç‚¹ã€‚ 
2. å”¯ä¸€æ€§ï¼šæ ¹æ®å®šä¹‰ï¼ŒTIN ä¸­çš„æ¯ä¸ªç‚¹éƒ½å¿…é¡»**å…·æœ‰å”¯ä¸€çš„æ°´å¹³åæ ‡**ã€‚å°†é¡¶ç‚¹æ·»åŠ åˆ° Tinfour æ—¶ï¼Œå®ƒä¼šæ ¹æ®å°é—­ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹æ¥æµ‹è¯•æ’å…¥é¡¶ç‚¹ï¼Œä»¥ç¡®å®šæ˜¯å¦ä¸åŒã€‚å¦‚æœæ’å…¥ç‚¹ä¸å”¯ä¸€ï¼Œåˆ™ä¸ä¼šå°†å…¶æ·»åŠ åˆ° TIN ä¸­ã€‚ç›¸åï¼Œå®ƒä¸â€œé¡¶ç‚¹ç»„â€ä¸­é¢„å…ˆå­˜åœ¨çš„é¡¶ç‚¹ç»“åˆã€‚ **TIN çš„ç»“æ„æœªæ›´æ”¹ã€‚** 
3.  æ’å…¥ï¼šå¦‚æœæ’å…¥é¡¶ç‚¹æ˜¯å”¯ä¸€çš„ï¼Œåˆ™è¯†åˆ«å¿…é¡»è¿æ¥åˆ°æ’å…¥é¡¶ç‚¹çš„ç½‘æ ¼é¡¶ç‚¹ï¼Œæ ¹æ®éœ€è¦åˆ é™¤è¾¹ä»¥ç¡®ä¿ç½‘æ ¼ä¿æŒ Delaunay æœ€ä½³çŠ¶æ€ï¼ˆè¿™ä¸€æ­¥éª¤è¿˜**åŒ…æ‹¬**å½“æ·»åŠ çš„é¡¶ç‚¹ä½äºTINçš„å‘¨è¾¹ä¹‹å¤–æ—¶**æ‰©å±•ç½‘æ ¼**ï¼‰ã€‚

#### 2.2.8.4 é¡¶ç‚¹ä½ç½®ï¼ˆ1ã€ç¡®å®šæ’å…¥ç‚¹åœ¨å“ªä¸ªä¸‰è§’å½¢å†…ï¼‰

Tinfour å®šä½åŒ…å«æ’å…¥é¡¶ç‚¹çš„ä¸‰è§’å½¢çš„æœ€ç›´æ¥æ–¹æ³•æ˜¯é¡ºåºæœç´¢æ‰€æœ‰ç°æœ‰ä¸‰è§’å½¢ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…é¡¹ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ ·çš„è¿‡ç¨‹å¾ˆæ…¢ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º ( 2 )ï¼Œå…·ä½“å–å†³äºè¾“å…¥é›†ä¸­çš„é¡¶ç‚¹æ•°é‡ã€‚ Lawson  (1977) æå‡ºäº†ä¸€ç§ä½¿ç”¨â€œæ­¥è¡Œâ€ç®—æ³•çš„æ›´å¿«æ–¹æ³•ã€‚å›¾16è¯´æ˜äº† Delaunay ä¸‰è§’å‰–åˆ†ä¸­ä¸¤ä¸ªä¸‰è§’ å½¢ä¹‹é—´éå†çš„æ¦‚å¿µã€‚åªè¦ç®—æ³•èƒ½å¤Ÿè¯†åˆ«åˆç†çš„ç›´æ¥è·¯å¾„ï¼Œéå†çš„æ­¥éª¤æ•°å°±ä¼šå¤§å¤§å°‘äºç½‘æ ¼ä¸­çš„é¡¶ ç‚¹æ•°ã€‚ç”±äºè¿™æ ·çš„è·¯å¾„å¾ˆå®¹æ˜“ä» Delaunay ä¸‰è§’æµ‹é‡ä¸­è·å¾—ï¼Œå› æ­¤æ’å…¥ç®—æ³•å¯ä»¥ä½¿ç”¨å®ƒæ¥åŠ å¿«ç‚¹ å®šä½è¿‡ç¨‹ã€‚ Soukal (2012) å¯¹æ­¥è¡Œç®—æ³•è¿›è¡Œäº†å…¨é¢çš„è®¨è®ºã€‚

![image-20240118130429719](./assets/image-20240118130429719.png)

**Tinfour ä½¿ç”¨ä»¥ä¸‹æ­¥éª¤æ‰§è¡Œé¡¶ç‚¹å®šä½æ“ä½œï¼š**

1. å›æƒ³ä¸€ä¸‹ï¼Œç½‘æ ¼ä¸­çš„æ‰€æœ‰ä¸‰è§’å½¢éƒ½æŒ‰é€†æ—¶é’ˆæ–¹å‘æ’åˆ—ã€‚å› æ­¤ï¼Œå¦‚æœä¸€ä¸ªé¡¶ç‚¹åŒ…å«åœ¨ä¸‰è§’å½¢ ä¸­ï¼Œåˆ™å®ƒå°†ä½äºæ¯ä¸ªå†…è¾¹å·¦ä¾§çš„åŠå¹³é¢å†…ã€‚ 

2. å¯¹äºå¼•å¯¼åçš„ç¬¬ä¸€æ¬¡æ’å…¥ï¼Œä½¿ç”¨åˆå§‹ä¸‰è§’å½¢çš„å†…ä¾§ä¹‹ä¸€é€‰æ‹©â€œèµ·å§‹è¾¹â€ã€‚å¯¹äºæ‰€æœ‰åç»­æœç´¢ï¼Œ ä»**æœ€è¿‘æ„å»ºçš„ä¸‰è§’å½¢ä¸­é€‰å–**èµ·å§‹è¾¹ã€‚ 

3. æµ‹è¯•æ’å…¥é¡¶ç‚¹æ˜¯å¦ä½äºèµ·å§‹è¾¹çš„å·¦ä¾§ã€‚å¦‚æœæ˜¯ï¼Œåˆ™ç»§ç»­æ­¥éª¤ 4ã€‚å¦‚æœä¸æ˜¯ï¼Œåˆ™å®ƒå°† ä½äºèµ·å§‹è¾¹å¯¹å¶çš„å·¦ä¾§ï¼Œå› æ­¤è½¬ç§»åˆ°èµ·å§‹è¾¹çš„å¯¹å¶ã€‚ 

4. é‡å¤ä»¥ä¸‹æ­¥éª¤ï¼Œç›´åˆ°æ‰¾åˆ°åŒ…å«çš„ä¸‰è§’å½¢æˆ–éå†è½¬ç§»åˆ° TIN çš„å¤–éƒ¨ï¼š 

   a. è·å–å‰æ²¿è¾¹ã€‚å¦‚æœé¡¶ç‚¹ä½äºå‰è¾¹çš„å³ä¾§ï¼Œåˆ™è½¬ç§»åˆ°å…¶å¯¹å¶å¹¶ç»§ç»­æ­¥éª¤ 5ã€‚ å¦åˆ™ç»§ç»­b

   b. è·å–åå‘è¾¹ç¼˜ã€‚å¦‚æœé¡¶ç‚¹ä½äºåå‘è¾¹çš„å³ä¾§ï¼Œåˆ™è½¬ç§»åˆ°å…¶å¯¹å¶å¹¶ç»§ç»­æ­¥éª¤ 5ã€‚ å¦åˆ™ç»§ç»­c

   c. å¦‚æœé¡¶ç‚¹ä½äºæ­£å‘è¾¹å’Œåå‘è¾¹çš„å·¦ä¾§ï¼Œåˆ™å®ƒå¿…é¡»ä½äºå½“å‰ä¸‰è§’å½¢çš„å†…éƒ¨ï¼ˆæˆ–è¾¹ ä¸Šï¼‰ã€‚éå†ç»“æŸã€‚

5. æœç´¢å·²è½¬ç§»åˆ°è¾¹çš„å¯¹å¶ï¼Œä½¿å¾—é¡¶ç‚¹ä½äºè¯¥è¾¹çš„å·¦ä¾§ã€‚å¦‚æœè¯¥è¾¹æ˜¯å†…è¾¹ï¼Œåˆ™ä»æ­¥éª¤ 4 ç»§ç»­æœç´¢ã€‚ 

6. å¦‚æœè¯¥è¾¹æ˜¯å¤–éƒ¨è¾¹ï¼Œåˆ™é€šè¿‡ç§»åŠ¨åˆ°å·¦æˆ–å³å‘¨è¾¹è¾¹ç¼˜ç›´åˆ°æ‰¾åˆ°å¯¹å‘è¾¹æ¥è¯†åˆ«å¯¹å‘é¡¶ç‚¹çš„è¾¹ã€‚ ç»ˆæ­¢æœç´¢ã€‚

    

â€‹        ä¸Šè¿°æ­¥éª¤é€‚ç”¨äºç‹¬ç‰¹ã€æœ€ä½³çš„ Delaunay ä¸‰è§’å‰–åˆ†ã€‚ä¸å¹¸çš„æ˜¯ï¼Œéæœ€ä½³ç½‘æ ¼å¯èƒ½åŒ…æ‹¬æ¸¸èµ°ç®—æ³•è½ å…¥å¾ªç¯è·¯å¾„ä¸”æ°¸è¿œä¸ä¼šå‡ºç°çš„åŒºåŸŸåˆ°è¾¾åŒ…å«ä¸‰è§’å½¢ã€‚ Lawson è¡¨æ˜ï¼Œå¯ä»¥é€šè¿‡éšæœºäº¤æ›¿æ­¥éª¤ 4.a å’Œ 4.b ä¸­è€ƒè™‘å‰å‘æˆ–åå‘è¾¹ç¼˜çš„ é¡ºåºæ¥é¿å…æ— é™å¾ªç¯ã€‚å³ä½¿éå†è½åœ¨ä¸‰è§’å½¢è·³è·ƒçš„æ½œåœ¨å¾ªç¯åºåˆ—ä¸­ï¼Œå¦‚æœéå†å¯ä»¥åˆ‡æ¢è€ƒè™‘ç›¸é‚» è¾¹çš„é¡ºåºï¼Œå®ƒæœ€ç»ˆä¹Ÿä¼šè½¬å‡ºå¾ªç¯ã€‚ç”±äºæ¸¸èµ°ç®—æ³•ä¸­çš„éšæœºåŒ–å…ƒç´ ï¼Œè¿™ç§æ–¹æ³•é€šå¸¸è¢«ç§°ä¸ºâ€œéšæœºåŠ³æ£®æ¸¸èµ°â€ã€‚ 

â€‹       åœ¨æ¯æ¬¡æ“ä½œä¹‹é—´ï¼ŒTinfour éƒ½ä¼šè·Ÿè¸ªæ‰€è°“çš„â€œèµ·å§‹è¾¹ç¼˜â€ï¼Œä»¥ä¾¿åç»­çš„æ¯æ¬¡æ­¥è¡Œéƒ½ä»å‰ä¸€æ¬¡æ­¥è¡Œç»“ æŸçš„åœ°æ–¹å¼€å§‹ã€‚å¦‚æœæ•´ä¸ªæ ·æœ¬é›†ä¸­çš„ä¸¤ä¸ªåç»­é¡¶ç‚¹é—´éš”å¾ˆè¿‘ï¼ˆä¸å…¶ä»–é¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ç›¸æ¯”ï¼‰ï¼Œåˆ™ æ­¥è¡Œæ“ä½œæ‰€éœ€çš„æ­¥æ•°ä¼šå‡å°‘ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœæ ·æœ¬é›†æ˜¯éšæœºå®šä½çš„ï¼Œåˆ™æ¸¸èµ°æ“ä½œå°†å€¾å‘äºåœ¨æ ·æœ¬ åŸŸä¸­æ¥å›è·³è·ƒï¼Œä»è€Œå¯¼è‡´æ¸¸èµ°æ“ä½œçš„æ€»é•¿åº¦å¢åŠ ã€‚å› æ­¤ï¼Œå½“åç»­é¡¶ç‚¹å¾€å¾€æ¯”éåç»­é¡¶ç‚¹æ›´é è¿‘æ—¶ï¼Œ Tinfour çš„è¡Œèµ°æ“ä½œå¾€å¾€ä¼šæ›´æœ‰æ•ˆã€‚è¿™æ ·çš„æ•°æ®é›†å…·æœ‰â€œé«˜åº¦çš„é¡ºåºç©ºé—´è‡ªç›¸å…³æ€§â€ï¼Œå¯ä»¥æ¯”é‚£äº› ä¸å…·æœ‰è¿™ç§ç‰¹æ€§çš„æ•°æ®é›†æ›´æœ‰æ•ˆåœ°å¤„ç†ã€‚å¹¸è¿çš„æ˜¯ï¼Œè¿™æ­£æ˜¯å…¸å‹æ¿€å…‰é›·è¾¾æ•°æ®é›†ä¸­çš„æƒ…å†µã€‚ ç”±äº æ¿€å…‰é›·è¾¾æ•°æ®é›†ä¸­çš„ç‚¹æ˜¯ä½¿ç”¨æ‰«ææ¿€å…‰æ”¶é›†çš„ï¼Œå¹¶ä¸”å¤§å¤šæ•°æ¿€å…‰é›·è¾¾æ ·æœ¬éƒ½æ˜¯æŒ‰ç…§æ”¶é›†çš„é¡ºåºç»™ å‡ºçš„ï¼Œå› æ­¤ä»æ¿€å…‰é›·è¾¾å¯¼å‡ºçš„é¡¶ç‚¹é€šå¸¸å…·æœ‰é«˜åº¦çš„é¡ºåºç©ºé—´è‡ªç›¸å…³æ€§ã€‚å¯¹äº Bear Mountain æ•°æ® é›†ï¼Œä½¿ç”¨ Lawson æ­¥è¡Œç®—æ³•å¹³å‡éœ€è¦ 3.38 æ­¥æ‰èƒ½æ‰¾åˆ°åŒ…å«é¡¶ç‚¹çš„ä¸‰è§’å½¢ï¼ˆè¯¥å€¼æ˜¯ä½¿ç”¨ä¸‹é¢æè¿° çš„ SingleBuildTest è·å¾—çš„ï¼‰ã€‚



#### 2.2.8.5 ä½¿ç”¨åŸºäºå¸Œå°”ä¼¯ç‰¹æ›²çº¿çš„æ’åºæ¥å‡å°‘æ­¥è¡Œé•¿åº¦

æœ‰ä¸€ä¸ªæ˜æ˜¾çš„æƒ…å†µï¼Œé¡ºåºç©ºé—´è‡ªç›¸å…³çš„å‡è®¾ä¸é€‚ç”¨ï¼šéšæœºæ ·æœ¬ã€‚å½“åœ¨è¾“å…¥åŸŸä¸­çš„éšæœºä½ç½®ç»™å‡ºæ · æœ¬æ—¶ï¼Œä¸€ä¸ªæ ·æœ¬ä¸å¤ªå¯èƒ½ä½äºå…¶å‰ä¸€ä¸ªæ ·æœ¬é™„è¿‘ã€‚å¯¹äºéšæœºå®šä½çš„æ ·æœ¬ï¼Œå¹³å‡æ¸¸èµ°çš„é•¿åº¦å¾€å¾€ä¸ ç½‘æ ¼ä¸­ç‚¹æ•°çš„å¹³æ–¹æ ¹æˆæ­£æ¯”ï¼ˆä¾‹å¦‚ï¼Œå®ƒä¸è·¨ç‚¹é›†åˆçš„å¯¹è§’çº¿é•¿åº¦æˆæ­£æ¯”ï¼‰ã€‚ç‚¹ä½ç½®çš„æ—¶é—´å¤æ‚åº¦ é€šè¿‡å¤§é‡é¡¶ç‚¹æ·»åŠ è¿›è¡Œæ•´åˆï¼Œå°†æ¥è¿‘ ( 3 â„ 2 )ã€‚ ä¸ºäº†å‡å°‘æ’å…¥ä¸€ç»„é¡ºåºç©ºé—´ç›¸å…³æ€§è¾ƒå·®çš„ç‚¹æ‰€éœ€çš„æ­¥éª¤æ•°ï¼ŒTinfour åº“å®ç°äº†ä¸€ä¸ªç±»ï¼Œç”¨äºä½¿ç”¨ åŸºäºå¸Œå°”ä¼¯ç‰¹ç©ºé—´å¡«å……æ›²çº¿ï¼ˆHilbertï¼Œ1891ï¼‰çš„æ’åºæ–¹æ¡ˆå¯¹æ ·æœ¬è¿›è¡Œæ’åºã€‚æ ·æœ¬ä¸­çš„æ¯ä¸ªç‚¹éƒ½ æŠ•å½±åˆ°å¸Œå°”ä¼¯ç‰¹æ›²çº¿çš„æœ€è¿‘çš„ä¸€æ®µä¸Šï¼Œå¹¶æ ¹æ®å…¶æ²¿æ›²çº¿çš„è·ç¦»åˆ†é…ä¸€ä¸ªæ’åºé”®ï¼Œå¦‚ä¸‹æ‰€ç¤ºå¦‚ä¸‹å›¾ 17ã€‚ ç”±äºå¸Œå°”ä¼¯ç‰¹æ›²çº¿è‡ªè¡Œå‘åæŠ˜å ï¼Œå› æ­¤é è¿‘çš„ç‚¹å¾€å¾€å…·æœ‰ç›¸ä¼¼çš„è·ç¦»å€¼ã€‚å› æ­¤ï¼Œæ’åºç¡®ä¿ äº†ä½ç½®æ¥è¿‘çš„ç‚¹åœ¨ç”Ÿæˆçš„æ ·æœ¬åºåˆ—ä¸­å½¼æ­¤é è¿‘ã€‚è¯¥æ“ä½œæå¤§åœ°æé«˜äº†æ ·æœ¬é›†çš„é¡ºåºç©ºé—´è‡ªç›¸å…³æ€§ã€‚ å› æ­¤ï¼Œé¡¶ç‚¹å®šä½è¿‡ç¨‹çš„æ—¶é—´å¤æ‚åº¦é™ä½åˆ° Java æ’åºæœ¬èº«çš„æ—¶é—´å¤æ‚åº¦ï¼Œé€šå¸¸ä¼˜äº ( âˆ™ log  )ã€‚

![image-20240118193104402](./assets/image-20240118193104402.png)

å°½ç®¡å¸Œå°”ä¼¯ç‰¹æ’åºåœ¨å¤„ç†è‡ªç›¸å…³æ€§è¾ƒå·®çš„æ ·æœ¬æ—¶å¯èƒ½å¾ˆæœ‰ç”¨ï¼Œä½†å®ƒå¹¶ä¸é€‚åˆæ‰€æœ‰æ•°æ®é›†ã€‚ä¾‹å¦‚ï¼Œ æ¿€å…‰é›·è¾¾æ ·æœ¬å¾ˆå°‘éœ€è¦å¸Œå°”ä¼¯ç‰¹æ’åºï¼Œå› ä¸ºå®ƒä»¬é€šå¸¸å…·æœ‰é«˜åº¦çš„é¡ºåºç©ºé—´è‡ªç›¸å…³æ€§ã€‚äº‹å®ä¸Šï¼Œè¿™ ç§æ’åºå¯ä»¥é€šè¿‡æ·»åŠ é¢å¤–çš„æ­¥éª¤æ¥å¢åŠ æ¿€å…‰é›·è¾¾æ ·æœ¬çš„æ•´ä½“å¤„ç†æ—¶é—´ï¼Œè¯¥æ­¥éª¤æœ¬èº«ä¼šäº§ç”Ÿå‰æœŸæˆ æœ¬ï¼Œå¹¶ä¸”åªèƒ½é€‚åº¦å‡å°‘é¡¶ç‚¹å®šä½æ—¶é—´ã€‚ä¾‹å¦‚ï¼Œå¯¹ Bear Mountain æ ·æœ¬æ‰§è¡Œå¸Œå°”ä¼¯ç‰¹æ’åºå°†å¹³å‡ éå†é•¿åº¦ä» 3.38 æ­¥å‡å°‘åˆ° 3.12 æ­¥ã€‚å½“ä½¿ç”¨å¸Œå°”ä¼¯ç‰¹æ’åºé€‰é¡¹æµ‹è¯•è¯¥æ ·æœ¬æ—¶ï¼Œä¸æœªæ’åºçš„è¾“å…¥ ç›¸æ¯”ï¼Œæ„å»º TIN æ‰€èŠ±è´¹çš„æ—¶é—´å‡å°‘äº† 106 æ¯«ç§’ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ’åºæœ¬èº«èŠ±è´¹äº† 236 æ¯«ç§’ã€‚å› æ­¤ï¼Œ åœ¨æ„å»º TIN ä¹‹å‰å¯¹æŠ˜ç‚¹è¿›è¡Œæ’åºå¯¼è‡´æ€»ä½“å¤„ç†æ—¶é—´å‡€å¢åŠ  130 æ¯«ç§’ã€‚ æ˜¾ç„¶ï¼Œç†Šå±±æ ·æœ¬ä¸æ˜¯å¸Œ å°”ä¼¯ç‰¹æ’åºçš„è‰¯å¥½å€™é€‰è€…ã€‚ä½†å¦‚æœåº”ç”¨ç¨‹åºå…ˆéªŒåœ°çŸ¥é“æ ·æœ¬å…·æœ‰è¾ƒå¼±çš„é¡ºåºç©ºé—´ç›¸å…³æ€§ï¼Œåˆ™å®ƒå¯ ä»¥æé«˜å¤„ç†æ•ˆç‡ã€‚è¯¥æ’åºåœ¨è¯¸å¦‚ Tinfour Viewerï¼ˆå¦‚ä¸‹æ‰€è¿°ï¼‰ä¹‹ç±»çš„åº”ç”¨ç¨‹åºä¸­ä¹Ÿå¾ˆæœ‰ç”¨ï¼Œå…¶ ä¸­åŒä¸€æ•°æ®é›†è¢«å¤„ç†å¤šæ¬¡ï¼ˆä»¥ä¾¿å•æ¬¡æ’åºçš„æˆæœ¬åœ¨è®¸å¤šåç»­æ“ä½œä¸­åˆ†æ‘Šï¼‰ã€‚ è®¡ç®—å¸Œå°”ä¼¯ç‰¹â€œç­‰çº§â€çš„é€»è¾‘åŸºäº Warren ä¸­æè¿°çš„ Lam & Shapiro æ–¹æ³•ï¼ˆ2013 å¹´ï¼Œç¬¬ 358  é¡µï¼‰ã€‚+

#### 2.2.8.6 é¡¶ç‚¹å”¯ä¸€æ€§

Tinfour æµ‹è¯•æ¯ä¸ªæ’å…¥é¡¶ç‚¹ï¼Œä»¥ç¡®ä¿å®ƒåŸºäºæœ€å°è·ç¦»æ ‡å‡†æ˜¯å”¯ä¸€çš„ã€‚**å¦‚æœé¡¶ç‚¹çš„æ°´å¹³åæ ‡ä¸ç°æœ‰é¡¶ç‚¹çš„æ°´å¹³åæ ‡ç›¸åŒæˆ–å‡ ä¹ç›¸åŒï¼Œåˆ™ä¸ä¼šå°†å…¶æ’å…¥ç½‘æ ¼ä¸­**ã€‚ç›¸åï¼ŒTinfour åˆ›å»ºäº†ä¸€ä¸ªâ€œé¡¶ç‚¹ç»„â€ï¼Œ å°†ä¸åŒçš„é¡¶ç‚¹è§†ä¸ºå•ä¸ªå®ä½“ã€‚

 VertexMergerGroup ç±»é€šè¿‡æ·»åŠ é¡¶ç‚¹åˆ—è¡¨ä½œä¸ºå…¶æˆå‘˜å…ƒç´ ä¹‹ä¸€æ¥æ‰©å±• Vertexã€‚ 

Tinfour ç¬¬ä¸€æ¬¡ é‡åˆ°æ’å…¥é¡¶ç‚¹ä¸å”¯ä¸€çš„æƒ…å†µæ—¶ï¼Œå®ƒä¼šå°†é¢„å…ˆå­˜åœ¨çš„é¡¶ç‚¹å¯¹è±¡æ›¿æ¢ä¸ºç”¨å…¶æ°´å¹³æ„é€ çš„ VertexMergerGroup å®ä¾‹åæ ‡ã€‚æ’å…¥é¡¶ç‚¹å’Œé¢„å…ˆå­˜åœ¨çš„é¡¶ç‚¹éƒ½è¢«æ·»åŠ åˆ°ç»„ä¸­ã€‚å½“åº”ç”¨ç¨‹åºéœ€è¦é¡¶ç‚¹ç»„çš„å‚ç›´ (z) åæ ‡æ—¶ï¼Œ Tinfour ä¼šæ ¹æ®ä¸º TIN è®¾ç½®çš„è®¿é—®é€‰é¡¹æ¥æå–é¡¶ç‚¹çš„æœ€å°å€¼ã€æœ€å¤§å€¼æˆ–å¹³å‡å€¼ã€‚å¦‚æœåº”ç”¨ç¨‹åº ä½¿ç”¨å¢é‡ TIN ç±»çš„è®¿é—®å™¨æ–¹æ³•æ¥è¯·æ±‚ç½‘æ ¼ä¸­å½“å‰æ‰€æœ‰é¡¶ç‚¹çš„åˆ—è¡¨ï¼Œåˆ™ç”Ÿæˆçš„é¡¶ç‚¹é›†åˆï¼ˆJava åˆ— è¡¨ï¼‰åŒ…å«é¡¶ç‚¹ç»„ä½œä¸ºå…ƒç´ ã€‚æ†ç»‘åˆ°ç»„ä¸­çš„æ’å…¥é¡¶ç‚¹ä¸åŒ…å«åœ¨ç»“æœä¸­ï¼Œä½†å¯ä»¥é€šè¿‡è®¿é—®åŒ…å«å®ƒä»¬çš„ ç»„å¯¹è±¡æ¥è·å–ã€‚

#### 2.2.8.7 å‹è…”åˆ›å»º

åœ¨æ¥ä¸‹æ¥çš„è¿‡ç¨‹ä¸­ï¼Œå½“ä¸”ä»…å½“æ’å…¥é¡¶ç‚¹ä½äºä½äºè¾¹çš„ç›¸å¯¹ä¾§çš„ä¸‰è§’å½¢çš„å¤–æ¥åœ†ä¹‹å¤–æ—¶ï¼Œæˆ‘ä»¬å°†è¾¹ æè¿°ä¸ºâ€œDelaunayâ€ã€‚è¯¥ç®—æ³•é€šè¿‡åˆ é™¤æ‰€æœ‰é Delaunay è¾¹æ¥åˆ›å»ºç©ºè…”ã€‚å½“è¾¹ç¼˜è¢«ç§»é™¤æ—¶ï¼Œç›¸é‚»è¾¹ ç¼˜çš„å‰å‘å’Œåå‘é“¾æ¥è¢«è°ƒæ•´ï¼Œä½¿å¾—ç©ºè…”ç”±ä¸€ç»„æ­£ç¡®é“¾æ¥çš„è¾¹ç¼˜ç•Œå®šã€‚

å‹è…”åˆ›å»ºè¿‡ç¨‹å¦‚ä¸‹ï¼š

1. ä»»æ„é€‰æ‹©å°é—­ä¸‰è§’å½¢çš„ä¸€æ¡è¾¹ä½œä¸ºâ€œèµ·å§‹è¾¹â€ã€‚

2.   å°†èµ·å§‹è¾¹çš„åˆå§‹é¡¶ç‚¹æŒ‡å®šä¸ºâ€œèµ·å§‹é¡¶ç‚¹â€ã€‚ 

3.  å°†ä¸€ä¸ªå…ƒç´ å®šä¹‰ä¸ºâ€œå…‰æ ‡â€è¾¹ç¼˜å¹¶å°†å…¶è®¾ç½®ä¸ºèµ·å§‹è¾¹ç¼˜ã€‚ 

4.  å¦‚æœå…‰æ ‡è¾¹ç¼˜ç›¸å¯¹äºæ’å…¥é¡¶ç‚¹æ˜¯ Delaunayï¼Œåˆ™ä¸ä¼šå°†å…¶åˆ é™¤ã€‚å¦‚æœç›¸å¯¹çš„é¡¶ç‚¹æ˜¯é¬¼é¡¶ç‚¹ï¼Œ åˆ™ä¸ä¼šåˆ é™¤è¯¥è¾¹ï¼Œå¹¶ä¸”è¯¥è¾¹å°†è¢«è§†ä¸ºâ€œæœ‰æ•ˆâ€Delaunayã€‚ä½¿ç”¨ InCircle è®¡ç®—æ¥ç¡®å®šå…‰æ ‡è¾¹ ç¼˜æ˜¯å¦ä¸º Delaunayã€‚å¦‚æœ InCircle è®¡ç®—ä¸æ˜ç¡®ï¼Œè¯·å°†è¾¹è§†ä¸º Delaunayã€‚è¾¹ç¼˜æ˜¯å¾·åŠ³å†… å—ï¼Ÿ

    a. æ˜¯ï¼šä¸è¦ç§»é™¤è¾¹ç¼˜ã€‚å°†å…‰æ ‡è½¬ç§»åˆ°å…¶è‡ªå·±çš„å‰è¾¹ç¼˜ã€‚ 

   b. å¦ï¼šä»ç½‘æ ¼ä¸­åˆ é™¤è¾¹ï¼Œè°ƒæ•´ç›¸é‚»è¾¹çš„é“¾æ¥ä»¥ä¿æŒç©ºè…”å¤šè¾¹å½¢é“¾æ¥ã€‚å°†å…‰æ ‡ è½¬ç§»åˆ°å…¶åŒè½´çš„å‰è¾¹ç¼˜ã€‚ 

5.  å¦‚æœå…‰æ ‡è¾¹ç¼˜çš„åˆå§‹é¡¶ç‚¹æ˜¯èµ·å§‹é¡¶ç‚¹ï¼Œåˆ™å‹è…”åˆ›å»ºè¿‡ç¨‹å®Œæˆã€‚å¦åˆ™ï¼Œä»æ­¥éª¤ 4 å¼€å§‹ é‡å¤ã€‚ 

   

   å°é—­ä¸‰è§’å½¢çš„æ‰€æœ‰è¾¹éƒ½å¯èƒ½æ˜¯æ­£ç¡®çš„ Delaunayï¼Œå¹¶ä¸”â€œç©ºè…”â€å¤šè¾¹å½¢å°†åªæ˜¯åŸå§‹çš„å°é—­ä¸‰è§’å½¢ã€‚

#### 2.2.8.8 é“¾æ¥è¿æ¥

ç”Ÿæˆçš„å¤šè¾¹å½¢å¯èƒ½æ˜¯å‡¸çš„æˆ–éå‡¸çš„ï¼Œä½† Bowyer å’Œ Watson çš„å·¥ä½œè¡¨æ˜å®ƒå°†ä¸¥æ ¼æŒ‰é€†æ—¶é’ˆé¡ºåºæ’ åºã€‚æ­¤å¤–ï¼Œåœ¨æ’å…¥é¡¶ç‚¹å’Œå¤šè¾¹å½¢é¡¶ç‚¹ä¹‹é—´æ„å»ºçš„æ‰€æœ‰è¾¹éƒ½å°†æ˜¯ Delaunay æœ€ä¼˜çš„ã€‚é“¾æ¥è¿æ¥è¿‡ç¨‹ å¾ˆç®€å•ï¼Œç”Ÿæˆçš„ä¸‰è§’å½¢å°†æŒ‰é€†æ—¶é’ˆé¡ºåºæŒ‡å®šã€‚æ­¤å¤–ï¼Œåªè¦æ‰€æœ‰ InCircle è®¡ç®—éƒ½æ˜ç¡®ï¼Œç”Ÿæˆçš„ç½‘ æ ¼å°†æ˜¯ Delaunay æœ€ä¼˜ä¸”å”¯ä¸€çš„ã€‚å¦åˆ™ï¼Œå®ƒå°†â€œæ¥è¿‘ Delaunayâ€ä¸”éå”¯ä¸€ã€‚å°½ç®¡ Tinfour å¯ä»¥å® æ–½é™„åŠ è§„åˆ™æ¥â€œæ¶ˆé™¤æ­§ä¹‰â€ï¼Œå³ InCircle è®¡ç®—ç»™å‡ºä¸æ˜ç¡®ï¼ˆé›¶ï¼‰ç»“æœçš„æƒ…å†µï¼Œä½†ç›®å‰è¿˜æ²¡æœ‰ä»»ä½• è§„åˆ™ã€‚å› æ­¤ï¼ŒåŒä¸€ç»„é‡‡æ ·ç‚¹å¯èƒ½ä¼šäº§ç”Ÿä¸åŒçš„ TINï¼Œå…·ä½“å–å†³äºå®ƒä»¬æ·»åŠ åˆ°ç½‘æ ¼çš„é¡ºåºã€‚

### 2.2.9 åæ ‡å’Œæ•°å€¼é—®é¢˜

è®¡ç®—å‡ ä½•åº”ç”¨å› æ•°å€¼ç²¾åº¦é—®é¢˜è€Œè‡­åæ˜­è‘—ã€‚ç”±äºæµ®ç‚¹è¿ç®—çš„é™åˆ¶ï¼ŒåŸºäºå…·æœ‰ç²¾ç¡®ä»£æ•°è§£çš„è¡¨è¾¾å¼ çš„è®¡ç®—ç»å¸¸ä¼šç”±äºèˆå…¥æˆ–è¿‘ä¼¼è¯¯å·®è€Œå¤±è´¥ã€‚å…·ä½“é—®é¢˜å°†åœ¨ä¸‹é¢çš„è®¨è®ºä¸­å‡ºç°ï¼Œä½†æœ‰ä¸¤ä¸ªä¸€èˆ¬æ€§è€ƒ è™‘å› ç´ å€¼å¾—æ³¨æ„ï¼š 

1. å‡ ä¹ç›¸åŒçš„é¡¶ç‚¹ï¼šTinfour ä¸­ä½¿ç”¨çš„ä¸‰è§’å‰–åˆ†ç®—æ³•å–å†³äºç½‘æ ¼ä¸­çš„æ¯ä¸ªé¡¶ç‚¹éƒ½æ˜¯å”¯ä¸€çš„ã€‚ å¦‚æœæŠ˜ç‚¹å¤ªè¿‘ï¼Œåˆ™ç»„åˆå®ƒä»¬çš„å€¼çš„æ•°å€¼è®¡ç®—å¯èƒ½ä¼šå¯¼è‡´ TIN æ„å»ºè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ã€‚ä¸ºäº† é¿å…ä¸¤ä¸ªé¡¶ç‚¹é—´éš”å¤ªè¿‘è€Œå¯¼è‡´è®¡ç®—å¤±è´¥çš„é—®é¢˜ï¼ŒTinfour å¿…é¡»å®šä¹‰ä¸€ä¸ªé˜ˆå€¼è·ç¦»ï¼Œç”¨äºå°† â€œå‡ ä¹ç›¸åŒâ€çš„é¡¶ç‚¹è§†ä¸ºåŒä¸€ç‚¹ã€‚ 

2.  éœ€è¦æ‰©å±•ç²¾åº¦ç®—æœ¯çš„æƒ…å†µï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼ŒTinfour å°†ä½¿ç”¨æ‰©å±•ç²¾åº¦ç®—æœ¯æ¥ç¡®å®šè¦ç´ ä¹‹ é—´çš„å‡ ä½•å…³ç³»ï¼ˆä¾‹å¦‚ï¼Œé¡¶ç‚¹ä½äºç›´çº¿çš„å“ªä¸€ä¾§ï¼‰ã€‚ç”±äºæ‰©å±•ç®—æœ¯æ¯”æ ‡å‡†æµ®ç‚¹è®¡ç®—éœ€è¦æ›´ å¤šå¤„ç†ï¼ŒTinfour å®ç°äº†é˜ˆå€¼ï¼Œä»¥ä¾¿å½“æŸäº›æ ‡å‡†è®¡ç®—äº§ç”Ÿâ€œæ¥è¿‘é›¶â€çš„å€¼æ—¶ï¼Œå¯ä»¥é‡‡ç”¨æ›¿ ä»£æ‰©å±•ç²¾åº¦å€¼è®¡ç®—ã€‚ 

   é˜ˆå€¼çš„åˆ†é…å–å†³äºæ­£åœ¨å»ºæ¨¡çš„æ•°æ®çš„å¤§å°ã€‚ç”¨äºå¯¹å‘¼å«æ–‡åŒ–ä¸­è¥å…»ç‰©è´¨åˆ†å¸ƒè¿›è¡Œå»ºæ¨¡çš„åº”ç”¨ç¨‹ åºçš„åæ ‡å€¼ä¸åŸºäºç›¸è·æ•°ç™¾å…¬é‡Œçš„å¤©æ°”è§‚æµ‹çš„åº”ç”¨ç¨‹åºçš„åæ ‡å€¼æœ‰å¾ˆå¤§ä¸åŒã€‚

    è®¡ç®—é˜ˆå€¼æ—¶ï¼Œå¢é‡ TIN ç±»çš„æ„é€ å‡½æ•°å…è®¸åº”ç”¨ç¨‹åºæŒ‡å®šä¸è¦æ„å»ºåˆ° TIN ä¸­çš„æŠ˜ç‚¹çš„å¹³å‡é—´è·ç›¸ å…³çš„å€¼ã€‚é»˜è®¤æ„é€ å‡½æ•°å‡å®šå€¼ä¸º 1 ä¸ªå•ä½ï¼ˆç±³ã€è‹±å°ºã€ç§’å·®è·ç­‰ï¼‰ã€‚å…¶ä»–æ„é€ å‡½æ•°å…è®¸åº”ç”¨ç¨‹åº æŒ‡å®šé€‚å½“çš„å€¼ã€‚ 

   è®¤ä¸ºä¸¤ä¸ªé¡¶ç‚¹ç›¸åŒçš„é˜ˆå€¼æ˜¯å¹³å‡ç‚¹é—´è·çš„ 1/10000ç¬¬ ã€‚åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ä½¿ç”¨ Tinfour é¡¹ç›®ä¸­å®š ä¹‰çš„ Thresholds ç±»æ¥æ”¹å˜è¿™ä¸€ç‚¹ã€‚



### 2.2.10çº¦æŸDelaunayä¸‰è§’å‰–åˆ†

ä¸Šè¿°DelaunayæŠ€æœ¯åŸºäºä¸‰è§’æµ‹é‡è¿‡ç¨‹ä¸ºå¯ä»¥åŸºäºDelaunayå‡†åˆ™è‡ªç”±åœ°å…³è”ç›¸é‚»é¡¶ç‚¹ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¿™æ ·åš
ä¸ä¸€å®šæ˜¯å¯¹æ•°æ®çš„æœ€ä½³å¤„ç†ã€‚å†æ¬¡è½¬å‘é«˜ç¨‹æ•°æ®çš„ç¤ºä¾‹ï¼Œå½“æ„Ÿå…´è¶£çš„é™†åœ°è¡¨é¢åŒ…æ‹¬æ‚¬å´–ã€è·¯å ‘ã€æ‚¬å´–ï¼Œç”šè‡³æ°´ä½“æ—¶ï¼Œè¯·è€ƒè™‘è¿™ç§æƒ…å†µã€‚è¿™ç§è¾¹ç•Œç›¸å¯¹ä¸¤ä¾§çš„è¿æ¥é¡¶ç‚¹å¯èƒ½ä¸ä¸€å®šæ˜¯æ•°æ®çš„æœ€ä½³å¤„ç†ã€‚

å—çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†å…è®¸å°†ä¸€ç»„è¾¹æ’å…¥åˆ°ä¸‰è§’å½¢ä¸­å–ä»£Delaunayå‡†åˆ™å¹¶çº¦æŸç½‘æ ¼ä¸­é¡¶ç‚¹è¿æ¥æ–¹å¼çš„ç½‘æ ¼ã€‚ä¸‹å›¾è¯´æ˜äº†è¿™ä¸€æ¦‚å¿µã€‚æ˜¾ç¤ºçš„æ•°æ®å‡ºç°åœ¨ä¸¤ä¸ªç‹¬ç«‹çš„åŒºåŸŸã€‚æ™®é€šçš„Delaunayå¯ä»¥éšæ„åœ¨å•ç‹¬çš„é¡¶ç‚¹ä¹‹é—´åˆ›å»ºè¿æ¥ã€‚å—çº¦æŸçš„Delaunayè¡¥å……é“ä»¥å®šä¹‰æ•°æ®åŒºåŸŸçš„é™åˆ¶çš„è¾¹çš„å½¢å¼å‘ç³»ç»Ÿæä¾›æ›´å¤šä¿¡æ¯ã€‚åœ¨å¦‚å›¾æ‰€ç¤ºï¼Œçº¦æŸæ˜¾ç¤ºä¸ºä¸‰è§’æµ‹é‡ä¸­å¿ƒçš„å‚ç›´è¾¹ã€‚

![image-20231221222757230](./assets/image-20231221222757230.png)

å‘ä¸‰è§’å‰–åˆ†æ·»åŠ çº¦æŸçš„ç¼ºç‚¹ä¹‹ä¸€æ˜¯å¹¶éç½‘æ ¼ä¸­çš„æ‰€æœ‰ä¸‰è§’å½¢å¿…ç„¶ç¬¦åˆDelaunayæ ‡å‡†ã€‚ç‰¹åˆ«æ˜¯ï¼Œè¿™ç§çº¦æŸå¯èƒ½ä¼šå¯¼è‡´â€œç˜¦â€ä¸‰è§’å½¢ï¼Œä¾‹å¦‚å›¾ä¸­å—çº¦æŸè¾¹é™„è¿‘å‡ºç°çš„ä¸‰è§’å½¢ã€‚è¿™ç§ä¼ªå½±é€šå¸¸æ˜¯å½“ä½¿ç”¨ä¸‰è§’æµ‹é‡æ¥æ’å€¼æˆ–å¯¹æ›²é¢å»ºæ¨¡æ—¶ï¼Œè¿™æ˜¯ä¸å¸Œæœ›çš„ã€‚æ­¤å¤–ï¼Œè®¸å¤šåº”ç”¨ç¨‹åºåˆ©ç”¨äº†è¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå³Delaunayä¸‰è§’æµ‹é‡å¾ˆå®¹æ˜“æ˜ å°„åˆ°å¦ä¸€ä¸ªé‡è¦çš„å›¾å½¢ç»“æ„Voronoiå›¾ã€‚å¦‚æœæ·»åŠ çº¦æŸä¼šæ¸²æŸ“ä¸‰è§’æµ‹é‡éDelaunayï¼Œå®ƒä¸å†å…·æœ‰å…³è”çš„Voronoiå›¾ã€‚

Rognantç­‰äººï¼ˆ1999ï¼‰æè¿°äº†æ¢å¤Delaunayæœ€ä¼˜æ€§çš„ä¸€ç§æ–¹æ³•ï¼Œä»–è¿˜æå‡ºäº†è¯¥æŠ€æœ¯çš„ç®€çŸ­æ•°å­¦è¯æ˜ã€‚è¯¥æŠ€æœ¯æ²¿çº¦æŸæ·»åŠ åˆæˆç‚¹
å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚çº¦æŸè¾¹è¢«ç»†åˆ†ä¸ºè¾ƒå°çš„è¾¹å¾—åˆ°çš„ä¸‰è§’å½¢éƒ½ç¬¦åˆDelaunayå‡†åˆ™ã€‚æœ€ä½³çŠ¶æ€æ¢å¤ã€‚

![image-20231221223009410](./assets/image-20231221223009410.png)

CDTçš„åº”ç”¨è¶…è¶Šäº†åœ°å½¢å»ºæ¨¡ï¼Œæ‰©å±•åˆ°äº†æ•°æ®å»ºæ¨¡çš„è®¸å¤šé¢†åŸŸã€‚ä¸€LogoCDTåº”ç”¨ç¨‹åºæä¾›äº†ä¸è¡¨é¢é«˜ç¨‹æ— å…³çš„CDTç¤ºä¾‹å…¶åŒ…å«åœ¨Tinfourè½¯ä»¶å‘è¡Œç‰ˆä¸­ã€‚åº”ç”¨ç¨‹åºä¸­çš„å›¾åƒå¦‚ä¸‹æ‰€ç¤ºã€‚

![image-20231221223030002](./assets/image-20231221223030002.png)

Tinfourå®ç°äº†ä¸€ä¸ªç§°ä¸ºâ€œå—çº¦æŸåŒºåŸŸâ€çš„æ¦‚å¿µï¼Œè¯¥æ¦‚å¿µå…è®¸åŸºäºå¤šè¾¹å½¢çš„çº¦æŸä½¿ç”¨åº”ç”¨ç¨‹åºå®šä¹‰çš„å…ƒæ•°æ®å®šä¹‰åŒºåŸŸã€‚æ­¤å…ƒæ•°æ®é€šå¸¸ä»¥Javaçš„å½¢å¼æŒ‡å®šå¯¹è±¡åœ¨æ„é€ çº¦æŸæ—¶æ·»åŠ åˆ°çº¦æŸä¸­ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„å›¾ç‰‡æ˜¯åˆæˆçš„ä½¿ç”¨å…¬å…±é¢†åŸŸè‡ªç„¶åœ°çƒåœ°å›¾é¡¹ç›®çš„å…¨çƒèŒƒå›´çš„äº§å“ã€‚æ¯ä¸ªå›½å®¶å¤šè¾¹å½¢å¡«å……äº†ä¸€ä¸ªJava Colorå¯¹è±¡ã€‚ç¼–å†™äº†ä¸€ä¸ªæµ‹è¯•åº”ç”¨ç¨‹åºæ¥æ¸²æŸ“å†…éƒ¨çš„è¾¹ã€‚

![image-20231221223101514](./assets/image-20231221223101514.png)

## 2.3æ’å€¼

æ’å€¼å¯èƒ½æ˜¯ä¸‰è§’å½¢ç½‘æ ¼æœ€å¸¸è§çš„åº”ç”¨ç¨‹åºã€‚Tinfourå®ç°äº†ä¸‰ç§ä¸åŒçš„æ’å€¼æŠ€æœ¯ï¼šä¸‰è§’é¢ã€è‡ªç„¶é‚»åŸŸå’Œåœ°ç†åŠ æƒå›å½’å¤šé¡¹å¼ã€‚ç”±äºè¿™ä¸‰ç§æŠ€æœ¯éƒ½æ˜¯åœ¨åªè¯»çš„åŸºç¡€ä¸Šè®¿é—®TINçš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨å¤šçº¿ç¨‹æ–¹æ³•å¹¶è¡Œæ“ä½œä»»ä½•Tinfouræ’å€¼ç±»çš„å¤šä¸ªå®ä¾‹ã€‚

# VoronoÃ¯å›¾

VoronoÃ¯å›¾æ˜¯ä¸€ç§æ•°å­¦å’Œè®¡ç®—å‡ ä½•ä¸­çš„å›¾å½¢è¡¨ç¤ºæ–¹æ³•ï¼Œä¹Ÿè¢«ç§°ä¸ºVoronoÃ¯å›¾æ¡ˆã€VoronoÃ¯å›¾å½¢ã€VoronoÃ¯å›¾å½¢åˆ†å‰²ç­‰ã€‚è¿™ä¸ªå›¾å½¢æ˜¯æ ¹æ®ä¸€ç»„ç‚¹åœ¨ä¸€ä¸ªç»™å®šçš„ç©ºé—´ä¸­ç”Ÿæˆçš„ï¼Œå®ƒå°†è¿™ä¸ªç©ºé—´åˆ†å‰²æˆç”±è¿™äº›ç‚¹æ§åˆ¶çš„å¤šè¾¹å½¢åŒºåŸŸï¼Œä½¿å¾—æ¯ä¸ªåŒºåŸŸå†…çš„ç‚¹éƒ½ç¦»æœ€è¿‘çš„æ§åˆ¶ç‚¹æœ€è¿‘ã€‚

å…·ä½“æ¥è¯´ï¼ŒVoronoÃ¯å›¾çš„ç”Ÿæˆè¿‡ç¨‹å¦‚ä¸‹ï¼š

1. åœ¨äºŒç»´æˆ–ä¸‰ç»´ç©ºé—´ä¸­é€‰æ‹©ä¸€ç»„ç‚¹ï¼Œç§°ä¸ºç”Ÿæˆç‚¹æˆ–ç§å­ç‚¹ã€‚
2. å¯¹äºæ¯ä¸ªç”Ÿæˆç‚¹ï¼Œè®¡ç®—å…¶åˆ°å…¶ä»–æ‰€æœ‰ç”Ÿæˆç‚¹çš„è·ç¦»ã€‚
3. æ ¹æ®è·ç¦»ï¼Œå°†ç©ºé—´åˆ’åˆ†æˆä»¥æ¯ä¸ªç”Ÿæˆç‚¹ä¸ºä¸­å¿ƒçš„åŒºåŸŸï¼Œæ¯ä¸ªåŒºåŸŸå†…çš„ç‚¹éƒ½ç¦»è¯¥ç”Ÿæˆç‚¹æœ€è¿‘ã€‚
4. å½¢æˆçš„åŒºåŸŸç”±å¤šè¾¹å½¢ç»„æˆï¼Œç§°ä¸ºVoronoÃ¯å¤šè¾¹å½¢ï¼Œå®ƒä»¬æ˜¯ç”±ç›¸é‚»ç”Ÿæˆç‚¹ä¹‹é—´çš„å‚ç›´å¹³åˆ†çº¿æ‰€å›´æˆçš„ã€‚

VoronoÃ¯å›¾åœ¨è®¸å¤šé¢†åŸŸä¸­æœ‰å¹¿æ³›çš„åº”ç”¨ï¼ŒåŒ…æ‹¬è®¡ç®—æœºå›¾å½¢å­¦ã€åœ°ç†ä¿¡æ¯ç³»ç»Ÿï¼ˆGISï¼‰ã€æ¨¡å¼è¯†åˆ«ã€ç”Ÿç‰©å­¦ã€ææ–™ç§‘å­¦ç­‰ã€‚åœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­ï¼ŒVoronoÃ¯å›¾å¸¸ç”¨äºç”Ÿæˆè‡ªç„¶æ™¯è§‚ã€çº¹ç†åˆæˆã€æ¸¸æˆè®¾è®¡ç­‰æ–¹é¢ã€‚

# DEMåº”ç”¨

https://blog.csdn.net/TuxinyunGIS/article/details/105837629

1 åŸºæœ¬æ¦‚å¿µ

DEMæ˜¯æ•°å­—é«˜ç¨‹æ¨¡å‹çš„è‹±æ–‡ç®€ç§°(Digital Elevation Model)ï¼Œæ˜¯ç ”ç©¶åˆ†æåœ°å½¢ã€æµåŸŸã€åœ°ç‰©è¯†åˆ«çš„é‡è¦åŸå§‹èµ„æ–™ã€‚ç”±äºDEM æ•°æ®èƒ½å¤Ÿåæ˜ ä¸€å®šåˆ†è¾¨ç‡çš„å±€éƒ¨åœ°å½¢ç‰¹å¾ï¼Œå› æ­¤é€šè¿‡DEM å¯æå–å¤§é‡çš„åœ°è¡¨å½¢æ€ä¿¡æ¯ï¼Œå¯ç”¨äºç»˜åˆ¶ç­‰é«˜çº¿ã€å¡åº¦å›¾ã€å¡å‘å›¾ã€ç«‹ä½“é€è§†å›¾ã€ç«‹ä½“æ™¯è§‚å›¾ï¼Œå¹¶åº”ç”¨äºåˆ¶ä½œæ­£å°„å½±åƒã€ç«‹ä½“åœ°å½¢æ¨¡å‹ä¸åœ°å›¾ä¿®æµ‹ã€‚åœ¨æµ‹ç»˜ã€æ°´æ–‡ã€æ°”è±¡ã€åœ°è²Œã€åœ°è´¨ã€åœŸå£¤ã€å·¥ç¨‹å»ºè®¾ã€é€šè®¯ã€å†›äº‹ç­‰å›½æ°‘ç»æµå’Œå›½é˜²å»ºè®¾ä»¥åŠäººæ–‡å’Œè‡ªç„¶ç§‘å­¦é¢†åŸŸæœ‰ç€å¹¿æ³›çš„åº”ç”¨ã€‚

å¦‚åœ¨å·¥ç¨‹å»ºè®¾ä¸Šï¼Œå¯ç”¨äºå¦‚åœŸæ–¹é‡è®¡ç®—ã€é€šè§†åˆ†æç­‰ï¼›åœ¨é˜²æ´ªå‡ç¾æ–¹é¢ï¼ŒDEMæ˜¯è¿›è¡Œæ°´æ–‡åˆ†æå¦‚æ±‡æ°´åŒºåˆ†æã€æ°´ç³»ç½‘ç»œåˆ†æã€é™é›¨åˆ†æã€è“„æ´ªè®¡ç®—ã€æ·¹æ²¡åˆ†æç­‰çš„åŸºç¡€; åœ¨æ— çº¿é€šè®¯ä¸Šï¼Œå¯ç”¨äºèœ‚çªç”µè¯çš„åŸºç«™åˆ†æç­‰ã€‚

 

2 ä¸»æµæ•°æ®æº

ç›®å‰ç½‘ä¸Šæœ‰å¤šç§å…¨çƒé«˜ç¨‹æ•°æ®ï¼Œç®€è¦ä»‹ç»ä¸‹è¿™å››ç§æ•°æ®ï¼š

SRTM C æ³¢æ®µæ•°æ®ï¼Œç¾å›½è´§ï¼Œå¯èƒ½æ˜¯æœ€æœ‰åçš„é«˜ç¨‹æ•°æ®äº†ã€‚ç¾å›½èˆªç©ºèˆªå¤©å±€ NASA åœ¨ 2000 æ—¶åˆ©ç”¨å¥‹è¿›å·èˆªå¤©é£æœºä¸Šçš„é›·è¾¾æµ‹è§‚æµ‹æ‰€å¾—ï¼Œæ˜¯ä»¥å‰ç”¨å¾—æœ€å¤šçš„é«˜ç¨‹æ•°æ®ï¼Œè¦†ç›–äº†å…¨çƒå—åŒ—çº¬ 60 åº¦ä»¥å†…çš„åŒºåŸŸã€‚

SRTM1ï¼š1 è§’ç§’ç²¾åº¦ï¼Œå¯¹åº”ç²¾åº¦ä¸º30 ç±³

SRTM3ï¼š 3è§’ç§’ç²¾åº¦ï¼Œå¯¹åº”ç²¾åº¦ä¸º90 ç±³ã€‚è°·æ­Œåœ°çƒæ‰€ä½¿ç”¨é«˜ç¨‹æ•°æ®å³ä¸º SRTM3ï¼Œå…¨çƒè¦†ç›–ï¼Œä¿çœŸåº¦ä¸å¥½ï¼Œå‡ ä¹æ²¡æœ‰æ¼æ´ã€ç©ºæ´ã€‚
![image-20240103143522493](./assets/image-20240103143522493.png)

# é¡¹ç›®ç®€ä»‹

Tinfour æ˜¯ä¸€ä¸ªç›¸å½“å¤æ‚çš„åº“ï¼Œå®ƒåŒ…å«å¤šä¸ªç”¨äºå¤„ç†ç©ºé—´æ•°æ®å’Œæ„å»ºä¸‰è§’ä¸è§„åˆ™ç½‘ç»œï¼ˆTINï¼‰çš„ç±»ã€‚åœ¨ Tinfour çš„æ ¸å¿ƒä¸­ï¼Œä¸»è¦çš„ç»„ä»¶å¯èƒ½åŒ…æ‹¬é¡¶ç‚¹å¤„ç†ã€è¾¹ç¼˜ç®¡ç†ã€ä¸‰è§’å‰–åˆ†ç®—æ³•ç­‰ã€‚é‰´äºè¿™æ˜¯ä¸€ä¸ªå¹¿æ³›çš„è¯é¢˜ï¼Œæˆ‘å°†æ¦‚è¿°å…¶å‡ ä¸ªä¸»è¦éƒ¨åˆ†ï¼š

### 1. é¡¶ç‚¹(Vertex)

`Vertex` ç±»é€šå¸¸è¡¨ç¤ºäºŒç»´æˆ–ä¸‰ç»´ç©ºé—´ä¸­çš„ä¸€ä¸ªç‚¹ã€‚å®ƒä¼šæœ‰åæ ‡ï¼ˆå¦‚ x, y, å’Œå¯é€‰çš„ z åæ ‡ï¼‰ï¼Œä»¥åŠå¯èƒ½çš„å…¶ä»–å±æ€§ã€‚

### 2. è¾¹(Edge)å’Œè¾¹æ± (EdgePool)

åœ¨ TIN ç»“æ„ä¸­ï¼Œè¾¹ç”¨äºè¿æ¥é¡¶ç‚¹ï¼Œå¹¶å½¢æˆç½‘çŠ¶ç»“æ„ã€‚è¾¹é€šå¸¸ä»¥æˆå¯¹çš„å½¢å¼å­˜åœ¨ï¼Œä»¥ä¾¿äºä»ä¸¤ä¸ªæ–¹å‘éå†ã€‚`EdgePool` ç±»ï¼Œåƒä¹‹å‰æåˆ°è¿‡çš„ï¼Œç”¨äºç®¡ç†è¿™äº›è¾¹çš„åˆ›å»ºå’Œé‡ç”¨ï¼Œä»è€Œæé«˜æ•ˆç‡å¹¶å‡å°‘å†…å­˜çš„ä½¿ç”¨ã€‚

### 3. ä¸‰è§’å½¢(Triangle)

ä¸‰è§’å½¢æ˜¯æ„æˆ TIN çš„åŸºæœ¬å•å…ƒï¼Œæ¯ä¸ªä¸‰è§’å½¢ç”±ä¸‰æ¡è¾¹ç•Œã€‚åœ¨æŸäº›å®ç°ä¸­ï¼Œä¸‰è§’å½¢å¯èƒ½æ˜¯éšå¼è¡¨ç¤ºçš„ï¼Œé€šè¿‡è¾¹å’Œé¡¶ç‚¹å°±å¯ä»¥æ¨æ–­å‡ºæ¥ã€‚

### 4. ä¸‰è§’å‰–åˆ†(Delaunay Triangulation)

Tinfour å®ç°äº† Delaunay ä¸‰è§’å‰–åˆ†ç®—æ³•ï¼Œè¿™æ˜¯ç”Ÿæˆ TIN çš„å…³é”®æ­¥éª¤ã€‚è¯¥ç®—æ³•ç¡®ä¿äº†ä»»ä½•åœ†å‘¨ä¸Šæœ€å¤šåªæœ‰ä¸‰ä¸ªé¡¶ç‚¹ï¼Œä¸”æ²¡æœ‰å…¶ä»–é¡¶ç‚¹åœ¨æ­¤åœ†å†…ï¼Œè¿™æ ·èƒ½å¤Ÿæœ€å¤§åŒ–æœ€å°è§’ï¼Œé¿å…ç‹­é•¿çš„ä¸‰è§’å½¢ã€‚å‰–åˆ†ç®—æ³•æ˜¯ Tinfour ä¸­æœ€æ ¸å¿ƒå’Œæœ€å¤æ‚çš„éƒ¨åˆ†ä¹‹ä¸€ã€‚

### 5. çº¦æŸæ€§ç‰¹å¾(Constrained Features)

Tinfour å¯ä»¥å¤„ç†å…·æœ‰çº¿æ€§çº¦æŸçš„æ•°æ®ï¼Œæ¯”å¦‚æ²³æµã€é“è·¯ç­‰ã€‚è¿™äº›çº¦æŸæ€§ç‰¹å¾ä¼šå½±å“ TIN çš„ç”Ÿæˆï¼Œå› ä¸ºå®ƒä»¬éœ€è¦æŒ‰ç…§ç‰¹å®šçš„çº¿æ€§è·¯å¾„è€Œéä»…ä»…ç¬¦åˆ Delaunay æ¡ä»¶è¿›è¡Œä¸‰è§’åŒ–ã€‚

### 6. æ’å€¼å’Œæ›²é¢åˆ†æ(Interpolation and Surface Analysis)

é™¤äº†ç”Ÿæˆ TIN å¤–ï¼ŒTinfour è¿˜æä¾›ä¸€ç³»åˆ—ç”¨äºåˆ†æå’Œæ’å€¼çš„å·¥å…·ï¼Œä¾‹å¦‚ç¡®å®šç»™å®šç‚¹çš„é«˜åº¦ï¼Œæˆ–è€…è®¡ç®—æ›²é¢çš„å¡åº¦å’Œæ–¹å‘ã€‚

### 7. IO Utilities

è¾“å…¥è¾“å‡º (IO) å·¥å…·ç”¨äºè¯»å–å’Œå†™å…¥ä¸ TIN ç›¸å…³çš„æ•°æ®æ ¼å¼ï¼Œæ¯”å¦‚ ESRI çš„ shapefile æˆ–å…¶ä»– GIS æ ‡å‡†æ ¼å¼ã€‚

### æºç ç»“æ„

Tinfour çš„æºä»£ç é€šå¸¸æŒ‰åŠŸèƒ½æ¨¡å—ç»„ç»‡æˆä¸åŒçš„åŒ…ã€‚ä¾‹å¦‚ï¼š

- `org.tinfour.common`: åŒ…å«é€šç”¨ç±»ï¼Œå¦‚é¡¶ç‚¹ã€è¾¹ç­‰ã€‚
- `org.tinfour.standard`: åŒ…å«æ ‡å‡†çš„ TIN å¤„ç†ç®—æ³•ã€‚
- `org.tinfour.gis`: åŒ…å« GIS æ•°æ®æ¥å£ç›¸å…³çš„ç±»ã€‚
- `org.tinfour.interpolation`: åŒ…å«æ’å€¼ç®—æ³•å’Œå·¥å…·ã€‚
- `org.tinfour.utils`: åŒ…å«åŠ©æ‰‹å‡½æ•°å’Œå®ç”¨å·¥å…·ã€‚

ç”±äº Tinfour çš„æºä»£ç æ˜¯å¼€æºçš„ï¼Œä½ å¯ä»¥åœ¨ GitHub æˆ–å…¶ä»–ä»£ç æ‰˜ç®¡å¹³å°æ‰¾åˆ°å®ƒã€‚é˜…è¯»å’Œç†è§£å…¶æºä»£ç éœ€è¦ä¸€å®šçš„æ—¶é—´å’Œè€å¿ƒï¼Œå°¤å…¶æ˜¯å¯¹æ¶‰åŠåˆ°çš„ç©ºé—´æ•°æ®å¤„ç†ç®—æ³•æœ‰æ‰€äº†è§£ä¼šæ›´åŠ æœ‰å¸®åŠ©ã€‚å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œæˆ‘å»ºè®®ä½ ç›´æ¥æŸ¥çœ‹ Tinfour çš„æºä»£ç ä»¥è·å¾—æ›´è¯¦ç»†çš„äº†è§£ã€‚

# ä¾‹å­

```java
import org.tinfour.common.IConstraint;
import org.tinfour.common.SimpleTriangle;
import org.tinfour.common.Vertex;
import org.tinfour.standard.IncrementalTin;

import java.util.ArrayList;
import java.util.List;

// ç¤ºä¾‹ï¼šåˆ›å»ºå¹¶ä½¿ç”¨ IncrementalTin å¤„ç†ç¦»æ•£ç‚¹å’Œçº¦æŸè¾¹ç•Œ

// å‡è®¾ vertices æ˜¯ä¸€ä¸ª Vertex ç±»å‹çš„åˆ—è¡¨ï¼ŒåŒ…å«æ‰€æœ‰ç¦»æ•£ç‚¹
List<Vertex> vertices = new ArrayList<>();
// ... åœ¨æ­¤æ·»åŠ ä½ çš„ç‚¹æ•°æ® ...

// å‡è®¾ borderVertices æ˜¯ä¸€ä¸ª Vertex ç±»å‹çš„åˆ—è¡¨ï¼ŒåŒ…å«å¤–éƒ¨è¾¹ç•Œç‚¹
List<Vertex> borderVertices = new ArrayList<>();
// ... åœ¨æ­¤æ·»åŠ å¤–éƒ¨è¾¹ç•Œç‚¹ ...

// å‡è®¾ innerBoundaryVertices æ˜¯ä¸€ä¸ª Vertex ç±»å‹çš„åˆ—è¡¨ï¼ŒåŒ…å«å†…éƒ¨è¾¹ç•Œç‚¹
List<Vertex> innerBoundaryVertices = new ArrayList<>();
// ... åœ¨æ­¤æ·»åŠ å†…éƒ¨è¾¹ç•Œç‚¹ ...

IncrementalTin tin = new IncrementalTin(); // åˆ›å»ºä¸‰è§’å‰–åˆ†å®ä¾‹

// æ·»åŠ ç¦»æ•£ç‚¹åˆ° TIN
for (Vertex v : vertices) {
    tin.add(v);
}

// åˆ›å»ºå¤–éƒ¨è¾¹ç•Œçº¦æŸå¹¶æ·»åŠ åˆ° TIN
IConstraint outerBoundary = createBoundaryConstraint(borderVertices);
tin.addConstraints(Collections.singletonList(outerBoundary), true);

// åˆ›å»ºå†…éƒ¨è¾¹ç•Œçº¦æŸï¼ˆå¦‚æœæœ‰ï¼‰å¹¶æ·»åŠ åˆ° TIN
IConstraint innerBoundary = createBoundaryConstraint(innerBoundaryVertices);
tin.addConstraints(Collections.singletonList(innerBoundary), true);

// å¯¹äºä¸Šè¿° `createBoundaryConstraint` å‡½æ•°ï¼Œä½ éœ€è¦å®ç°å®ƒä»¥åˆ›å»ºçº¦æŸ
// è¿™ä¸ªå‡½æ•°é€šå¸¸ä¼šåˆ›å»ºä¸€ä¸ª LinearConstraint ç±»å‹çš„å¯¹è±¡ï¼Œå¹¶å°†è¾¹ç•Œç‚¹ä½œä¸ºå…¶é¡¶ç‚¹æ·»åŠ è¿›å»

// å®Œæˆä¸‰è§’å‰–åˆ†åè·å–ä¸‰è§’å½¢åˆ—è¡¨
List<SimpleTriangle> triangles = tin.getSimpleTriangles();

// ç°åœ¨ triangles åŒ…å«äº† TIN ç»“æ„çš„ä¸‰è§’å½¢åˆ—è¡¨ï¼Œå¯ä»¥è¿›è¡Œè¿›ä¸€æ­¥æ“ä½œ

```

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª `IncrementalTin` å¯¹è±¡æ¥ç®¡ç†ä¸‰è§’å‰–åˆ†è¿‡ç¨‹ã€‚ç„¶åï¼Œæˆ‘ä»¬åˆ†åˆ«å‘å…¶ä¸­æ·»åŠ äº†ç¦»æ•£ç‚¹ã€å¤–éƒ¨è¾¹ç•Œç‚¹å’Œå†…éƒ¨è¾¹ç•Œç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ä½œä¸ºçº¦æŸã€‚è¿™äº›éƒ½é€šè¿‡è°ƒç”¨ `add(...)` å’Œ `addConstraints(...)` æ–¹æ³•å®Œæˆã€‚

æ³¨æ„ï¼Œ`createBoundaryConstraint` æ–¹æ³•æ˜¯å‡è®¾å­˜åœ¨çš„æ–¹æ³•ï¼Œä½ éœ€è¦è‡ªè¡Œå®ç°å®ƒæ¥åˆ›å»ºåˆé€‚çš„ `IConstraint` å¯¹è±¡ï¼ˆç»§æ‰¿è‡ª Tinfour åº“ï¼‰ã€‚è¿™ä¸ªå‡½æ•°åº”è¯¥æ¥æ”¶ä¸€ä¸ªé¡¶ç‚¹åˆ—è¡¨ï¼Œå¹¶æ ¹æ®è¿™äº›é¡¶ç‚¹åˆ›å»ºä¸€ä¸ªçº¿æ€§çº¦æŸï¼Œè¿™äº›çº¦æŸå®šä¹‰äº† TIN ä¸­çš„ä¸å¯ç©¿è¶Šè¾¹ç•Œã€‚